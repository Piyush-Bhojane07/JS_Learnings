What are the advantages of StyleSheet API over inline styles?
200. How does StyleSheet optimize style performance?
201. How do you create and use StyleSheets?
202. How do you handle dynamic styles with StyleSheet?
I notice these questions are about React Native's StyleSheet API, not regular web CSS. Let me answer them from a React Native perspective:

199. Advantages of StyleSheet API over Inline Styles
javascript
// ❌ Inline styles (not recommended)
<View style={{ backgroundColor: 'red', padding: 10 }} />

// ✅ StyleSheet API (recommended)
<View style={styles.container} />
Advantages:

Performance: Styles are created once and reused

Validation: Style properties are validated at creation time

Maintainability: Separates styles from component logic

Code reuse: Styles can be shared across components

Better error messages: Invalid properties show warnings immediately

200. How StyleSheet Optimizes Performance
javascript
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});

// Behind the scenes:
// 1. Styles are serialized into numbers (IDs)
// 2. Bridge communication is minimized
// 3. No repeated style object creation on re-renders
// 4. Style references remain consistent
Optimization Techniques:

Style ID referencing: Instead of sending full style objects to native side

Memoization: Styles are cached and reused

Reduced bridge traffic: Less data passed between JS and native threads

201. Creating and Using StyleSheets
javascript
import { StyleSheet, View, Text } from 'react-native';

// Create StyleSheet
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  button: {
    backgroundColor: 'blue',
    padding: 15,
    borderRadius: 5,
  },
});

// Use in components
const MyComponent = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.header}>Hello World</Text>
      <View style={styles.button} />
    </View>
  );
};
202. Handling Dynamic Styles with StyleSheet
javascript
import { StyleSheet } from 'react-native';

// Method 1: Array composition
const MyComponent = ({ isActive, type }) => {
  return (
    <View style={[
      styles.container,
      isActive && styles.active,
      type === 'error' && styles.error
    ]} />
  );
};

// Method 2: StyleSheet.flatten
const getDynamicStyle = (isPrimary) => {
  return StyleSheet.flatten([
    styles.button,
    isPrimary ? styles.primary : styles.secondary
  ]);
};

// Method 3: Using React hooks for dynamic styles
const useDynamicStyles = (backgroundColor) => {
  return StyleSheet.create({
    box: {
      backgroundColor,
      padding: 10,
      borderRadius: 5,
    },
  });
};

// Method 4: Conditional style objects
const dynamicStyles = StyleSheet.create({
  container: {
    flex: 1,
  },
  active: {
    backgroundColor: 'green',
  },
  inactive: {
    backgroundColor: 'red',
  },
});

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  active: {
    backgroundColor: 'green',
  },
  error: {
    backgroundColor: 'red',
  },
  button: {
    padding: 15,
  },
  primary: {
    backgroundColor: 'blue',
  },
  secondary: {
    backgroundColor: 'gray',
  },
});
Best Practices:
javascript
// ✅ Good - Static styles in StyleSheet
const styles = StyleSheet.create({
  base: { padding: 10 },
  dynamic: (color) => ({ backgroundColor: color }), // Not valid!
});

// ✅ Good - Dynamic styles with composition
<View style={[styles.base, { backgroundColor: dynamicColor }]} />

// ✅ Good - Using libraries for complex dynamic styles
import { useStyle } from 'react-native-style-utilities';
Key Points:

Use StyleSheet.create() for static styles

Use array composition style={[style1, style2]} for dynamic styles

Avoid creating new style objects in render methods

Use StyleSheet.flatten() when you need computed style values

This approach gives you the best of both worlds: performance of StyleSheet with flexibility of dynamic styling!

203. How do you combine multiple styles?
204. How do you create responsive designs with StyleSheet?
205. How do you handle platform-specific styles?
206. How does StyleSheet.create() optimize performance?
203. How to Combine Multiple Styles
javascript
import { StyleSheet, View } from 'react-native';

const styles = StyleSheet.create({
  container: {
    padding: 20,
    backgroundColor: '#fff',
  },
  bordered: {
    borderWidth: 1,
    borderColor: '#ccc',
  },
  large: {
    padding: 30,
  },
  error: {
    backgroundColor: '#ffebee',
  }
});

// Method 1: Array syntax (most common)
const MyComponent = ({ hasError, isLarge }) => {
  return (
    <View style={[
      styles.container,
      styles.bordered,
      isLarge && styles.large,
      hasError && styles.error
    ]} />
  );
};

// Method 2: StyleSheet.flatten for computed styles
const getCombinedStyle = (isActive) => {
  return StyleSheet.flatten([
    styles.container,
    styles.bordered,
    isActive ? styles.active : styles.inactive
  ]);
};

// Method 3: Using spread operator with caution
const combinedStyle = {
  ...styles.container,
  ...styles.bordered,
  margin: 10, // Additional inline style
};

// Method 4: Conditional object
const getDynamicStyle = (type) => {
  const typeStyles = {
    primary: styles.primary,
    secondary: styles.secondary,
    danger: styles.danger,
  };
  
  return [styles.base, typeStyles[type] || styles.default];
};
204. Responsive Designs with StyleSheet
javascript
import { StyleSheet, Dimensions, PixelRatio } from 'react-native';

const { width, height } = Dimensions.get('window');

// Responsive units
const responsive = {
  windowWidth: width,
  windowHeight: height,
  pixelRatio: PixelRatio.get(),
};

// Method 1: Using Dimensions API
const styles = StyleSheet.create({
  container: {
    width: width * 0.9, // 90% of screen width
    height: height * 0.5, // 50% of screen height
    padding: width * 0.05, // 5% of screen width
  },
  font: {
    fontSize: width * 0.04, // Responsive font size
  },
});

// Method 2: Using Platform-specific breakpoints
const getResponsiveStyle = () => {
  const isSmallScreen = width < 375;
  const isTablet = width > 768;

  return StyleSheet.create({
    container: {
      padding: isTablet ? 40 : isSmallScreen ? 15 : 20,
      fontSize: isTablet ? 24 : isSmallScreen ? 14 : 16,
    },
    grid: {
      flexDirection: isTablet ? 'row' : 'column',
    }
  });
};

// Method 3: Using hooks for responsiveness
import { useWindowDimensions } from 'react-native';

const useResponsiveStyles = () => {
  const { width, height } = useWindowDimensions();
  
  return StyleSheet.create({
    container: {
      padding: width * 0.05,
      margin: height * 0.02,
    },
    text: {
      fontSize: width < 375 ? 14 : 16,
    }
  });
};
205. Platform-Specific Styles
javascript
import { StyleSheet, Platform, Dimensions } from 'react-native';

// Method 1: Platform.OS detection
const styles = StyleSheet.create({
  container: {
    padding: Platform.OS === 'ios' ? 20 : 15,
    marginTop: Platform.OS === 'android' ? 10 : 0,
    shadowColor: Platform.OS === 'ios' ? '#000' : null,
    shadowOffset: Platform.OS === 'ios' ? { width: 0, height: 2 } : null,
    shadowOpacity: Platform.OS === 'ios' ? 0.1 : null,
    elevation: Platform.OS === 'android' ? 3 : 0, // Android shadow
  },
});

// Method 2: Platform.select for cleaner code
const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        backgroundColor: 'blue',
        padding: 20,
      },
      android: {
        backgroundColor: 'green',
        padding: 15,
        elevation: 5,
      },
      web: {
        backgroundColor: 'red',
        padding: 25,
        cursor: 'pointer',
      },
    }),
    borderRadius: 5,
  },
  header: {
    fontSize: Platform.select({ 
      ios: 18, 
      android: 16, 
      web: 20 
    }),
    fontFamily: Platform.OS === 'ios' ? 'Helvetica' : 'Roboto',
  },
});

// Method 3: Separate platform-specific style files
// styles.ios.js
export const iosStyles = StyleSheet.create({
  container: { padding: 20 },
});

// styles.android.js  
export const androidStyles = StyleSheet.create({
  container: { padding: 15 },
});

// Method 4: Using platform-specific extensions
// Component.ios.js & Component.android.js
206. How StyleSheet.create() Optimizes Performance
javascript
// ❌ Without StyleSheet.create (less efficient)
const styles = {
  container: { padding: 10 },
  text: { fontSize: 16 },
};
// New object created on every render

// ✅ With StyleSheet.create (optimized)
const styles = StyleSheet.create({
  container: { padding: 10 },
  text: { fontSize: 16 },
});
// Styles are optimized and cached
Performance Optimizations:

1. Style ID Referencing
javascript
// Behind the scenes:
const styles = StyleSheet.create({
  container: { padding: 10 }, // → becomes { container: 1 }
  text: { fontSize: 16 },     // → becomes { text: 2 }
});

// Native side receives numeric IDs instead of full objects
2. Serialization & Caching
javascript
// Styles are serialized once
const serializedStyles = {
  container: JSON.stringify({ padding: 10 }),
  text: JSON.stringify({ fontSize: 16 }),
};

// Subsequent references use cached versions
3. Bridge Optimization
javascript
// ❌ Inline styles - sends full object every time
<View style={{padding: 10}} /> 
// Bridge message: { type: 'style', value: {padding: 10} }

// ✅ StyleSheet - sends only ID
<View style={styles.container} />
// Bridge message: { type: 'style', value: 1 }
4. Validation & Error Detection
javascript
const styles = StyleSheet.create({
  container: {
    padding: 10,
    invalidProp: 'value', // ❌ Warning at creation time!
  },
});
// Errors caught during development, not in production
5. Memory Efficiency
javascript
// Multiple components can reference same style object
const sharedStyles = StyleSheet.create({
  card: { margin: 10, padding: 15 },
});

// Used across multiple components - same memory reference
<Component1 style={sharedStyles.card} />
<Component2 style={sharedStyles.card} />
Key Performance Benefits:

✅ Reduced bridge traffic (smaller messages)

✅ Faster re-renders (cached style references)

✅ Memory efficiency (shared style objects)

✅ Early validation (catch errors during development)

✅ Better tooling (React Native Debugger support)

This makes StyleSheet.create() essential for performance in React Native applications!
----------------------------------------------------------------------------

Explanation: Style Serialization & Caching
Let me explain the serialization concept in detail:

What is Serialization?
javascript
// Original style object
const styleObject = { 
  padding: 10, 
  backgroundColor: 'red',
  borderRadius: 5 
};

// Serialization converts it to a string
const serialized = JSON.stringify(styleObject);
// Result: '{"padding":10,"backgroundColor":"red","borderRadius":5}'
How React Native Uses This:
javascript
// Behind the scenes in React Native
const styleRegistry = new Map();
let nextStyleId = 1;

function registerStyle(styleObject) {
  const serialized = JSON.stringify(styleObject);
  
  // Check if style already exists
  if (styleRegistry.has(serialized)) {
    return styleRegistry.get(serialized); // Return existing ID
  }
  
  // Register new style
  const styleId = nextStyleId++;
  styleRegistry.set(serialized, styleId);
  return styleId;
}

// Example usage:
const styles = StyleSheet.create({
  container: { padding: 10, backgroundColor: 'red' },
  text: { fontSize: 16, color: 'blue' }
});

// What happens:
// container → registerStyle({padding:10, backgroundColor:'red'}) → returns 1
// text → registerStyle({fontSize:16, color:'blue'}) → returns 2
Visual Example:
javascript
// First time - styles are created and serialized
const styles = StyleSheet.create({
  box: { margin: 10, padding: 15 }, // → Serialized: '{"margin":10,"padding":15}'
  card: { backgroundColor: 'white' } // → Serialized: '{"backgroundColor":"white"}'
});

// These become:
// styles = { box: 1, card: 2 }

// When component renders:
<View style={styles.box} />
// Instead of sending {margin:10, padding:15} to native side,
// React Native just sends the ID: 1

// Reusing the same style:
<AnotherComponent style={styles.box} />
// Again, just sends ID: 1 - no serialization needed!
Performance Benefit:
javascript
// ❌ Without caching (inefficient)
function renderComponent() {
  const style = { padding: 10 }; // New object every render
  return <View style={style} />; // Serialized every time
}

// ✅ With StyleSheet.create (optimized)
const styles = StyleSheet.create({
  padded: { padding: 10 } // Serialized ONCE
});

function renderComponent() {
  return <View style={styles.padded} />; // Reuses cached ID
}
Memory Optimization:
javascript
// Multiple components using same style
const sharedStyle = StyleSheet.create({ button: { padding: 15 } });

// All these use the same serialized version
<Button style={sharedStyle.button} />
<AnotherButton style={sharedStyle.button} />
<DifferentButton style={sharedStyle.button} />

// Memory usage: 
// - One serialized string: '{"padding":15}'
// - One style ID mapping
// vs
// - Three separate objects
// - Three serialization operations
Key Takeaway: Style serialization and caching prevents redundant processing and reduces bridge communication, making your app faster and more memory-efficient!

type of styling
Types of Styling in React Native
Here are the main approaches to styling in React Native:

1. StyleSheet API (Built-in)
javascript
import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: 'white',
  },
  text: {
    fontSize: 16,
    color: '#333',
  },
});
2. Inline Styles
javascript
// Simple inline
<View style={{ padding: 10, backgroundColor: 'red' }} />

// Dynamic inline
<View style={{
  padding: isActive ? 15 : 10,
  backgroundColor: hasError ? 'red' : 'green'
}} />
3. Conditional Style Arrays
javascript
<View style={[
  styles.base,
  isActive && styles.active,
  isLarge && styles.large,
  { marginTop: customMargin } // Inline override
]} />
4. Platform-Specific Styles
javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    padding: Platform.OS === 'ios' ? 20 : 15,
    ...Platform.select({
      ios: { shadowColor: '#000', shadowOpacity: 0.1 },
      android: { elevation: 3 },
    }),
  },
});
5. Styled Components (Third-party)
javascript
import styled from 'styled-components/native';

const StyledView = styled.View`
  flex: 1;
  padding: 20px;
  background-color: ${props => props.primary ? 'blue' : 'white'};
`;

const StyledText = styled.Text`
  font-size: 16px;
  color: #333;
  font-weight: ${props => props.bold ? 'bold' : 'normal'};
`;

// Usage
<StyledView primary>
  <StyledText bold>Hello World</StyledText>
</StyledView>
6. CSS-in-JS Libraries (Emotion, etc.)
javascript
import { css } from '@emotion/native';

const containerStyle = css`
  flex: 1;
  padding: 20px;
  background-color: ${props => props.theme.background};
`;

<View style={containerStyle}>
  <Text>Content</Text>
</View>
7. Utility-First CSS (Tailwind-like)
javascript
// Using libraries like twrnc or nativewind
import tw from 'twrnc';

<View style={tw`flex-1 p-4 bg-white`}>
  <Text style={tw`text-lg font-bold text-gray-800`}>
    Hello World
  </Text>
</View>
8. Theme-Based Styling
javascript
// Using React Context or styled-components theme
const theme = {
  colors: {
    primary: '#007AFF',
    secondary: '#5856D6',
    background: '#FFFFFF',
  },
  spacing: {
    small: 8,
    medium: 16,
    large: 24,
  },
};

const styles = StyleSheet.create({
  container: {
    padding: theme.spacing.medium,
    backgroundColor: theme.colors.background,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.small,
  },
});
9. Dynamic Style Functions
javascript
const createDynamicStyles = (theme, isDark) => {
  return StyleSheet.create({
    container: {
      backgroundColor: isDark ? '#000' : '#FFF',
      padding: theme.spacing.medium,
    },
    text: {
      color: isDark ? '#FFF' : '#000',
      fontSize: theme.typography.body,
    },
  });
};

// Usage in component
const styles = createDynamicStyles(theme, isDarkMode);
10. Component Composition
javascript
// Base components with predefined styles
const BaseView = ({ children, style, ...props }) => (
  <View style={[styles.baseView, style]} {...props}>
    {children}
  </View>
);

const BaseText = ({ children, style, variant = 'body', ...props }) => (
  <Text style={[styles.baseText, styles[variant], style]} {...props}>
    {children}
  </Text>
);

const styles = StyleSheet.create({
  baseView: { padding: 16 },
  baseText: { fontFamily: 'System' },
  body: { fontSize: 16 },
  title: { fontSize: 24, fontWeight: 'bold' },
  caption: { fontSize: 12, color: '#666' },
});

// Usage
<BaseView>
  <BaseText variant="title">Hello</BaseText>
  <BaseText variant="body">World</BaseText>
</BaseView>
11. Responsive Style Hooks
javascript
import { useWindowDimensions } from 'react-native';

const useResponsiveStyles = () => {
  const { width, height } = useWindowDimensions();
  
  return StyleSheet.create({
    container: {
      padding: width > 768 ? 40 : 20,
      flexDirection: width > 768 ? 'row' : 'column',
    },
    text: {
      fontSize: width > 768 ? 18 : 14,
    },
  });
};

// Usage in component
const responsiveStyles = useResponsiveStyles();
12. Animation Styles
javascript
import { Animated } from 'react-native';

const animatedStyle = {
  opacity: fadeAnim, // Animated.Value
  transform: [{ translateY: slideAnim }],
};

<Animated.View style={[styles.container, animatedStyle]}>
  <Text>Animated Content</Text>
</Animated.View>
Comparison Table:
Method	Pros	Cons	Use Case
StyleSheet	Performance, Validation	Less dynamic	Static styles
Inline	Quick, Dynamic	Poor performance	Simple components
Styled Components	Dynamic, Theming	Bundle size	Complex apps
Utility CSS	Rapid development	Learning curve	Prototyping
Theme-Based	Consistency	Setup complexity	Large apps
Best Practices:
Use StyleSheet.create() for static styles

Combine with arrays for dynamic styles

Use third-party libraries for complex theming

Create reusable base components

Implement responsive design hooks


---------------------------------------

type of styling
Types of Styling in React Native
Here are the main approaches to styling in React Native:

1. StyleSheet API (Built-in)
javascript
import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: 'white',
  },
  text: {
    fontSize: 16,
    color: '#333',
  },
});
2. Inline Styles
javascript
// Simple inline
<View style={{ padding: 10, backgroundColor: 'red' }} />

// Dynamic inline
<View style={{
  padding: isActive ? 15 : 10,
  backgroundColor: hasError ? 'red' : 'green'
}} />
3. Conditional Style Arrays
javascript
<View style={[
  styles.base,
  isActive && styles.active,
  isLarge && styles.large,
  { marginTop: customMargin } // Inline override
]} />
4. Platform-Specific Styles
javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    padding: Platform.OS === 'ios' ? 20 : 15,
    ...Platform.select({
      ios: { shadowColor: '#000', shadowOpacity: 0.1 },
      android: { elevation: 3 },
    }),
  },
});
5. Styled Components (Third-party)
javascript
import styled from 'styled-components/native';

const StyledView = styled.View`
  flex: 1;
  padding: 20px;
  background-color: ${props => props.primary ? 'blue' : 'white'};
`;

const StyledText = styled.Text`
  font-size: 16px;
  color: #333;
  font-weight: ${props => props.bold ? 'bold' : 'normal'};
`;

// Usage
<StyledView primary>
  <StyledText bold>Hello World</StyledText>
</StyledView>
6. CSS-in-JS Libraries (Emotion, etc.)
javascript
import { css } from '@emotion/native';

const containerStyle = css`
  flex: 1;
  padding: 20px;
  background-color: ${props => props.theme.background};
`;

<View style={containerStyle}>
  <Text>Content</Text>
</View>
7. Utility-First CSS (Tailwind-like)
javascript
// Using libraries like twrnc or nativewind
import tw from 'twrnc';

<View style={tw`flex-1 p-4 bg-white`}>
  <Text style={tw`text-lg font-bold text-gray-800`}>
    Hello World
  </Text>
</View>
8. Theme-Based Styling
javascript
// Using React Context or styled-components theme
const theme = {
  colors: {
    primary: '#007AFF',
    secondary: '#5856D6',
    background: '#FFFFFF',
  },
  spacing: {
    small: 8,
    medium: 16,
    large: 24,
  },
};

const styles = StyleSheet.create({
  container: {
    padding: theme.spacing.medium,
    backgroundColor: theme.colors.background,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.small,
  },
});
9. Dynamic Style Functions
javascript
const createDynamicStyles = (theme, isDark) => {
  return StyleSheet.create({
    container: {
      backgroundColor: isDark ? '#000' : '#FFF',
      padding: theme.spacing.medium,
    },
    text: {
      color: isDark ? '#FFF' : '#000',
      fontSize: theme.typography.body,
    },
  });
};

// Usage in component
const styles = createDynamicStyles(theme, isDarkMode);
10. Component Composition
javascript
// Base components with predefined styles
const BaseView = ({ children, style, ...props }) => (
  <View style={[styles.baseView, style]} {...props}>
    {children}
  </View>
);

const BaseText = ({ children, style, variant = 'body', ...props }) => (
  <Text style={[styles.baseText, styles[variant], style]} {...props}>
    {children}
  </Text>
);

const styles = StyleSheet.create({
  baseView: { padding: 16 },
  baseText: { fontFamily: 'System' },
  body: { fontSize: 16 },
  title: { fontSize: 24, fontWeight: 'bold' },
  caption: { fontSize: 12, color: '#666' },
});

// Usage
<BaseView>
  <BaseText variant="title">Hello</BaseText>
  <BaseText variant="body">World</BaseText>
</BaseView>
11. Responsive Style Hooks
javascript
import { useWindowDimensions } from 'react-native';

const useResponsiveStyles = () => {
  const { width, height } = useWindowDimensions();
  
  return StyleSheet.create({
    container: {
      padding: width > 768 ? 40 : 20,
      flexDirection: width > 768 ? 'row' : 'column',
    },
    text: {
      fontSize: width > 768 ? 18 : 14,
    },
  });
};

// Usage in component
const responsiveStyles = useResponsiveStyles();
12. Animation Styles
javascript
import { Animated } from 'react-native';

const animatedStyle = {
  opacity: fadeAnim, // Animated.Value
  transform: [{ translateY: slideAnim }],
};

<Animated.View style={[styles.container, animatedStyle]}>
  <Text>Animated Content</Text>
</Animated.View>
Comparison Table:
Method	Pros	Cons	Use Case
StyleSheet	Performance, Validation	Less dynamic	Static styles
Inline	Quick, Dynamic	Poor performance	Simple components
Styled Components	Dynamic, Theming	Bundle size	Complex apps
Utility CSS	Rapid development	Learning curve	Prototyping
Theme-Based	Consistency	Setup complexity	Large apps
Best Practices:
Use StyleSheet.create() for static styles

Combine with arrays for dynamic styles

Use third-party libraries for complex theming

Create reusable base components

Implement responsive design hooks

Choose the approach that best fits your project's complexity and team preferences!

stylesheet vs nativewind which to preper why , which is better,
StyleSheet vs NativeWind: Detailed Comparison
StyleSheet (Built-in)
Pros:
javascript
import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: 'white',
    borderRadius: 8,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
});
✅ Advantages:

Zero dependencies - Built into React Native

Best performance - Optimized by React Native team

TypeScript support - Excellent autocomplete

Runtime validation - Catches invalid properties

Predictable - No build process required

Battle-tested - Used in production by thousands of apps

Cons:
Verbose - More code for simple styles

No utilities - Everything must be defined manually

Limited dynamic styling - Complex conditional logic

No design system - Manual consistency management

NativeWind (Tailwind for React Native)
Pros:
javascript
import tw from 'twrnc';

// Usage
<View style={tw`flex-1 p-4 bg-white rounded-lg`}>
  <Text style={tw`text-2xl font-bold text-gray-800`}>
    Hello World
  </Text>
</View>

// Dynamic styles
<View style={tw`p-4 ${isActive ? 'bg-blue-500' : 'bg-gray-200'}`}>
  <Text style={tw`${isLarge ? 'text-lg' : 'text-base'} font-medium`}>
    Dynamic Text
  </Text>
</View>
✅ Advantages:

Extremely fast development - Rapid prototyping

Consistent design system - Predefined scales

Utility-first - No naming things

Responsive design - Built-in breakpoints

Dark mode support - Easy theme switching

Smaller bundle - Only used utilities are included

Cons:
Learning curve - Must learn Tailwind classes

Build process - Requires configuration

Runtime overhead - String parsing to styles

Less explicit - Harder to understand at glance

Dependency - Third-party library risk

Performance Comparison
StyleSheet Performance:
javascript
// Optimized - styles created once
const styles = StyleSheet.create({
  container: { padding: 20, margin: 10 } // ← Serialized once
});

// Renders fast - just reference to style ID
<View style={styles.container} />
NativeWind Performance:
javascript
// Runtime parsing required
<View style={tw`p-4 m-2 bg-blue-500`} />
// Behind the scenes:
// 1. Parse string "p-4 m-2 bg-blue-500"
// 2. Convert to style object {padding: 16, margin: 8, backgroundColor: '#3b82f6'}
// 3. Cache result for same string
When to Choose StyleSheet:
Choose StyleSheet if:
javascript
// Enterprise apps with complex logic
const ComplexComponent = ({ data, theme, layout }) => {
  const styles = useMemo(() => StyleSheet.create({
    container: {
      padding: theme.spacing.large,
      backgroundColor: theme.colors.background,
      flexDirection: layout.horizontal ? 'row' : 'column',
    },
    // Complex computed styles
    dynamicSection: {
      width: data.items.length > 5 ? '80%' : '100%',
      opacity: data.isLoading ? 0.5 : 1,
    },
  }), [data, theme, layout]);

  return <View style={styles.container}>...</View>;
};
✅ Ideal for:

Large enterprise applications

Performance-critical apps

Teams preferring explicit styles

Apps with complex conditional styling

Projects avoiding third-party dependencies

When to Choose NativeWind:
Choose NativeWind if:
javascript
// Rapid prototyping and consistent design
const QuickComponent = () => (
  <View style={tw`flex-1 p-6 bg-white dark:bg-gray-900`}>
    <Text style={tw`text-xl font-bold text-gray-800 dark:text-white`}>
      Quick Title
    </Text>
    <View style={tw`flex-row justify-between items-center mt-4`}>
      <Button style={tw`px-4 py-2 bg-blue-500 rounded-lg`}>
        <Text style={tw`text-white font-medium`}>Action</Text>
      </Button>
    </View>
  </View>
);
✅ Ideal for:

Startups and MVPs

Rapid prototyping

Teams familiar with Tailwind CSS

Design-system driven development

Apps needing consistent spacing/colors

Real-World Scenarios:
Scenario 1: Complex Business Logic (StyleSheet Wins)
javascript
// StyleSheet - Better for complex computed styles
const calculateStyles = (status, priority, userRole) => {
  return StyleSheet.create({
    card: {
      padding: userRole === 'admin' ? 20 : 10,
      backgroundColor: 
        status === 'urgent' ? '#fee2e2' :
        priority === 'high' ? '#fef3c7' : '#ffffff',
      borderLeftWidth: 5,
      borderLeftColor: getStatusColor(status),
    },
  });
};
Scenario 2: Consistent UI Components (NativeWind Wins)
javascript
// NativeWind - Better for consistent design system
const Button = ({ variant = 'primary', size = 'md', children }) => (
  <TouchableOpacity style={tw`
    rounded-lg justify-center items-center
    ${variant === 'primary' ? 'bg-blue-500' : 'bg-gray-200'}
    ${size === 'lg' ? 'px-6 py-4' : 'px-4 py-2'}
    ${variant === 'primary' ? 'shadow-lg' : ''}
  `}>
    <Text style={tw`
      font-semibold
      ${variant === 'primary' ? 'text-white' : 'text-gray-800'}
      ${size === 'lg' ? 'text-lg' : 'text-base'}
    `}>
      {children}
    </Text>
  </TouchableOpacity>
);
Hybrid Approach:
javascript
// Use both - StyleSheet for complex, NativeWind for simple
import { StyleSheet } from 'react-native';
import tw from 'twrnc';

const styles = StyleSheet.create({
  complexAnimation: {
    transform: [{ rotate: rotation.interpolate({...}) }],
    // Complex animated styles
  },
  businessLogic: {
    width: calculateDynamicWidth(data),
    opacity: isLoading ? 0.5 : 1,
  },
});

const Component = () => (
  <View style={[tw`flex-1 p-4 bg-white`, styles.container]}>
    <View style={[tw`rounded-lg border`, styles.complexAnimation]}>
      <Text style={tw`text-lg font-medium`}>Content</Text>
    </View>
  </View>
);
Final Recommendation:
Choose StyleSheet when:
Performance is critical

Building large, complex applications

Team prefers explicit, typed styles

Minimal dependencies desired

Choose NativeWind when:
Rapid development is priority

Team knows Tailwind CSS

Consistent design system needed

Prototyping/MVP development

My Personal Preference:
For production enterprise apps: StyleSheet (performance, stability)
For startups/MVPs: NativeWind (speed, consistency)

Both are excellent choices - it depends on your team, project requirements, and priorities!
---------------------------------------------------------------------------------------------

207. What is NativeWind and how does it bring Tailwind to React Native?
208. How do you configure tailwind.config.js for React Native?
209. How do you handle dark mode with NativeWind?
207. What is NativeWind and How It Brings Tailwind to React Native
NativeWind is a library that brings Tailwind CSS utility classes to React Native, allowing you to use Tailwind's familiar syntax for styling mobile apps.

How It Works:
javascript
// Traditional React Native
<View style={{ padding: 20, backgroundColor: 'white', borderRadius: 8 }}>
  <Text style={{ fontSize: 16, fontWeight: 'bold' }}>Hello</Text>
</View>

// With NativeWind
<View style={tw`p-5 bg-white rounded-lg`}>
  <Text style={tw`text-base font-bold`}>Hello</Text>
</View>
Architecture:
javascript
// Behind the scenes - NativeWind process:
// 1. String parsing: "p-4 bg-blue-500" 
// 2. Style resolution: { padding: 16, backgroundColor: '#3b82f6' }
// 3. Caching: Store computed styles for performance
// 4. React Native rendering: Apply styles to components

// Installation:
npm install nativewind
npm install tailwindcss --save-dev

// The magic happens through:
// - Babel plugin (compile-time optimization)
// - Runtime parser (dynamic class handling)
Key Features:
Utility-first - Use Tailwind classes directly

Responsive design - Breakpoints (sm, md, lg)

Dark mode - Easy dark theme switching

Pseudo-classes - hover, focus, active states

Performance - Caching and optimizations

208. How to Configure tailwind.config.js for React Native
Basic Configuration:
javascript
// tailwind.config.js
module.exports = {
  content: [
    './App.{js,jsx,ts,tsx}',
    './src/**/*.{js,jsx,ts,tsx}',
    './components/**/*.{js,jsx,ts,tsx}'
  ],
  theme: {
    extend: {
      // Custom colors
      colors: {
        primary: '#007AFF',
        secondary: '#5856D6',
        success: '#34C759',
        danger: '#FF3B30',
        custom: {
          50: '#fef2f2',
          100: '#fee2e2',
          // ... more shades
        }
      },
      
      // Custom spacing
      spacing: {
        '13': '3.25rem',
        '15': '3.75rem',
        '128': '32rem',
      },
      
      // Custom font sizes
      fontSize: {
        '2xs': '0.625rem', // 10px
        '3xl': '1.875rem', // 30px
      },
      
      // Custom border radius
      borderRadius: {
        '4xl': '2rem',
      }
    },
  },
  plugins: [],
}
React Native Specific Configuration:
javascript
// tailwind.config.js - Mobile optimized
module.exports = {
  content: [
    './App.{js,jsx,ts,tsx}',
    './src/**/*.{js,jsx,ts,tsx}'
  ],
  theme: {
    extend: {
      colors: {
        // iOS system colors
        system: {
          blue: '#007AFF',
          green: '#34C759',
          indigo: '#5856D6',
          orange: '#FF9500',
          pink: '#FF2D55',
          purple: '#AF52DE',
          red: '#FF3B30',
          teal: '#5AC8FA',
          yellow: '#FFCC00',
        },
        
        // Material Design colors
        material: {
          primary: '#6200EE',
          secondary: '#03DAC6',
        }
      },
      
      // Mobile-first spacing scale
      spacing: {
        '0.5': '2px',
        '1': '4px',
        '1.5': '6px',
        '2': '8px',
        '2.5': '10px',
        '3': '12px',
        '3.5': '14px',
        '4': '16px',
        '5': '20px',
        '6': '24px',
        '7': '28px',
        '8': '32px',
        '9': '36px',
        '10': '40px',
      },
      
      // Mobile font sizes
      fontSize: {
        'xs': ['12px', { lineHeight: '16px' }],
        'sm': ['14px', { lineHeight: '20px' }],
        'base': ['16px', { lineHeight: '24px' }],
        'lg': ['18px', { lineHeight: '28px' }],
        'xl': ['20px', { lineHeight: '28px' }],
        '2xl': ['24px', { lineHeight: '32px' }],
      },
      
      // Safe areas for notches
      padding: {
        'safe-top': 'env(safe-area-inset-top)',
        'safe-bottom': 'env(safe-area-inset-bottom)',
        'safe-left': 'env(safe-area-inset-left)',
        'safe-right': 'env(safe-area-inset-right)',
      }
    },
  },
  
  // Mobile-specific plugins
  plugins: [
    // Custom plugin for platform-specific utilities
    function({ addUtilities }) {
      const newUtilities = {
        '.shadow-ios': {
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 2 },
          shadowOpacity: 0.1,
          shadowRadius: 3.84,
        },
        '.shadow-android': {
          elevation: 5,
        },
      }
      addUtilities(newUtilities)
    }
  ],
}
Babel Configuration:
javascript
// babel.config.js
module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
  plugins: [
    'nativewind/babel',
    // other plugins...
  ],
};

---------------------------------------------------------

209. How to Handle Dark Mode with NativeWind
Method 1: Using useColorScheme Hook
javascript
// App.js or _layout.js (Expo)
import { useColorScheme } from 'react-native';
import { ThemeProvider } from 'nativewind';

function App() {
  const colorScheme = useColorScheme();
  
  return (
    <ThemeProvider value={colorScheme === 'dark' ? 'dark' : 'light'}>
      <YourApp />
    </ThemeProvider>
  );
}
Method 2: Manual Theme Toggle
javascript
// ThemeContext.js
import React, { createContext, useContext, useState } from 'react';
import { ThemeProvider } from 'nativewind';

const ThemeContext = createContext();

export const useTheme = () => useContext(ThemeContext);

export const AppThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <ThemeProvider value={theme}>
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

// Usage in components
const MyComponent = () => {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <View style={tw`flex-1 bg-white dark:bg-gray-900`}>
      <Text style={tw`text-gray-900 dark:text-white`}>
        Current theme: {theme}
      </Text>
      <TouchableOpacity 
        onPress={toggleTheme}
        style={tw`p-4 bg-blue-500 dark:bg-blue-700 rounded-lg`}
      >
        <Text style={tw`text-white`}>Toggle Theme</Text>
      </TouchableOpacity>
    </View>
  );
};
Method 3: Complete Dark Mode Implementation
javascript
// tailwind.config.js - Dark mode configuration
module.exports = {
  darkMode: 'class', // Use class-based dark mode
  content: ['./App.{js,jsx,ts,tsx}', './src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {
      colors: {
        // Light theme colors
        background: '#FFFFFF',
        surface: '#F8F9FA',
        text: '#1F2937',
        
        // Dark theme colors
        dark: {
          background: '#0F172A',
          surface: '#1E293B', 
          text: '#F1F5F9',
        }
      }
    },
  },
}

// hooks/useTheme.js
import { useColorScheme } from 'react-native';
import { useColorScheme as useNativeWindColorScheme } from 'nativewind';

export const useTheme = () => {
  const deviceColorScheme = useColorScheme();
  const { colorScheme, setColorScheme } = useNativeWindColorScheme();
  
  const toggleColorScheme = () => {
    setColorScheme(colorScheme === 'light' ? 'dark' : 'light');
  };

  return {
    colorScheme: colorScheme || deviceColorScheme,
    toggleColorScheme,
    isDark: (colorScheme || deviceColorScheme) === 'dark',
  };
};

// components/ThemeToggle.js
import { Switch } from 'react-native';
import { useTheme } from '../hooks/useTheme';

export const ThemeToggle = () => {
  const { colorScheme, toggleColorScheme, isDark } = useTheme();
  
  return (
    <View style={tw`flex-row items-center p-4 bg-gray-100 dark:bg-gray-800`}>
      <Text style={tw`flex-1 text-gray-900 dark:text-white`}>
        Dark Mode
      </Text>
      <Switch
        value={isDark}
        onValueChange={toggleColorScheme}
        trackColor={{ false: '#767577', true: '#81b0ff' }}
        thumbColor={isDark ? '#f5dd4b' : '#f4f3f4'}
      />
    </View>
  );
};
Method 4: Advanced Dark Mode with Persistence
javascript
// hooks/usePersistedTheme.js
import { useState, useEffect } from 'react';
import { useColorScheme } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const usePersistedTheme = () => {
  const deviceTheme = useColorScheme();
  const [theme, setTheme] = useState(deviceTheme);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    loadTheme();
  }, []);

  const loadTheme = async () => {
    try {
      const savedTheme = await AsyncStorage.getItem('app-theme');
      if (savedTheme) {
        setTheme(savedTheme);
      }
    } catch (error) {
      console.log('Error loading theme:', error);
    } finally {
      setIsLoaded(true);
    }
  };

  const toggleTheme = async (newTheme) => {
    const themeToSet = newTheme || (theme === 'light' ? 'dark' : 'light');
    setTheme(themeToSet);
    try {
      await AsyncStorage.setItem('app-theme', themeToSet);
    } catch (error) {
      console.log('Error saving theme:', error);
    }
  };

  return {
    theme: isLoaded ? theme : deviceTheme,
    toggleTheme,
    isDark: theme === 'dark',
    isLoaded,
  };
};

// App.js
import { ThemeProvider } from 'nativewind';
import { usePersistedTheme } from './hooks/usePersistedTheme';

function App() {
  const { theme, toggleTheme } = usePersistedTheme();

  return (
    <ThemeProvider value={theme}>
      <YourApp onThemeChange={toggleTheme} />
    </ThemeProvider>
  );
}
Dark Mode Usage Examples:
javascript
// Comprehensive dark mode styling
const ProfileScreen = () => {
  return (
    <View style={tw`flex-1 bg-white dark:bg-gray-900`}>
      {/* Header */}
      <View style={tw`p-6 bg-blue-500 dark:bg-blue-800`}>
        <Text style={tw`text-white text-2xl font-bold`}>Profile</Text>
      </View>
      
      {/* Content */}
      <View style={tw`p-6 bg-gray-50 dark:bg-gray-800 flex-1`}>
        <View style={tw`bg-white dark:bg-gray-700 rounded-lg p-4 shadow-sm`}>
          <Text style={tw`text-gray-900 dark:text-white text-lg font-semibold`}>
            John Doe
          </Text>
          <Text style={tw`text-gray-600 dark:text-gray-300 mt-2`}>
            Software Developer
          </Text>
        </View>
        
        {/* Settings list */}
        <View style={tw`mt-4 bg-white dark:bg-gray-700 rounded-lg`}>
          <View style={tw`p-4 border-b border-gray-200 dark:border-gray-600`}>
            <Text style={tw`text-gray-900 dark:text-white`}>Notifications</Text>
          </View>
          <View style={tw`p-4 border-b border-gray-200 dark:border-gray-600`}>
            <Text style={tw`text-gray-900 dark:text-white`}>Privacy</Text>
          </View>
          <View style={tw`p-4`}>
            <Text style={tw`text-gray-900 dark:text-white`}>Help & Support</Text>
          </View>
        </View>
      </View>
    </View>
  );
};
Key Benefits of NativeWind Dark Mode:

✅ Automatic color switching with dark: prefix

✅ Consistent theming across entire app

✅ Performance optimized - no re-renders on theme change

✅ Flexible control - device theme or manual override

✅ Persistence - remember user preference

This makes implementing dark mode in React Native incredibly straightforward

--------------------------------------------------------------------------


210. How do you create responsive designs with NativeWind?
211. How do you handle dynamic classes with conditional rendering?
212. How do you create reusable component variants with Tailwind?
213. What are the performance considerations of using NativeWind?
210. Responsive Designs with NativeWind
NativeWind brings Tailwind's responsive utilities to React Native with breakpoints.

Basic Responsive Design:
javascript
import { useWindowDimensions } from 'react-native';
import tw from 'twrnc';

const ResponsiveComponent = () => {
  const { width } = useWindowDimensions();
  
  return (
    <View style={tw`
      flex-1 
      p-4 
      bg-white
      /* Mobile first, then responsive breakpoints */
      md:flex-row 
      md:p-8
      lg:bg-gray-50
      xl:max-w-6xl
      xl:mx-auto
    `}>
      <View style={tw`
        w-full 
        h-48 
        bg-blue-200
        md:w-1/2 
        md:h-auto
        lg:w-1/3
      `}>
        <Text style={tw`text-base md:text-lg lg:text-xl`}>
          Responsive Text
        </Text>
      </View>
      
      <View style={tw`
        w-full 
        mt-4
        md:w-1/2 
        md:mt-0 
        md:ml-4
        lg:w-2/3
      `}>
        <Text>Content</Text>
      </View>
    </View>
  );
};
Default Breakpoints:
javascript
// NativeWind uses these default breakpoints:
const breakpoints = {
  sm: 640,    // => @media (min-width: 640px)
  md: 768,    // => @media (min-width: 768px) 
  lg: 1024,   // => @media (min-width: 1024px)
  xl: 1280,   // => @media (min-width: 1280px)
  '2xl': 1536, // => @media (min-width: 1536px)
};

// Custom breakpoints in tailwind.config.js
module.exports = {
  theme: {
    screens: {
      'tablet': '768px',
      'laptop': '1024px',
      'desktop': '1280px',
    },
  },
}
Advanced Responsive Patterns:
javascript
// Responsive grid system
const GridComponent = () => (
  <View style={tw`flex-1 p-4`}>
    <View style={tw`
      flex-col
      tablet:flex-row
      tablet:flex-wrap
      tablet:justify-between
    `}>
      {[1, 2, 3, 4, 5, 6].map(item => (
        <View key={item} style={tw`
          w-full mb-4 p-4 bg-white rounded-lg
          tablet:w-[48%]
          laptop:w-[32%]
          desktop:w-[24%]
        `}>
          <Text>Item {item}</Text>
        </View>
      ))}
    </View>
  </View>
);

// Responsive navigation
const Navigation = () => (
  <View style={tw`
    flex-row items-center p-4 bg-gray-800
    laptop:px-8 laptop:py-6
  `}>
    <Text style={tw`
      text-lg text-white font-bold
      laptop:text-2xl
    `}>Logo</Text>
    
    <View style={tw`
      hidden
      laptop:flex laptop:flex-row laptop:ml-8
    `}>
      <Text style={tw`text-white mx-4`}>Home</Text>
      <Text style={tw`text-white mx-4`}>About</Text>
      <Text style={tw`text-white mx-4`}>Contact</Text>
    </View>
    
    {/* Mobile menu button */}
    <View style={tw`
      ml-auto
      laptop:hidden
    `}>
      <Text style={tw`text-white`}>☰</Text>
    </View>
  </View>
);
211. Dynamic Classes with Conditional Rendering
Method 1: Template Literals
javascript
const Button = ({ variant, size, disabled, isLoading }) => {
  const buttonStyles = tw`
    rounded-lg justify-center items-center
    /* Variants */
    ${variant === 'primary' ? 'bg-blue-500' : 
      variant === 'secondary' ? 'bg-gray-500' : 
      variant === 'danger' ? 'bg-red-500' : 'bg-blue-500'}
    
    /* Sizes */
    ${size === 'sm' ? 'px-3 py-2' : 
      size === 'lg' ? 'px-6 py-4' : 'px-4 py-3'}
    
    /* States */
    ${disabled ? 'opacity-50' : ''}
    ${isLoading ? 'opacity-70' : ''}
    
    /* Hover effects */
    ${!disabled && !isLoading ? 'active:opacity-80' : ''}
  `;
  
  const textStyles = tw`
    text-white font-medium
    ${size === 'sm' ? 'text-sm' : 
      size === 'lg' ? 'text-lg' : 'text-base'}
    ${isLoading ? 'opacity-0' : 'opacity-100'}
  `;

  return (
    <TouchableOpacity style={buttonStyles} disabled={disabled || isLoading}>
      <Text style={textStyles}>
        {isLoading ? 'Loading...' : 'Click me'}
      </Text>
      {isLoading && (
        <ActivityIndicator size="small" color="#fff" style={tw`absolute`} />
      )}
    </TouchableOpacity>
  );
};
Method 2: Style Arrays
javascript
const Card = ({ status, priority, isInteractive }) => {
  const baseStyles = tw`p-4 rounded-lg border`;
  
  const statusStyles = {
    success: tw`bg-green-50 border-green-200`,
    warning: tw`bg-yellow-50 border-yellow-200`,
    error: tw`bg-red-50 border-red-200`,
    info: tw`bg-blue-50 border-blue-200`,
  };
  
  const priorityStyles = {
    high: tw`border-l-4 border-l-red-500`,
    medium: tw`border-l-4 border-l-yellow-500`,
    low: tw`border-l-4 border-l-green-500`,
  };
  
  const interactiveStyles = isInteractive ? tw`shadow-sm active:shadow-md` : tw``;

  return (
    <View style={[
      baseStyles,
      statusStyles[status] || statusStyles.info,
      priorityStyles[priority] || priorityStyles.medium,
      interactiveStyles,
    ]}>
      <Text>Card Content</Text>
    </View>
  );
};
Method 3: clsx Alternative for Complex Logic
javascript
import tw from 'twrnc';
import clsx from 'clsx';

const ComplexComponent = ({ 
  isActive, 
  hasError, 
  isDisabled, 
  size,
  theme = 'light'
}) => {
  const containerClasses = clsx(
    'p-4 rounded-lg border',
    {
      'bg-blue-500 border-blue-600': isActive && !hasError,
      'bg-red-500 border-red-600': hasError,
      'bg-gray-300 border-gray-400': isDisabled,
      'bg-white border-gray-200': !isActive && !hasError && !isDisabled,
    },
    theme === 'dark' && 'dark:bg-gray-800 dark:border-gray-700',
    size === 'large' ? 'p-6' : 'p-4'
  );

  return (
    <View style={tw`${containerClasses}`}>
      <Text style={tw`
        ${isDisabled ? 'text-gray-500' : 
          hasError ? 'text-white' : 
          isActive ? 'text-white' : 'text-gray-900'}
        ${theme === 'dark' && !isActive && !hasError ? 'dark:text-white' : ''}
      `}>
        Dynamic Content
      </Text>
    </View>
  );
};
212. Reusable Component Variants with Tailwind
Method 1: Variant Prop Pattern
javascript
const Button = ({ 
  variant = 'primary', 
  size = 'md',
  disabled = false,
  children,
  ...props 
}) => {
  const variants = {
    primary: 'bg-blue-500 hover:bg-blue-600 active:bg-blue-700',
    secondary: 'bg-gray-500 hover:bg-gray-600 active:bg-gray-700',
    danger: 'bg-red-500 hover:bg-red-600 active:bg-red-700',
    success: 'bg-green-500 hover:bg-green-600 active:bg-green-700',
    outline: 'bg-transparent border border-blue-500 text-blue-500',
  };
  
  const sizes = {
    sm: 'px-3 py-2 text-sm',
    md: 'px-4 py-3 text-base',
    lg: 'px-6 py-4 text-lg',
  };
  
  const baseStyles = tw`
    rounded-lg 
    justify-center 
    items-center
    flex-row
    ${disabled ? 'opacity-50' : ''}
  `;

  return (
    <TouchableOpacity
      style={tw`${baseStyles} ${variants[variant]} ${sizes[size]}`}
      disabled={disabled}
      {...props}
    >
      <Text style={tw`
        text-white font-medium
        ${variant === 'outline' ? 'text-blue-500' : 'text-white'}
      `}>
        {children}
      </Text>
    </TouchableOpacity>
  );
};

// Usage
<Button variant="primary" size="lg">Submit</Button>
<Button variant="outline" size="sm">Cancel</Button>
<Button variant="danger" disabled>Delete</Button>
Method 2: Compound Variants
javascript
const Badge = ({ 
  variant = 'default',
  size = 'md',
  rounded = false,
  children 
}) => {
  const baseStyles = tw`inline-flex items-center`;
  
  const variantStyles = {
    default: 'bg-gray-100 text-gray-800',
    primary: 'bg-blue-100 text-blue-800',
    success: 'bg-green-100 text-green-800',
    warning: 'bg-yellow-100 text-yellow-800',
    error: 'bg-red-100 text-red-800',
  };
  
  const sizeStyles = {
    sm: 'px-2 py-1 text-xs',
    md: 'px-3 py-1.5 text-sm',
    lg: 'px-4 py-2 text-base',
  };
  
  const roundedStyles = rounded ? 'rounded-full' : 'rounded-md';

  const className = tw`
    ${baseStyles}
    ${variantStyles[variant]}
    ${sizeStyles[size]} 
    ${roundedStyles}
  `;

  return (
    <View style={className}>
      <Text style={tw`font-medium`}>{children}</Text>
    </View>
  );
};
Method 3: Configuration-Based Variants
javascript
// components/Alert.js
const alertConfig = {
  variants: {
    success: {
      container: 'bg-green-50 border border-green-200',
      icon: 'text-green-500',
      text: 'text-green-800',
      title: 'text-green-700 font-semibold',
    },
    error: {
      container: 'bg-red-50 border border-red-200',
      icon: 'text-red-500', 
      text: 'text-red-800',
      title: 'text-red-700 font-semibold',
    },
    warning: {
      container: 'bg-yellow-50 border border-yellow-200',
      icon: 'text-yellow-500',
      text: 'text-yellow-800',
      title: 'text-yellow-700 font-semibold',
    },
    info: {
      container: 'bg-blue-50 border border-blue-200',
      icon: 'text-blue-500',
      text: 'text-blue-800',
      title: 'text-blue-700 font-semibold',
    },
  },
};

const Alert = ({ variant = 'info', title, message, showIcon = true }) => {
  const styles = alertConfig.variants[variant];
  
  return (
    <View style={tw`${styles.container} rounded-lg p-4`}>
      <View style={tw`flex-row items-start`}>
        {showIcon && (
          <View style={tw`mr-3 mt-0.5`}>
            <Text style={tw`${styles.icon} text-lg`}>ⓘ</Text>
          </View>
        )}
        <View style={tw`flex-1`}>
          {title && (
            <Text style={tw`${styles.title} text-base mb-1`}>
              {title}
            </Text>
          )}
          <Text style={tw`${styles.text} text-sm`}>
            {message}
          </Text>
        </View>
      </View>
    </View>
  );
};
213. Performance Considerations of NativeWind
Performance Benefits:
javascript
// ✅ GOOD - Cached styles
const styles = {
  button: tw`bg-blue-500 text-white p-4 rounded-lg`,
};

// These use the same cached style object
<Button style={styles.button} />
<AnotherButton style={styles.button} />

// Behind the scenes:
// First render: "bg-blue-500 text-white p-4 rounded-lg" → parsed → cached
// Subsequent renders: use cached style object (fast!)
Performance Pitfalls:
javascript
// ❌ BAD - Dynamic strings in render
const BadComponent = ({ isActive }) => (
  <View style={tw`
    p-4 
    ${isActive ? 'bg-blue-500' : 'bg-gray-500'}
    ${someComplexFunction()} // ← Runs every render!
  `} />
);

// ✅ GOOD - Memoized dynamic styles
const GoodComponent = ({ isActive }) => {
  const dynamicStyles = useMemo(() => 
    tw`p-4 ${isActive ? 'bg-blue-500' : 'bg-gray-500'}`,
    [isActive] // Only recompute when isActive changes
  );
  
  return <View style={dynamicStyles} />;
};
Performance Optimization Techniques:
1. Memoize Dynamic Styles
javascript
import { useMemo } from 'react';

const OptimizedComponent = ({ variant, size, disabled }) => {
  const styles = useMemo(() => {
    return {
      container: tw`
        rounded-lg p-4
        ${variant === 'primary' ? 'bg-blue-500' : 'bg-gray-500'}
        ${size === 'large' ? 'p-6' : 'p-4'}
        ${disabled ? 'opacity-50' : 'opacity-100'}
      `,
      text: tw`
        text-white
        ${size === 'large' ? 'text-lg' : 'text-base'}
      `,
    };
  }, [variant, size, disabled]); // Only recompute when deps change

  return (
    <View style={styles.container}>
      <Text style={styles.text}>Content</Text>
    </View>
  );
};
2. Precompute Static Styles
javascript
// styles/components.js
export const componentStyles = {
  button: {
    base: tw`rounded-lg justify-center items-center`,
    variants: {
      primary: tw`bg-blue-500 text-white`,
      secondary: tw`bg-gray-500 text-white`,
    },
    sizes: {
      sm: tw`px-3 py-2 text-sm`,
      md: tw`px-4 py-3 text-base`,
      lg: tw`px-6 py-4 text-lg`,
    },
  },
};

// Usage - no runtime string parsing
const Button = ({ variant, size }) => (
  <TouchableOpacity style={[
    componentStyles.button.base,
    componentStyles.button.variants[variant],
    componentStyles.button.sizes[size],
  ]}>
    <Text>Button</Text>
  </TouchableOpacity>
);
3. Avoid Complex String Interpolation
javascript
// ❌ Complex interpolation (slow)
const SlowComponent = ({ items, user }) => (
  <View style={tw`
    p-4 
    bg-${user.theme}-500 
    text-${items.length > 5 ? 'lg' : 'base'}
  `} />
);

// ✅ Predefined classes (fast)
const FastComponent = ({ items, user }) => (
  <View style={tw`
    p-4 
    ${user.theme === 'blue' ? 'bg-blue-500' : 
      user.theme === 'red' ? 'bg-red-500' : 'bg-gray-500'}
    ${items.length > 5 ? 'text-lg' : 'text-base'}
  `} />
);
4. Use NativeWind's Production Optimizations
javascript
// In production, NativeWind:
// - Pre-compiles frequently used classes
// - Minimizes runtime parsing
// - Optimizes cache hits

// Enable production optimizations in babel.config.js
module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
  plugins: [
    ['nativewind/babel', { mode: 'compileOnly' }], // Production mode
  ],
};
Performance Comparison:
Scenario	StyleSheet	NativeWind (Good)	NativeWind (Bad)
Static styles	⭐⭐⭐⭐⭐	⭐⭐⭐⭐	⭐⭐
Dynamic styles	⭐⭐⭐⭐	⭐⭐⭐	⭐
Memory usage	⭐⭐⭐⭐⭐	⭐⭐⭐	⭐⭐
Development speed	⭐⭐	⭐⭐⭐⭐⭐	⭐⭐⭐⭐⭐
Best Practices Summary:
Memoize dynamic style computations

Precompute static styles outside components

Avoid complex string interpolation in render

Use predefined variant classes

Leverage NativeWind's caching mechanism

Profile performance with React Native Debugger

NativeWind performs excellently when used properly, but requires careful attention to dynamic styling patterns!
-------------------------------------------------------------------------------------------------------------------------

214. What are Styled Components and how do they work?
215. How do you implement themes with Styled Components?
216. How do you handle responsive design with Styled Components?
217. How do you create polymorphic components?
218. How do you handle conditional styling?
219. What are the performance implications?
220. How do you optimize re-renders with Styled Components?
214. Styled Components and How They Work
Styled Components is a CSS-in-JS library that lets you write actual CSS in your JavaScript components.

Basic Usage:
javascript
import styled from 'styled-components/native';

// Create styled components
const Container = styled.View`
  flex: 1;
  padding: 20px;
  background-color: ${props => props.primary ? 'blue' : 'white'};
`;

const Title = styled.Text`
  font-size: 24px;
  color: #333;
  font-weight: bold;
`;

const Button = styled.TouchableOpacity`
  background-color: #007AFF;
  padding: 15px 20px;
  border-radius: 8px;
  align-items: center;
`;

// Usage
const MyComponent = () => (
  <Container primary>
    <Title>Welcome to Styled Components</Title>
    <Button onPress={() => console.log('Pressed')}>
      <Title style={{ color: 'white', fontSize: 16 }}>Click Me</Title>
    </Button>
  </Container>
);
How It Works:
javascript
// Behind the scenes:
// 1. Template literals are parsed
// 2. CSS is converted to React Native style objects
// 3. Dynamic props are injected
// 4. Unique class names are generated (for web)
// 5. Styles are applied to components

// Example transformation:
const StyledView = styled.View`
  padding: 20px;
  background-color: ${props => props.bg || 'white'};
`;

// Becomes something like:
const generatedStyle = (props) => ({
  padding: 20,
  backgroundColor: props.bg || 'white',
});
215. Implementing Themes with Styled Components
Theme Provider Setup:
javascript
// theme.js
export const theme = {
  colors: {
    primary: '#007AFF',
    secondary: '#5856D6',
    success: '#34C759',
    danger: '#FF3B30',
    warning: '#FF9500',
    background: '#FFFFFF',
    text: '#1C1C1E',
    textSecondary: '#8E8E93',
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  typography: {
    title: 24,
    subtitle: 18,
    body: 16,
    caption: 14,
  },
  borderRadius: {
    sm: 4,
    md: 8,
    lg: 12,
  }
};

export const darkTheme = {
  ...theme,
  colors: {
    ...theme.colors,
    background: '#000000',
    text: '#FFFFFF',
    textSecondary: '#98989F',
  }
};
Theme Provider Implementation:
javascript
// App.js
import React, { useState } from 'react';
import { ThemeProvider } from 'styled-components/native';
import { theme, darkTheme } from './theme';

const App = () => {
  const [isDark, setIsDark] = useState(false);
  
  return (
    <ThemeProvider theme={isDark ? darkTheme : theme}>
      <YourApp toggleTheme={() => setIsDark(!isDark)} />
    </ThemeProvider>
  );
};
Using Themes in Components:
javascript
import styled from 'styled-components/native';

const Container = styled.View`
  flex: 1;
  padding: ${props => props.theme.spacing.md}px;
  background-color: ${props => props.theme.colors.background};
`;

const Heading = styled.Text`
  font-size: ${props => props.theme.typography.title}px;
  color: ${props => props.theme.colors.text};
  font-weight: bold;
  margin-bottom: ${props => props.theme.spacing.sm}px;
`;

const Card = styled.View`
  background-color: ${props => props.theme.colors.background};
  padding: ${props => props.theme.spacing.md}px;
  border-radius: ${props => props.theme.borderRadius.md}px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
  shadow-opacity: 0.1;
  shadow-radius: 3px;
  elevation: 3;
`;

// Usage with theme
const ProfileScreen = () => (
  <Container>
    <Heading>Profile</Heading>
    <Card>
      <Text style={{ color: theme.colors.textSecondary }}>
        Welcome back!
      </Text>
    </Card>
  </Container>
);
Theme Hook:
javascript
import { useTheme } from 'styled-components/native';

const ThemedComponent = () => {
  const theme = useTheme();
  
  return (
    <View style={{
      padding: theme.spacing.md,
      backgroundColor: theme.colors.primary,
    }}>
      <Text style={{ color: theme.colors.background }}>
        Using theme hook
      </Text>
    </View>
  );
};
216. Responsive Design with Styled Components
Method 1: Using useWindowDimensions Hook
javascript
import styled from 'styled-components/native';
import { useWindowDimensions } from 'react-native';

const ResponsiveContainer = styled.View`
  flex: 1;
  padding: ${props => {
    const { width } = props.dimensions;
    return width > 768 ? '40px' : '20px';
  }};
  flex-direction: ${props => 
    props.dimensions.width > 768 ? 'row' : 'column'
  };
`;

const ResponsiveComponent = () => {
  const dimensions = useWindowDimensions();
  
  return (
    <ResponsiveContainer dimensions={dimensions}>
      <View style={{ 
        width: dimensions.width > 768 ? '50%' : '100%' 
      }}>
        <Text>Sidebar</Text>
      </View>
      <View style={{ 
        width: dimensions.width > 768 ? '50%' : '100%' 
      }}>
        <Text>Content</Text>
      </View>
    </ResponsiveContainer>
  );
};
Method 2: Responsive Utility Functions
javascript
// utils/responsive.js
import { Dimensions } from 'react-native';

const { width, height } = Dimensions.get('window');

export const breakpoints = {
  phone: 375,
  tablet: 768,
  desktop: 1024,
};

export const isPhone = width < breakpoints.tablet;
export const isTablet = width >= breakpoints.tablet && width < breakpoints.desktop;
export const isDesktop = width >= breakpoints.desktop;

export const responsiveValue = (phone, tablet, desktop) => {
  if (isPhone) return phone;
  if (isTablet) return tablet;
  return desktop;
};
Method 3: Responsive Styled Components
javascript
import styled from 'styled-components/native';
import { responsiveValue } from '../utils/responsive';

const Container = styled.View`
  flex: 1;
  padding: ${responsiveValue('16px', '24px', '32px')};
  flex-direction: ${responsiveValue('column', 'row', 'row')};
`;

const Grid = styled.View`
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-between;
`;

const GridItem = styled.View`
  width: ${responsiveValue('100%', '48%', '32%')};
  margin-bottom: ${responsiveValue('16px', '16px', '24px')};
  padding: ${responsiveValue('12px', '16px', '20px')};
  background-color: white;
  border-radius: 8px;
`;

// Usage
const ResponsiveGrid = () => (
  <Container>
    <Grid>
      {[1, 2, 3, 4, 5, 6].map(item => (
        <GridItem key={item}>
          <Text>Item {item}</Text>
        </GridItem>
      ))}
    </Grid>
  </Container>
);
217. Polymorphic Components
Polymorphic components can change their underlying DOM element/component while maintaining the same styling.

Basic Polymorphic Component:
javascript
import styled from 'styled-components/native';

// Method 1: Using "as" prop
const Box = styled.View`
  padding: 16px;
  background-color: ${props => props.bg || 'white'};
  border-radius: 8px;
`;

// Usage - render as different components
const PolymorphicExample = () => (
  <>
    {/* Renders as View */}
    <Box bg="#f0f0f0">
      <Text>This is a View</Text>
    </Box>
    
    {/* Renders as TouchableOpacity */}
    <Box as={TouchableOpacity} bg="#007AFF" onPress={() => alert('Pressed!')}>
      <Text style={{ color: 'white' }}>This is a Button</Text>
    </Box>
    
    {/* Renders as Text */}
    <Box as={Text} bg="transparent">
      This is actually Text component!
    </Box>
  </>
);
Advanced Polymorphic Component with Type Safety:
javascript
import React from 'react';
import styled from 'styled-components/native';

const StyledBox = styled.View`
  padding: ${props => props.padding || '16px'};
  background-color: ${props => props.backgroundColor || 'white'};
  border-radius: ${props => props.borderRadius || '8px'};
  ${props => props.center && `
    justify-content: center;
    align-items: center;
  `}
`;

// Polymorphic component with TypeScript
const Box = React.forwardRef(({ 
  as: Component = View, 
  children, 
  ...props 
}, ref) => {
  return (
    <StyledBox as={Component} ref={ref} {...props}>
      {children}
    </StyledBox>
  );
});

// Usage examples
const App = () => (
  <>
    {/* Default (View) */}
    <Box padding="20px" backgroundColor="#f5f5f5">
      <Text>Regular Box</Text>
    </Box>
    
    {/* As TouchableOpacity */}
    <Box 
      as={TouchableOpacity} 
      backgroundColor="#007AFF"
      padding="12px"
      center
      onPress={() => console.log('Pressed')}
    >
      <Text style={{ color: 'white', fontWeight: 'bold' }}>
        Button Box
      </Text>
    </Box>
    
    {/* As ScrollView */}
    <Box as={ScrollView} backgroundColor="transparent">
      <Text>Item 1</Text>
      <Text>Item 2</Text>
      <Text>Item 3</Text>
    </Box>
    
    {/* As Text */}
    <Box as={Text} backgroundColor="transparent" padding="0">
      This is text with box styling!
    </Box>
  </>
);
218. Conditional Styling
Method 1: Props-Based Conditional Styling
javascript
import styled from 'styled-components/native';

const Button = styled.TouchableOpacity`
  padding: 12px 24px;
  border-radius: 8px;
  align-items: center;
  justify-content: center;
  
  /* Variant based on props */
  background-color: ${props => {
    switch (props.variant) {
      case 'primary': return '#007AFF';
      case 'secondary': return '#6C757D';
      case 'success': return '#28A745';
      case 'danger': return '#DC3545';
      default: return '#007AFF';
    }
  }};
  
  /* Size based on props */
  padding: ${props => {
    switch (props.size) {
      case 'sm': return '8px 16px';
      case 'lg': return '16px 32px';
      default: return '12px 24px';
    }
  }};
  
  /* Disabled state */
  opacity: ${props => props.disabled ? 0.6 : 1};
  
  /* Outline variant */
  ${props => props.outline && `
    background-color: transparent;
    border: 2px solid ${props.variant ? getColor(props.variant) : '#007AFF'};
  `}
`;

const getColor = (variant) => {
  const colors = {
    primary: '#007AFF',
    secondary: '#6C757D', 
    success: '#28A745',
    danger: '#DC3545',
  };
  return colors[variant] || colors.primary;
};

// Usage
const ButtonExamples = () => (
  <>
    <Button variant="primary" onPress={() => {}}>
      <Text style={{ color: 'white' }}>Primary</Text>
    </Button>
    
    <Button variant="success" size="lg" onPress={() => {}}>
      <Text style={{ color: 'white' }}>Success Large</Text>
    </Button>
    
    <Button variant="danger" outline onPress={() => {}}>
      <Text style={{ color: getColor('danger') }}>Danger Outline</Text>
    </Button>
    
    <Button disabled onPress={() => {}}>
      <Text style={{ color: 'white' }}>Disabled</Text>
    </Button>
  </>
);
Method 2: CSS Helper Function
javascript
import styled, { css } from 'styled-components/native';

const Card = styled.View`
  padding: 16px;
  border-radius: 8px;
  background-color: white;
  
  /* Base shadow */
  shadow-color: #000;
  shadow-offset: 0px 2px;
  shadow-opacity: 0.1;
  shadow-radius: 3px;
  elevation: 2;
  
  /* Conditional styles using css helper */
  ${props => props.elevated && css`
    shadow-opacity: 0.2;
    shadow-radius: 6px;
    elevation: 6;
  `}
  
  ${props => props.interactive && css`
    shadow-opacity: 0.15;
    elevation: 4;
  `}
  
  ${props => props.selected && css`
    border: 2px solid #007AFF;
    background-color: #F0F8FF;
  `}
  
  ${props => props.disabled && css`
    opacity: 0.5;
    background-color: #F8F9FA;
  `}
`;

// Usage
const CardExamples = () => (
  <>
    <Card>
      <Text>Regular Card</Text>
    </Card>
    
    <Card elevated>
      <Text>Elevated Card</Text>
    </Card>
    
    <Card interactive selected>
      <Text>Selected Interactive Card</Text>
    </Card>
    
    <Card disabled>
      <Text>Disabled Card</Text>
    </Card>
  </>
);
219. Performance Implications
Performance Concerns:
javascript
// ❌ PROBLEMATIC - Dynamic styles in render
const DynamicComponent = ({ items, user, theme }) => {
  // New styled component created on every render!
  const DynamicBox = styled.View`
    padding: ${items.length * 2}px;
    background-color: ${user.preferences.color};
    border-radius: ${theme.borderRadius}px;
  `;
  
  return <DynamicBox />;
};

// ✅ BETTER - Static styled components
const StaticBox = styled.View`
  padding: ${props => props.padding}px;
  background-color: ${props => props.backgroundColor};
  border-radius: ${props => props.borderRadius}px;
`;

const OptimizedComponent = ({ items, user, theme }) => (
  <StaticBox 
    padding={items.length * 2}
    backgroundColor={user.preferences.color}
    borderRadius={theme.borderRadius}
  />
);
Performance Issues:
Runtime style computation - CSS parsing happens in JavaScript

Dynamic component creation - New components created during render

Prop changes - Frequent style recalculations

Memory usage - Cache growth with dynamic styles

220. Optimizing Re-renders with Styled Components
Method 1: useMemo for Dynamic Styles
javascript
import React, { useMemo } from 'react';
import styled from 'styled-components/native';

const StaticBox = styled.View`
  padding: 16px;
  background-color: ${props => props.bg};
  border-radius: 8px;
`;

const OptimizedComponent = ({ user, items, isActive }) => {
  // Memoize dynamic props to prevent unnecessary re-renders
  const boxProps = useMemo(() => ({
    bg: isActive ? user.preferences.activeColor : user.preferences.inactiveColor,
  }), [isActive, user.preferences.activeColor, user.preferences.inactiveColor]);
  
  return (
    <StaticBox {...boxProps}>
      <Text>Items: {items.length}</Text>
    </StaticBox>
  );
};
Method 2: React.memo with Styled Components
javascript
import React, { memo } from 'react';
import styled from 'styled-components/native';

const CardContainer = styled.View`
  padding: 16px;
  background-color: ${props => props.theme.colors.background};
  border-radius: 8px;
  margin-bottom: 12px;
`;

const CardTitle = styled.Text`
  font-size: 18px;
  font-weight: bold;
  color: ${props => props.theme.colors.text};
  margin-bottom: 8px;
`;

// Use React.memo to prevent unnecessary re-renders
const Card = memo(({ title, content, isFeatured }) => {
  return (
    <CardContainer style={{
      borderLeftWidth: isFeatured ? 4 : 0,
      borderLeftColor: isFeatured ? '#007AFF' : 'transparent',
    }}>
      <CardTitle>{title}</CardTitle>
      <Text style={{ color: '#666' }}>{content}</Text>
    </CardContainer>
  );
});

// Custom comparison function
const areEqual = (prevProps, nextProps) => {
  return prevProps.title === nextProps.title && 
         prevProps.content === nextProps.content &&
         prevProps.isFeatured === nextProps.isFeatured;
};

const OptimizedCard = memo(Card, areEqual);
Method 3: Avoiding Inline Styled Components
javascript
// ❌ BAD - Inline styled component in render
const BadComponent = ({ type }) => {
  const DynamicBox = styled.View`
    background-color: ${type === 'error' ? 'red' : 'blue'};
    padding: 20px;
  `;
  
  return <DynamicBox />;
};

// ✅ GOOD - Predefined with props
const Box = styled.View`
  background-color: ${props => 
    props.type === 'error' ? 'red' : 'blue'};
  padding: 20px;
`;

const GoodComponent = ({ type }) => {
  return <Box type={type} />;
};
Method 4: Style Extraction Pattern
javascript
import styled from 'styled-components/native';

// Extract dynamic calculations outside styled component
const getDynamicStyles = (props) => {
  const { size, variant, disabled } = props;
  
  return `
    padding: ${size === 'large' ? '24px' : '16px'};
    background-color: ${disabled ? '#CCCCCC' : 
      variant === 'primary' ? '#007AFF' : '#6C757D'};
    opacity: ${disabled ? 0.6 : 1};
  `;
};

const OptimizedButton = styled.TouchableOpacity`
  border-radius: 8px;
  align-items: center;
  justify-content: center;
  ${props => getDynamicStyles(props)}
`;

// Usage
const App = () => (
  <OptimizedButton size="large" variant="primary" disabled={false}>
    <Text style={{ color: 'white' }}>Optimized Button</Text>
  </OptimizedButton>
);
Method 5: Using attrs for Static Props
javascript
import styled from 'styled-components/native';

// Use attrs for props that don't change frequently
const OptimizedInput = styled.TextInput.attrs(props => ({
  placeholderTextColor: props.theme.colors.textSecondary,
  selectionColor: props.theme.colors.primary,
}))`
  padding: 16px;
  border-radius: 8px;
  background-color: ${props => props.theme.colors.background};
  border: 1px solid ${props => props.theme.colors.textSecondary};
  color: ${props => props.theme.colors.text};
  font-size: 16px;
`;

// Static values are set once in attrs
const StaticButton = styled.TouchableOpacity.attrs({
  activeOpacity: 0.8,
})`
  padding: 16px;
  background-color: #007AFF;
  border-radius: 8px;
  align-items: center;
`;
Performance Best Practices Summary:
Avoid creating styled components in render

Use React.memo for expensive components

Memoize dynamic props with useMemo

Extract complex logic outside styled components

Use attrs for static properties

Keep styled components pure and predictable

These optimizations ensure Styled Components remain performant even in complex applications!

------------------------------------------------------------------------------------------