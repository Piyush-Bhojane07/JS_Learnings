JavaScript Fundamentals 

What is the difference between == and ===? 


== (Loose Equality)
Compares values after type conversion

Converts both values to a common type before comparing

Also called "type coercion"

=== (Strict Equality)
Compares both value AND type

No type conversion - both must be exactly the same

Examples:
javascript
// == (Loose Equality) - with type coercion
console.log(5 == "5");        // true (string "5" converted to number 5)
console.log(1 == true);       // true (true converted to number 1)
console.log(0 == false);      // true (false converted to number 0)
console.log(null == undefined); // true
console.log("" == false);     // true

// === (Strict Equality) - no type coercion
console.log(5 === "5");       // false (number vs string)
console.log(1 === true);      // false (number vs boolean)
console.log(0 === false);     // false (number vs boolean)
console.log(null === undefined); // false
console.log("" === false);    // false
Best Practice:
Always use === (strict equality) unless you have a specific reason to use ==. It's more predictable and prevents unexpected type coercion bugs.

javascript
// Good practice
if (age === "25") {
  // This will only execute if age is exactly string "25"
}

// Potentially problematic
if (age == "25") {
  // This executes for number 25 OR string "25"
}-----------------------------------------------------


Explain JavaScript's event loop and call stack

JavaScript's Event Loop & Call Stack
1. Call Stack
What it is: A data structure that tracks function execution (LIFO - Last In, First Out)

How it works: When a function is called, it's pushed to the stack. When it returns, it's popped off.

javascript
function first() {
    console.log('First');
    second();
}

function second() {
    console.log('Second');
    third();
}

function third() {
    console.log('Third');
}

first();

// Call Stack flow:
// 1. first() enters stack
// 2. console.log('First') enters stack ‚Üí executes ‚Üí leaves stack
// 3. second() enters stack
// 4. console.log('Second') enters stack ‚Üí executes ‚Üí leaves stack
// 5. third() enters stack
// 6. console.log('Third') enters stack ‚Üí executes ‚Üí leaves stack
// 7. All functions leave stack in reverse order
2. Event Loop
Purpose: Monitors Call Stack and Callback Queue

How it works: When Call Stack is empty, it moves callbacks from Queue to Stack

The Complete Picture:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise callback');
});

console.log('End');

// Output order:
// "Start"
// "End" 
// "Promise callback"  (Microtask queue - higher priority)
// "Timeout callback"  (Macrotask queue - lower priority)
Key Components:
1. Call Stack
Synchronous function execution

One thing at a time

2. Web APIs (Browser Environment)
setTimeout, setInterval, DOM events, HTTP requests

Handle asynchronous operations outside JS engine

3. Callback Queues
Microtask Queue: Promises, MutationObserver (higher priority)

Macrotask Queue: setTimeout, setInterval, I/O operations (lower priority)

Visual Flow:
text
Call Stack ‚Üí Web APIs ‚Üí Callback Queues ‚Üí Event Loop ‚Üí Back to Call Stack
Detailed Example:
javascript
console.log('Script start'); // 1

setTimeout(function() {
    console.log('setTimeout'); // 4
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 3.1
});

console.log('Script end'); // 2

// Execution order:
// 1. "Script start"
// 2. "Script end"
// 3. "Promise 1", "Promise 2" (Microtasks)
// 4. "setTimeout" (Macrotask)
Key Takeaways:
JavaScript is single-threaded but can handle async operations

Call Stack handles synchronous code

Event Loop enables non-blocking behavior

Microtasks have higher priority than Macrotasks

Never block the call stack - it freezes the UI
This architecture allows JavaScript to handle concurrent operations while remaining single-threaded!

------------------------------------------------

What is the difference between let, const, and var?

var, let, and const - Complete Guide
üéØ Quick Summary
var: Function-scoped, hoisted, can be redeclared and reassigned

let: Block-scoped, hoisted but in TDZ, can be reassigned but not redeclared

const: Block-scoped, hoisted but in TDZ, cannot be reassigned or redeclared

üìù Detailed Breakdown
1. var (Legacy - Avoid in Modern Code)
javascript
// ‚úÖ Function-scoped
function varExample() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10 - accessible outside the block
}

// ‚úÖ Hoisted with undefined
console.log(a); // undefined (not ReferenceError)
var a = 5;

// ‚úÖ Can be redeclared
var b = 1;
var b = 2; // No error

// ‚úÖ Can be reassigned
var c = 10;
c = 20; // Allowed
2. let (Modern - Use when reassignment needed)
javascript
// ‚úÖ Block-scoped
function letExample() {
    if (true) {
        let y = 20;
        console.log(y); // 20
    }
    // console.log(y); // ReferenceError: y is not defined
}

// ‚ùå Hoisted but in Temporal Dead Zone (TDZ)
// console.log(d); // ReferenceError: Cannot access 'd' before initialization
let d = 5;

// ‚ùå Cannot be redeclared in same scope
let e = 1;
// let e = 2; // SyntaxError: Identifier 'e' has already been declared

// ‚úÖ Can be reassigned
let f = 10;
f = 20; // Allowed

// ‚úÖ Can be redeclared in different blocks
if (true) {
    let g = 1;
}
if (true) {
    let g = 2; // Allowed - different block scope
}
3. const (Modern - Use by default)
javascript
// ‚úÖ Block-scoped
function constExample() {
    if (true) {
        const z = 30;
        console.log(z); // 30
    }
    // console.log(z); // ReferenceError: z is not defined
}

// ‚ùå Must be initialized during declaration
// const h; // SyntaxError: Missing initializer in const declaration
const h = 10;

// ‚ùå Cannot be reassigned
const i = 10;
// i = 20; // TypeError: Assignment to constant variable

// ‚ùå Cannot be redeclared
const j = 1;
// const j = 2; // SyntaxError: Identifier 'j' has already been declared

// ‚úÖ But object properties can be modified!
const person = {
    name: "John",
    age: 30
};
person.age = 31; // ‚úÖ Allowed
person.city = "NYC"; // ‚úÖ Allowed

// ‚úÖ Same for arrays
const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ Allowed
numbers[0] = 10; // ‚úÖ Allowed
üîç Deep Dive Examples
Temporal Dead Zone (TDZ)
javascript
// var - hoisted and initialized with undefined
console.log(varVariable); // undefined
var varVariable = "hello";

// let/const - hoisted but NOT initialized (TDZ)
// console.log(letVariable); // ReferenceError: Cannot access 'letVariable' before initialization
let letVariable = "world";

// console.log(constVariable); // ReferenceError: Cannot access 'constVariable' before initialization
const constVariable = "!";
Loop Behavior
javascript
// var in loops - problematic
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100); // 3, 3, 3
}

// let in loops - works as expected
for (let j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100); // 0, 1, 2
}

// const in loops - each iteration gets new binding
for (const k of [1, 2, 3]) {
    console.log(k); // 1, 2, 3
}
Object/Array Mutation with const
javascript
// ‚úÖ Objects can be modified
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
};

config.timeout = 10000; // ‚úÖ Allowed
config.retries = 3; // ‚úÖ Allowed

// ‚ùå But reassignment is not allowed
// config = { new: "object" }; // TypeError

// ‚úÖ Arrays can be modified
const fruits = ["apple", "banana"];
fruits.push("orange"); // ‚úÖ Allowed
fruits[0] = "grape"; // ‚úÖ Allowed

// To prevent mutation entirely:
Object.freeze(config);
// config.newProp = "value"; // Fails silently in non-strict mode
üìä Comparison Table
Feature	var	let	const
Scope	Function	Block	Block
Hoisting	Yes (initialized)	Yes (TDZ)	Yes (TDZ)
Redeclaration	‚úÖ Allowed	‚ùå Not allowed	‚ùå Not allowed
Reassignment	‚úÖ Allowed	‚úÖ Allowed	‚ùå Not allowed
Temporal Dead Zone	‚ùå No	‚úÖ Yes	‚úÖ Yes
Global Property	‚úÖ Creates	‚ùå Doesn't create	‚ùå Doesn't create
üèÜ Best Practices
Use const by default
javascript
// ‚úÖ Good
const API_URL = "https://api.example.com";
const MAX_RETRIES = 3;
const userPreferences = { theme: "dark" };
const availableLanguages = ["en", "es", "fr"];

// Only use let when you need reassignment
let isLoading = false;
let currentPage = 1;
let userInput = "";

// Avoid var in modern code
// ‚ùå var oldVariable = "deprecated";
Practical Usage Patterns
javascript
// Configuration objects
const APP_CONFIG = {
    apiBaseUrl: "https://api.example.com",
    version: "1.0.0",
    features: {
        darkMode: true,
        notifications: false
    }
};

// Arrays that will be modified
const TODO_ITEMS = [
    { id: 1, text: "Learn JavaScript", completed: true },
    { id: 2, text: "Master React Native", completed: false }
];

// Variables that change
let currentUser = null;
let networkStatus = "online";
let attemptCount = 0;

// In React Native components
const UserProfile = () => {
    const [user, setUser] = useState(null); // const for state setters
    const navigation = useNavigation(); // const for hooks
    
    let temporaryValue = ""; // let for values that change within function
};
‚ö†Ô∏è Common Pitfalls & Solutions
1. Accidental Reassignment
javascript
const items = [1, 2, 3];
// items = [4, 5, 6]; // ‚ùå Error

// ‚úÖ Solution: Modify instead of reassign
items.length = 0; // Clear array
items.push(4, 5, 6); // Add new items
2. Block Scope Confusion
javascript
if (true) {
    let blockScoped = "I'm here";
    const alsoBlockScoped = "Me too";
}
// console.log(blockScoped); // ‚ùå ReferenceError
3. Loop Variables
javascript
// ‚úÖ Correct - let creates new binding each iteration
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100); // 0, 1, 2, 3, 4
}

// ‚ùå Problematic - var shares same binding
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 100); // 5, 5, 5, 5, 5
}
üéØ Interview Ready Summary
When asked in interviews:

"I use const by default for all variables that won't be reassigned, let for variables that need reassignment, and avoid var due to its function scoping and hoisting behavior which can lead to unexpected bugs. const doesn't make values immutable, it only prevents reassignment of the variable itself."

This answer shows:

Understanding of modern JS practices

Awareness of scope and hoisting implications

Practical experience with real-world usage
----------------------------------------------

How does JavaScript handle asynchronous operations? explain
How JavaScript Handles Asynchronous Operations
üéØ The Core Problem
JavaScript is single-threaded, meaning it can only do one thing at a time. But we need to handle multiple operations like:

API calls (take 2-3 seconds)

File operations

Timers

User interactions

Without blocking the main thread!

üîÑ The Solution: Event Loop + Callback Queue
Synchronous (Blocking) Code:
javascript
console.log('Start');

function syncOperation() {
    console.log('Processing...');
    // Simulate heavy computation
    for (let i = 0; i < 1000000000; i++) {}
    console.log('Done');
}

syncOperation(); // Blocks everything for seconds

console.log('End');

// Output:
// "Start"
// "Processing..."
// "Done" (after delay)
// "End"
Asynchronous (Non-blocking) Code:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout completed');
}, 2000);

console.log('End');

// Output:
// "Start"
// "End" (immediately)
// "Timeout completed" (after 2 seconds)
üèóÔ∏è JavaScript Runtime Architecture
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CALL STACK    ‚îÇ    ‚îÇ  WEB APIs        ‚îÇ    ‚îÇ  CALLBACK QUEUE ‚îÇ
‚îÇ (Main Thread)   ‚îÇ    ‚îÇ (Browser/Node)   ‚îÇ    ‚îÇ (Task Queue)    ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ function calls  ‚îÇ    ‚îÇ setTimeout       ‚îÇ    ‚îÇ Callbacks       ‚îÇ
‚îÇ execution       ‚îÇ    ‚îÇ fetch            ‚îÇ    ‚îÇ waiting         ‚îÇ
‚îÇ context         ‚îÇ    ‚îÇ DOM events       ‚îÇ    ‚îÇ to execute      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ  EVENT LOOP   ‚îÇ
                         ‚îÇ               ‚îÇ
                         ‚îÇ Monitors      ‚îÇ
                         ‚îÇ Stack & Queue ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üìö Async Mechanisms Evolution
1. Callbacks (The OG Way)
javascript
// Simple callback
function fetchData(callback) {
    setTimeout(() => {
        callback('Data received');
    }, 1000);
}

fetchData((result) => {
    console.log(result); // "Data received" after 1 second
});

// ‚ùå Callback Hell (Pyramid of Doom)
getUser(userId, (user) => {
    getPosts(user.id, (posts) => {
        getComments(posts[0].id, (comments) => {
            getReplies(comments[0].id, (replies) => {
                console.log(replies); // üòµ‚Äçüí´ Nested mess!
            });
        });
    });
});
2. Promises (ES6)
javascript
// Promise-based approach
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const success = Math.random() > 0.3;
            success ? resolve('Data received') : reject('Error occurred');
        }, 1000);
    });
}

// Usage
fetchData()
    .then(result => {
        console.log(result);
        return processData(result);
    })
    .then(processed => {
        console.log(processed);
    })
    .catch(error => {
        console.error('Error:', error);
    })
    .finally(() => {
        console.log('Operation completed');
    });

// ‚úÖ Multiple async operations
Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
])
.then(([user, posts, comments]) => {
    console.log('All data loaded');
})
.catch(error => {
    console.error('One request failed');
});
3. Async/Await (ES2017) - Modern Way
javascript
// Async/await - syntactic sugar over Promises
async function loadUserData() {
    try {
        console.log('Loading user data...');
        
        const user = await fetchUser();
        const posts = await fetchPosts(user.id);
        const comments = await fetchComments(posts[0].id);
        
        console.log('All data loaded:', { user, posts, comments });
        return { user, posts, comments };
    } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
    } finally {
        console.log('Data loading attempt completed');
    }
}

// Usage
loadUserData()
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Failure:', error));
üîß Detailed Execution Flow
Example with All Components:
javascript
console.log('Script start'); // 1

// Macro-task (setTimeout)
setTimeout(() => {
    console.log('setTimeout'); // 4
}, 0);

// Micro-task (Promise)
Promise.resolve()
    .then(() => {
        console.log('Promise 1'); // 3
    })
    .then(() => {
        console.log('Promise 2'); // 3.1
    });

// Synchronous code
console.log('Script end'); // 2

// Output Order:
// "Script start"
// "Script end" 
// "Promise 1"
// "Promise 2"
// "setTimeout"
üé™ Task Queues Priority
Microtasks vs Macrotasks:
javascript
console.log('Start');

// Macrotask (lower priority)
setTimeout(() => console.log('Timeout'), 0);

// Microtask (higher priority)
Promise.resolve().then(() => console.log('Promise'));

// Synchronous
console.log('End');

// Execution:
// 1. Call Stack: "Start", "End"
// 2. Microtask Queue: "Promise"
// 3. Macrotask Queue: "Timeout"

// Output:
// "Start"
// "End"
// "Promise"
// "Timeout"
Complex Example:
javascript
console.log('1 - Sync');

setTimeout(() => console.log('2 - Timeout'), 0);

Promise.resolve()
    .then(() => {
        console.log('3 - Promise');
        setTimeout(() => console.log('4 - Timeout in Promise'), 0);
    });

Promise.resolve()
    .then(() => console.log('5 - Promise 2'));

console.log('6 - Sync end');

// Output:
// "1 - Sync"
// "6 - Sync end"
// "3 - Promise"
// "5 - Promise 2"
// "2 - Timeout"
// "4 - Timeout in Promise"
üåê Real-World Async Patterns
1. API Calls with Error Handling
javascript
async function fetchUserWithRetry(userId, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(`/api/users/${userId}`);
            if (!response.ok) throw new Error('Network error');
            return await response.json();
        } catch (error) {
            if (i === retries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
    }
}

// Usage
fetchUserWithRetry(123)
    .then(user => console.log('User:', user))
    .catch(error => console.error('Failed after retries:', error));
2. Parallel Execution
javascript
// Sequential (slow)
async function sequentialFetch() {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);    // Waits for user first
    const comments = await fetchComments(posts[0].id); // Waits for posts
    return { user, posts, comments };
}

// Parallel (fast)
async function parallelFetch() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    return { user, posts, comments };
}

// Mixed approach
async function smartFetch(userId) {
    const user = await fetchUser(userId);
    
    const [posts, profile] = await Promise.all([
        fetchPosts(userId),
        fetchProfile(userId)
    ]);
    
    return { user, posts, profile };
}
3. Race Conditions & Cancellation
javascript
// Using AbortController for cancellation
function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    return fetch(url, { signal: controller.signal })
        .then(response => {
            clearTimeout(timeoutId);
            return response.json();
        })
        .catch(error => {
            clearTimeout(timeoutId);
            throw error;
        });
}

// Race: First to complete wins
Promise.race([
    fetchWithTimeout('/api/data', 2000),
    new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 3000)
    )
])
.then(data => console.log('Data:', data))
.catch(error => console.error('Error:', error.message));
‚ö° Performance Implications
Blocking the Event Loop:
javascript
// ‚ùå DON'T: Blocking operation
function calculateHashSync(data) {
    // Heavy computation blocks everything
    let hash = 0;
    for (let i = 0; i < 1000000000; i++) {
        hash = (hash << 5) - hash + i;
    }
    return hash;
}

// ‚úÖ DO: Use Web Workers or break into chunks
async function calculateHashAsync(data) {
    // Use setTimeout to yield control
    return new Promise(resolve => {
        setTimeout(() => {
            const hash = performCalculation(data);
            resolve(hash);
        }, 0);
    });
}
üéØ Key Takeaways
JavaScript is single-threaded but handles async via Event Loop

Call Stack executes synchronous code

Web APIs handle async operations (timers, network requests)

Callback Queue holds completed async operations

Event Loop moves callbacks from queue to stack when stack is empty

Microtasks (Promises) have higher priority than Macrotasks (setTimeout)

Async/Await is the modern, readable way to handle async code

üí° Interview Ready Summary
"JavaScript handles asynchronous operations through its event-driven architecture. While the call stack handles synchronous execution, async operations like timers, network requests, and file I/O are delegated to browser/Node.js APIs. When these operations complete, their callbacks are placed in task queues. The event loop continuously monitors the call stack and when empty, pushes callbacks from the queues to the stack for execution. This non-blocking I/O model allows JavaScript to handle concurrent operations efficiently despite being single-threaded."

This architecture is why JavaScript can handle thousands of concurrent connections with great performance! üöÄ


