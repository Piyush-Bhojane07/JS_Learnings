JavaScript Fundamentals => 


What is the difference between == and ===? 


== (Loose Equality)
Compares values after type conversion

Converts both values to a common type before comparing

Also called "type coercion"

=== (Strict Equality)
Compares both value AND type

No type conversion - both must be exactly the same

Examples:
javascript
// == (Loose Equality) - with type coercion
console.log(5 == "5");        // true (string "5" converted to number 5)
console.log(1 == true);       // true (true converted to number 1)
console.log(0 == false);      // true (false converted to number 0)
console.log(null == undefined); // true
console.log("" == false);     // true

// === (Strict Equality) - no type coercion
console.log(5 === "5");       // false (number vs string)
console.log(1 === true);      // false (number vs boolean)
console.log(0 === false);     // false (number vs boolean)
console.log(null === undefined); // false
console.log("" === false);    // false
Best Practice:
Always use === (strict equality) unless you have a specific reason to use ==. It's more predictable and prevents unexpected type coercion bugs.

javascript
// Good practice
if (age === "25") {
  // This will only execute if age is exactly string "25"
}

// Potentially problematic
if (age == "25") {
  // This executes for number 25 OR string "25"
}-----------------------------------------------------


Explain JavaScript's event loop and call stack

JavaScript's Event Loop & Call Stack
1. Call Stack
What it is: A data structure that tracks function execution (LIFO - Last In, First Out)

How it works: When a function is called, it's pushed to the stack. When it returns, it's popped off.

javascript
function first() {
    console.log('First');
    second();
}

function second() {
    console.log('Second');
    third();
}

function third() {
    console.log('Third');
}

first();

// Call Stack flow:
// 1. first() enters stack
// 2. console.log('First') enters stack ‚Üí executes ‚Üí leaves stack
// 3. second() enters stack
// 4. console.log('Second') enters stack ‚Üí executes ‚Üí leaves stack
// 5. third() enters stack
// 6. console.log('Third') enters stack ‚Üí executes ‚Üí leaves stack
// 7. All functions leave stack in reverse order
2. Event Loop
Purpose: Monitors Call Stack and Callback Queue

How it works: When Call Stack is empty, it moves callbacks from Queue to Stack

The Complete Picture:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise callback');
});

console.log('End');

// Output order:
// "Start"
// "End" 
// "Promise callback"  (Microtask queue - higher priority)
// "Timeout callback"  (Macrotask queue - lower priority)
Key Components:
1. Call Stack
Synchronous function execution

One thing at a time

2. Web APIs (Browser Environment)
setTimeout, setInterval, DOM events, HTTP requests

Handle asynchronous operations outside JS engine

3. Callback Queues
Microtask Queue: Promises, MutationObserver (higher priority)

Macrotask Queue: setTimeout, setInterval, I/O operations (lower priority)

Visual Flow:
text
Call Stack ‚Üí Web APIs ‚Üí Callback Queues ‚Üí Event Loop ‚Üí Back to Call Stack
Detailed Example:
javascript
console.log('Script start'); // 1

setTimeout(function() {
    console.log('setTimeout'); // 4
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 3.1
});

console.log('Script end'); // 2

// Execution order:
// 1. "Script start"
// 2. "Script end"
// 3. "Promise 1", "Promise 2" (Microtasks)
// 4. "setTimeout" (Macrotask)
Key Takeaways:
JavaScript is single-threaded but can handle async operations

Call Stack handles synchronous code

Event Loop enables non-blocking behavior

Microtasks have higher priority than Macrotasks

Never block the call stack - it freezes the UI
This architecture allows JavaScript to handle concurrent operations while remaining single-threaded!

------------------------------------------------

What is the difference between let, const, and var?

var, let, and const - Complete Guide
üéØ Quick Summary
var: Function-scoped, hoisted, can be redeclared and reassigned

let: Block-scoped, hoisted but in TDZ, can be reassigned but not redeclared

const: Block-scoped, hoisted but in TDZ, cannot be reassigned or redeclared

üìù Detailed Breakdown
1. var (Legacy - Avoid in Modern Code)
javascript
// ‚úÖ Function-scoped
function varExample() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10 - accessible outside the block
}

// ‚úÖ Hoisted with undefined
console.log(a); // undefined (not ReferenceError)
var a = 5;

// ‚úÖ Can be redeclared
var b = 1;
var b = 2; // No error

// ‚úÖ Can be reassigned
var c = 10;
c = 20; // Allowed
2. let (Modern - Use when reassignment needed)
javascript
// ‚úÖ Block-scoped
function letExample() {
    if (true) {
        let y = 20;
        console.log(y); // 20
    }
    // console.log(y); // ReferenceError: y is not defined
}

// ‚ùå Hoisted but in Temporal Dead Zone (TDZ)
// console.log(d); // ReferenceError: Cannot access 'd' before initialization
let d = 5;

// ‚ùå Cannot be redeclared in same scope
let e = 1;
// let e = 2; // SyntaxError: Identifier 'e' has already been declared

// ‚úÖ Can be reassigned
let f = 10;
f = 20; // Allowed

// ‚úÖ Can be redeclared in different blocks
if (true) {
    let g = 1;
}
if (true) {
    let g = 2; // Allowed - different block scope
}
3. const (Modern - Use by default)
javascript
// ‚úÖ Block-scoped
function constExample() {
    if (true) {
        const z = 30;
        console.log(z); // 30
    }
    // console.log(z); // ReferenceError: z is not defined
}

// ‚ùå Must be initialized during declaration
// const h; // SyntaxError: Missing initializer in const declaration
const h = 10;

// ‚ùå Cannot be reassigned
const i = 10;
// i = 20; // TypeError: Assignment to constant variable

// ‚ùå Cannot be redeclared
const j = 1;
// const j = 2; // SyntaxError: Identifier 'j' has already been declared

// ‚úÖ But object properties can be modified!
const person = {
    name: "John",
    age: 30
};
person.age = 31; // ‚úÖ Allowed
person.city = "NYC"; // ‚úÖ Allowed

// ‚úÖ Same for arrays
const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ Allowed
numbers[0] = 10; // ‚úÖ Allowed
üîç Deep Dive Examples
Temporal Dead Zone (TDZ)
javascript
// var - hoisted and initialized with undefined
console.log(varVariable); // undefined
var varVariable = "hello";

// let/const - hoisted but NOT initialized (TDZ)
// console.log(letVariable); // ReferenceError: Cannot access 'letVariable' before initialization
let letVariable = "world";

// console.log(constVariable); // ReferenceError: Cannot access 'constVariable' before initialization
const constVariable = "!";
Loop Behavior
javascript
// var in loops - problematic
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100); // 3, 3, 3
}

// let in loops - works as expected
for (let j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100); // 0, 1, 2
}

// const in loops - each iteration gets new binding
for (const k of [1, 2, 3]) {
    console.log(k); // 1, 2, 3
}
Object/Array Mutation with const
javascript
// ‚úÖ Objects can be modified
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
};

config.timeout = 10000; // ‚úÖ Allowed
config.retries = 3; // ‚úÖ Allowed

// ‚ùå But reassignment is not allowed
// config = { new: "object" }; // TypeError

// ‚úÖ Arrays can be modified
const fruits = ["apple", "banana"];
fruits.push("orange"); // ‚úÖ Allowed
fruits[0] = "grape"; // ‚úÖ Allowed

// To prevent mutation entirely:
Object.freeze(config);
// config.newProp = "value"; // Fails silently in non-strict mode
üìä Comparison Table
Feature	var	let	const
Scope	Function	Block	Block
Hoisting	Yes (initialized)	Yes (TDZ)	Yes (TDZ)
Redeclaration	‚úÖ Allowed	‚ùå Not allowed	‚ùå Not allowed
Reassignment	‚úÖ Allowed	‚úÖ Allowed	‚ùå Not allowed
Temporal Dead Zone	‚ùå No	‚úÖ Yes	‚úÖ Yes
Global Property	‚úÖ Creates	‚ùå Doesn't create	‚ùå Doesn't create
üèÜ Best Practices
Use const by default
javascript
// ‚úÖ Good
const API_URL = "https://api.example.com";
const MAX_RETRIES = 3;
const userPreferences = { theme: "dark" };
const availableLanguages = ["en", "es", "fr"];

// Only use let when you need reassignment
let isLoading = false;
let currentPage = 1;
let userInput = "";

// Avoid var in modern code
// ‚ùå var oldVariable = "deprecated";
Practical Usage Patterns
javascript
// Configuration objects
const APP_CONFIG = {
    apiBaseUrl: "https://api.example.com",
    version: "1.0.0",
    features: {
        darkMode: true,
        notifications: false
    }
};

// Arrays that will be modified
const TODO_ITEMS = [
    { id: 1, text: "Learn JavaScript", completed: true },
    { id: 2, text: "Master React Native", completed: false }
];

// Variables that change
let currentUser = null;
let networkStatus = "online";
let attemptCount = 0;

// In React Native components
const UserProfile = () => {
    const [user, setUser] = useState(null); // const for state setters
    const navigation = useNavigation(); // const for hooks
    
    let temporaryValue = ""; // let for values that change within function
};
‚ö†Ô∏è Common Pitfalls & Solutions
1. Accidental Reassignment
javascript
const items = [1, 2, 3];
// items = [4, 5, 6]; // ‚ùå Error

// ‚úÖ Solution: Modify instead of reassign
items.length = 0; // Clear array
items.push(4, 5, 6); // Add new items
2. Block Scope Confusion
javascript
if (true) {
    let blockScoped = "I'm here";
    const alsoBlockScoped = "Me too";
}
// console.log(blockScoped); // ‚ùå ReferenceError
3. Loop Variables
javascript
// ‚úÖ Correct - let creates new binding each iteration
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100); // 0, 1, 2, 3, 4
}

// ‚ùå Problematic - var shares same binding
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 100); // 5, 5, 5, 5, 5
}
üéØ Interview Ready Summary
When asked in interviews:

"I use const by default for all variables that won't be reassigned, let for variables that need reassignment, and avoid var due to its function scoping and hoisting behavior which can lead to unexpected bugs. const doesn't make values immutable, it only prevents reassignment of the variable itself."

This answer shows:

Understanding of modern JS practices

Awareness of scope and hoisting implications

Practical experience with real-world usage
----------------------------------------------

How does JavaScript handle asynchronous operations? explain
How JavaScript Handles Asynchronous Operations
üéØ The Core Problem
JavaScript is single-threaded, meaning it can only do one thing at a time. But we need to handle multiple operations like:

API calls (take 2-3 seconds)

File operations

Timers

User interactions

Without blocking the main thread!

üîÑ The Solution: Event Loop + Callback Queue
Synchronous (Blocking) Code:
javascript
console.log('Start');

function syncOperation() {
    console.log('Processing...');
    // Simulate heavy computation
    for (let i = 0; i < 1000000000; i++) {}
    console.log('Done');
}

syncOperation(); // Blocks everything for seconds

console.log('End');

// Output:
// "Start"
// "Processing..."
// "Done" (after delay)
// "End"
Asynchronous (Non-blocking) Code:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout completed');
}, 2000);

console.log('End');

// Output:
// "Start"
// "End" (immediately)
// "Timeout completed" (after 2 seconds)
üèóÔ∏è JavaScript Runtime Architecture
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CALL STACK    ‚îÇ    ‚îÇ  WEB APIs        ‚îÇ    ‚îÇ  CALLBACK QUEUE ‚îÇ
‚îÇ (Main Thread)   ‚îÇ    ‚îÇ (Browser/Node)   ‚îÇ    ‚îÇ (Task Queue)    ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ function calls  ‚îÇ    ‚îÇ setTimeout       ‚îÇ    ‚îÇ Callbacks       ‚îÇ
‚îÇ execution       ‚îÇ    ‚îÇ fetch            ‚îÇ    ‚îÇ waiting         ‚îÇ
‚îÇ context         ‚îÇ    ‚îÇ DOM events       ‚îÇ    ‚îÇ to execute      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ  EVENT LOOP   ‚îÇ
                         ‚îÇ               ‚îÇ
                         ‚îÇ Monitors      ‚îÇ
                         ‚îÇ Stack & Queue ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üìö Async Mechanisms Evolution
1. Callbacks (The OG Way)
javascript
// Simple callback
function fetchData(callback) {
    setTimeout(() => {
        callback('Data received');
    }, 1000);
}

fetchData((result) => {
    console.log(result); // "Data received" after 1 second
});

// ‚ùå Callback Hell (Pyramid of Doom)
getUser(userId, (user) => {
    getPosts(user.id, (posts) => {
        getComments(posts[0].id, (comments) => {
            getReplies(comments[0].id, (replies) => {
                console.log(replies); // üòµ‚Äçüí´ Nested mess!
            });
        });
    });
});
2. Promises (ES6)
javascript
// Promise-based approach
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const success = Math.random() > 0.3;
            success ? resolve('Data received') : reject('Error occurred');
        }, 1000);
    });
}

// Usage
fetchData()
    .then(result => {
        console.log(result);
        return processData(result);
    })
    .then(processed => {
        console.log(processed);
    })
    .catch(error => {
        console.error('Error:', error);
    })
    .finally(() => {
        console.log('Operation completed');
    });

// ‚úÖ Multiple async operations
Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
])
.then(([user, posts, comments]) => {
    console.log('All data loaded');
})
.catch(error => {
    console.error('One request failed');
});
3. Async/Await (ES2017) - Modern Way
javascript
// Async/await - syntactic sugar over Promises
async function loadUserData() {
    try {
        console.log('Loading user data...');
        
        const user = await fetchUser();
        const posts = await fetchPosts(user.id);
        const comments = await fetchComments(posts[0].id);
        
        console.log('All data loaded:', { user, posts, comments });
        return { user, posts, comments };
    } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
    } finally {
        console.log('Data loading attempt completed');
    }
}

// Usage
loadUserData()
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Failure:', error));
üîß Detailed Execution Flow
Example with All Components:
javascript
console.log('Script start'); // 1

// Macro-task (setTimeout)
setTimeout(() => {
    console.log('setTimeout'); // 4
}, 0);

// Micro-task (Promise)
Promise.resolve()
    .then(() => {
        console.log('Promise 1'); // 3
    })
    .then(() => {
        console.log('Promise 2'); // 3.1
    });

// Synchronous code
console.log('Script end'); // 2

// Output Order:
// "Script start"
// "Script end" 
// "Promise 1"
// "Promise 2"
// "setTimeout"
üé™ Task Queues Priority
Microtasks vs Macrotasks:
javascript
console.log('Start');

// Macrotask (lower priority)
setTimeout(() => console.log('Timeout'), 0);

// Microtask (higher priority)
Promise.resolve().then(() => console.log('Promise'));

// Synchronous
console.log('End');

// Execution:
// 1. Call Stack: "Start", "End"
// 2. Microtask Queue: "Promise"
// 3. Macrotask Queue: "Timeout"

// Output:
// "Start"
// "End"
// "Promise"
// "Timeout"
Complex Example:
javascript
console.log('1 - Sync');

setTimeout(() => console.log('2 - Timeout'), 0);

Promise.resolve()
    .then(() => {
        console.log('3 - Promise');
        setTimeout(() => console.log('4 - Timeout in Promise'), 0);
    });

Promise.resolve()
    .then(() => console.log('5 - Promise 2'));

console.log('6 - Sync end');

// Output:
// "1 - Sync"
// "6 - Sync end"
// "3 - Promise"
// "5 - Promise 2"
// "2 - Timeout"
// "4 - Timeout in Promise"
üåê Real-World Async Patterns
1. API Calls with Error Handling
javascript
async function fetchUserWithRetry(userId, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(`/api/users/${userId}`);
            if (!response.ok) throw new Error('Network error');
            return await response.json();
        } catch (error) {
            if (i === retries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
    }
}

// Usage
fetchUserWithRetry(123)
    .then(user => console.log('User:', user))
    .catch(error => console.error('Failed after retries:', error));
2. Parallel Execution
javascript
// Sequential (slow)
async function sequentialFetch() {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);    // Waits for user first
    const comments = await fetchComments(posts[0].id); // Waits for posts
    return { user, posts, comments };
}

// Parallel (fast)
async function parallelFetch() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    return { user, posts, comments };
}

// Mixed approach
async function smartFetch(userId) {
    const user = await fetchUser(userId);
    
    const [posts, profile] = await Promise.all([
        fetchPosts(userId),
        fetchProfile(userId)
    ]);
    
    return { user, posts, profile };
}
3. Race Conditions & Cancellation
javascript
// Using AbortController for cancellation
function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    return fetch(url, { signal: controller.signal })
        .then(response => {
            clearTimeout(timeoutId);
            return response.json();
        })
        .catch(error => {
            clearTimeout(timeoutId);
            throw error;
        });
}

// Race: First to complete wins
Promise.race([
    fetchWithTimeout('/api/data', 2000),
    new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 3000)
    )
])
.then(data => console.log('Data:', data))
.catch(error => console.error('Error:', error.message));
‚ö° Performance Implications
Blocking the Event Loop:
javascript
// ‚ùå DON'T: Blocking operation
function calculateHashSync(data) {
    // Heavy computation blocks everything
    let hash = 0;
    for (let i = 0; i < 1000000000; i++) {
        hash = (hash << 5) - hash + i;
    }
    return hash;
}

// ‚úÖ DO: Use Web Workers or break into chunks
async function calculateHashAsync(data) {
    // Use setTimeout to yield control
    return new Promise(resolve => {
        setTimeout(() => {
            const hash = performCalculation(data);
            resolve(hash);
        }, 0);
    });
}
üéØ Key Takeaways
JavaScript is single-threaded but handles async via Event Loop

Call Stack executes synchronous code

Web APIs handle async operations (timers, network requests)

Callback Queue holds completed async operations

Event Loop moves callbacks from queue to stack when stack is empty

Microtasks (Promises) have higher priority than Macrotasks (setTimeout)

Async/Await is the modern, readable way to handle async code

üí° Interview Ready Summary
"JavaScript handles asynchronous operations through its event-driven architecture. While the call stack handles synchronous execution, async operations like timers, network requests, and file I/O are delegated to browser/Node.js APIs. When these operations complete, their callbacks are placed in task queues. The event loop continuously monitors the call stack and when empty, pushes callbacks from the queues to the stack for execution. This non-blocking I/O model allows JavaScript to handle concurrent operations efficiently despite being single-threaded."

This architecture is why JavaScript can handle thousands of concurrent connections with great performance! üöÄ


--------------------------------------------------------------------------------------------------------

xplain the concept of hoisting in JavaScript explain
Hoisting in JavaScript - Complete Guide
üéØ What is Hoisting?
Hoisting is JavaScript's behavior of moving declarations to the top of their scope during the compilation phase, before code execution.

üìù Key Concept
Note: Only declarations are hoisted, not initializations!

üîç Variable Hoisting
var Hoisting
javascript
// How we write it:
console.log(x); // undefined (not ReferenceError)
var x = 5;
console.log(x); // 5

// How JavaScript interprets it:
var x;          // Declaration hoisted to top
console.log(x); // undefined
x = 5;          // Initialization stays in place
console.log(x); // 5
let and const Hoisting (Temporal Dead Zone)
javascript
// ‚ùå Temporal Dead Zone (TDZ)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

console.log(z); // ReferenceError: Cannot access 'z' before initialization
const z = 15;

// How JavaScript interprets it:
let y;          // Declaration hoisted but NOT initialized
const z;        // Declaration hoisted but NOT initialized
console.log(y); // Error - in TDZ
console.log(z); // Error - in TDZ
y = 10;         // Initialization
z = 15;         // Initialization
üé™ Function Hoisting
Function Declarations (Fully Hoisted)
javascript
// ‚úÖ Function declarations are fully hoisted
sayHello(); // "Hello!" - works fine

function sayHello() {
    console.log("Hello!");
}

// How JavaScript interprets it:
function sayHello() {  // Entire function hoisted
    console.log("Hello!");
}
sayHello(); // Works!
Function Expressions (Partially Hoisted)
javascript
// ‚ùå Function expressions - only variable is hoisted
// sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
    console.log("Hi!");
};

sayHi(); // "Hi!" - works here

// How JavaScript interprets it:
var sayHi;              // Declaration hoisted (undefined)
// sayHi();             // Error - sayHi is undefined
sayHi = function() {    // Assignment stays here
    console.log("Hi!");
};
sayHi(); // Works!
Arrow Functions (Same as Function Expressions)
javascript
// ‚ùå Arrow functions - only variable is hoisted
// greet(); // TypeError: greet is not a function

var greet = () => {
    console.log("Greetings!");
};

greet(); // "Greetings!" - works here
‚ö° Hoisting in Different Scopes
Global Scope
javascript
console.log(globalVar); // undefined
var globalVar = "I'm global";

// Equivalent to:
var globalVar;
console.log(globalVar);
globalVar = "I'm global";
Function Scope
javascript
function test() {
    console.log(localVar); // undefined
    var localVar = "I'm local";
    console.log(localVar); // "I'm local"
}
test();

// Equivalent to:
function test() {
    var localVar;
    console.log(localVar); // undefined
    localVar = "I'm local";
    console.log(localVar); // "I'm local"
}
Block Scope (let/const)
javascript
function blockExample() {
    console.log(beforeBlock); // undefined
    
    {
        // console.log(blockVar); // ReferenceError: TDZ!
        let blockVar = "inside block";
        console.log(blockVar); // "inside block"
    }
    
    // console.log(blockVar); // ReferenceError: not accessible
    var beforeBlock = "hoisted";
}
blockExample();
üé≠ Hoisting Order of Precedence
Functions First, Then Variables
javascript
// Example 1
console.log(typeof myFunc); // "function"
console.log(typeof myVar);  // "undefined"

function myFunc() {
    return "I'm a function";
}
var myVar = "I'm a variable";

// How JavaScript interprets it:
function myFunc() {         // Function hoisted first
    return "I'm a function";
}
var myVar;                  // Variable declaration hoisted
console.log(typeof myFunc); // "function"
console.log(typeof myVar);  // "undefined"
myVar = "I'm a variable";   // Initialization
Duplicate Declarations
javascript
// Function declaration overrides variable declaration
console.log(typeof example); // "function"

var example = "I'm a variable";
function example() {
    return "I'm a function";
}

console.log(typeof example); // "string"

// How JavaScript interprets it:
function example() {        // Function hoisted first
    return "I'm a function";
}
var example;                // Variable declaration (ignored - function exists)
console.log(typeof example); // "function"
example = "I'm a variable"; // Reassignment
console.log(typeof example); // "string"
üî• Practical Examples & Gotchas
Example 1: Tricky Hoisting
javascript
var x = 1;

function test() {
    console.log(x); // undefined (not 1!)
    var x = 2;
    console.log(x); // 2
}

test();
console.log(x); // 1

// Equivalent to:
var x = 1;

function test() {
    var x;        // Declaration hoisted (shadows global x)
    console.log(x); // undefined
    x = 2;        // Initialization
    console.log(x); // 2
}

test();
console.log(x); // 1 (global x unchanged)
Example 2: Function vs Variable
javascript
// Scenario 1
var a = 1;
function a() {}
console.log(typeof a); // "number"

// Scenario 2
function b() {}
var b = 1;
console.log(typeof b); // "number"

// Both scenarios interpreted as:
function a() {}  // Function hoisted
function b() {}  // Function hoisted
var a;           // Ignored (function exists)
var b;           // Ignored (function exists)
a = 1;           // Reassignment
b = 1;           // Reassignment
console.log(typeof a); // "number"
console.log(typeof b); // "number"
Example 3: Conditional Function Declarations
javascript
// ‚ùå Avoid this - behavior is inconsistent
if (true) {
    function conditionalFunc() {
        return "I'm in true block";
    }
} else {
    function conditionalFunc() {
        return "I'm in false block";
    }
}

console.log(conditionalFunc()); // Varies by browser and strict mode
üõ°Ô∏è Best Practices to Avoid Hoisting Issues
1. Use let and const
javascript
// ‚úÖ Good - no hoisting surprises
console.log(myLet);    // ReferenceError
console.log(myConst);  // ReferenceError
let myLet = "value";
const myConst = "value";

// ‚ùå Avoid - hoisting can cause bugs
console.log(myVar); // undefined (silent failure)
var myVar = "value";
2. Declare Variables at Top
javascript
// ‚úÖ Good practice
function cleanFunction() {
    // Declare all variables at top
    const config = getConfig();
    let isLoading = false;
    const data = [];
    
    // Then use them
    if (config.enabled) {
        isLoading = true;
        // ... rest of logic
    }
}
3. Use Function Expressions for Conditional Logic
javascript
// ‚úÖ Clear and predictable
let myFunction;

if (condition) {
    myFunction = function() {
        console.log("Condition true");
    };
} else {
    myFunction = function() {
        console.log("Condition false");
    };
}

myFunction(); // Always works as expected
üìä Hoisting Summary Table
Declaration Type	Hoisting	Initial Value	Scope
var	‚úÖ Yes	undefined	Function
let	‚úÖ Yes (TDZ)	Uninitialized	Block
const	‚úÖ Yes (TDZ)	Uninitialized	Block
Function Declaration	‚úÖ Yes	Function itself	Block (strict)
Function Expression	‚ö†Ô∏è Variable only	undefined	Depends on variable
Arrow Function	‚ö†Ô∏è Variable only	undefined	Depends on variable
üéØ Interview Ready Explanation
"Hoisting is JavaScript's mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution. However, only declarations are hoisted, not initializations.

Key points:

var declarations are hoisted and initialized with undefined

let and const are hoisted but remain uninitialized (Temporal Dead Zone)

Function declarations are fully hoisted with their definitions

Function expressions follow variable hoisting rules

Best practice is to use let/const and declare variables at the top of their scope to avoid unexpected behavior."

üí° Quick Mental Model
javascript
// What you write:
console.log(a);
var a = 10;
function b() { return 20; }

// What JavaScript does:
function b() { return 20; }  // Functions first
var a;                       // Then variables
console.log(a); // undefined
a = 10;         // Then assignments
Understanding hoisting helps you avoid subtle bugs and write more predictable JavaScript code! üöÄ
------------------------------------------------------------------------

What are closures and how do they work?
Closures in JavaScript - Complete Guide
üéØ What is a Closure?
A closure is a function that has access to variables from its outer (enclosing) scope even after the outer function has finished executing.

üí° Simple Definition
"A closure gives you access to an outer function's scope from an inner function"

üîç Basic Example
javascript
function outer() {
    const outerVar = "I'm from outer scope!";
    
    function inner() {
        console.log(outerVar); // Accesses outerVar
    }
    
    return inner;
}

const closureFunc = outer();
closureFunc(); // "I'm from outer scope!" - Still remembers outerVar!
üèóÔ∏è How Closures Work
Step-by-Step Execution:
javascript
function createCounter() {
    let count = 0; // This variable is "closed over"
    
    return function() {
        count++;    // Remembers count between calls
        return count;
    };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Each call remembers the same 'count' variable!
üìö Types of Closures
1. Function Returning Function
javascript
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

console.log(sayHello("Alice")); // "Hello, Alice!"
console.log(sayHi("Bob"));      // "Hi, Bob!"

// Each function remembers its own 'greeting'
2. IIFE (Immediately Invoked Function Expression)
javascript
const uniqueId = (function() {
    let id = 0;
    
    return function() {
        return id++;
    };
})();

console.log(uniqueId()); // 0
console.log(uniqueId()); // 1
console.log(uniqueId()); // 2
3. Event Handlers
javascript
function setupButtons() {
    const buttons = document.querySelectorAll('button');
    
    for (var i = 0; i < buttons.length; i++) {
        // Without closure - problem!
        buttons[i].addEventListener('click', function() {
            console.log('Button ' + i + ' clicked'); // Always "Button 3 clicked"
        });
    }
}

// Fixed with closure:
function setupButtonsFixed() {
    const buttons = document.querySelectorAll('button');
    
    for (var i = 0; i < buttons.length; i++) {
        (function(index) {
            buttons[index].addEventListener('click', function() {
                console.log('Button ' + index + ' clicked'); // Correct index!
            });
        })(i);
    }
}

// Modern solution with let:
function setupButtonsModern() {
    const buttons = document.querySelectorAll('button');
    
    for (let i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
            console.log('Button ' + i + ' clicked'); // Works with let!
        });
    }
}
üî• Practical Use Cases
1. Data Privacy & Encapsulation
javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return "Insufficient funds";
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);
console.log(account.getBalance()); // 1000
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300

// ‚ùå Cannot access balance directly
// console.log(account.balance); // undefined
2. Function Factories
javascript
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5));  // 10
console.log(triple(5));  // 15
console.log(quadruple(5)); // 20
3. Memoization (Caching)
javascript
function memoize(fn) {
    const cache = {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache[key]) {
            console.log('Returning cached result');
            return cache[key];
        }
        
        console.log('Calculating result');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// Expensive function
function slowSquare(n) {
    for (let i = 0; i < 1000000000; i++) {} // Simulate slow operation
    return n * n;
}

const memoizedSquare = memoize(slowSquare);

console.log(memoizedSquare(5)); // "Calculating result" then 25
console.log(memoizedSquare(5)); // "Returning cached result" then 25 (fast!)
4. Partial Application & Currying
javascript
// Partial application
function partial(fn, ...fixedArgs) {
    return function(...remainingArgs) {
        return fn.apply(this, fixedArgs.concat(remainingArgs));
    };
}

function multiply(a, b, c) {
    return a * b * c;
}

const multiplyByTwo = partial(multiply, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

// Currying
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)); // 24
üîß Advanced Closure Patterns
1. Module Pattern
javascript
const Calculator = (function() {
    let memory = 0;
    
    function add(a, b) {
        return a + b;
    }
    
    function subtract(a, b) {
        return a - b;
    }
    
    function store(value) {
        memory = value;
    }
    
    function recall() {
        return memory;
    }
    
    // Public API
    return {
        add,
        subtract,
        store,
        recall
    };
})();

console.log(Calculator.add(5, 3)); // 8
Calculator.store(100);
console.log(Calculator.recall()); // 100

// ‚ùå Private variables inaccessible
// console.log(Calculator.memory); // undefined
2. React Hooks (Closures in Action)
javascript
// Simplified useState implementation
function useState(initialValue) {
    let state = initialValue;
    
    function setState(newValue) {
        state = newValue;
        // Trigger re-render logic here
        console.log('State updated to:', state);
    }
    
    function getState() {
        return state;
    }
    
    return [getState, setState];
}

// Usage similar to React
const [getCount, setCount] = useState(0);
console.log(getCount()); // 0
setCount(5);
console.log(getCount()); // 5
‚ö†Ô∏è Common Pitfalls & Solutions
1. Loop Variable Capture
javascript
// ‚ùå Problem: All functions share same 'i'
function createFunctionsProblem() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i); // Always 3!
        });
    }
    
    return functions;
}

const funcs = createFunctionsProblem();
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3

// ‚úÖ Solution 1: IIFE
function createFunctionsFixed() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        (function(index) {
            functions.push(function() {
                console.log(index); // 0, 1, 2
            });
        })(i);
    }
    
    return functions;
}

// ‚úÖ Solution 2: Use let
function createFunctionsModern() {
    var functions = [];
    
    for (let i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i); // 0, 1, 2
        });
    }
    
    return functions;
}
2. Memory Leaks
javascript
// ‚ùå Potential memory leak
function createHeavyClosure() {
    const largeData = new Array(1000000).fill("data");
    
    return function() {
        console.log('Closure using large data');
        // largeData stays in memory even if not used!
    };
}

// ‚úÖ Solution: Release references
function createOptimizedClosure() {
    let largeData = new Array(1000000).fill("data");
    
    const usefulFunction = function() {
        console.log('Using data:', largeData[0]);
    };
    
    // Allow cleanup
    usefulFunction.cleanup = function() {
        largeData = null;
    };
    
    return usefulFunction;
}
üéØ Interview Questions & Answers
Q: What creates a closure?
A: A closure is created when a function is defined inside another function and the inner function references variables from the outer function's scope.

Q: Why are closures useful?
A: Closures enable:

Data privacy and encapsulation

Function factories and currying

Memoization and caching

Event handlers with preserved context

Module patterns

Q: What's the relationship between closures and scope?
A: Closures have access to:

Their own scope (variables defined between curly braces)

Outer function's scope

Global scope

üí° Key Takeaways
Closures remember their lexical environment - variables available at creation time

Every function in JavaScript is a closure (except arrow functions in some cases)

Closures enable powerful patterns like modules, memoization, and currying

Watch for memory leaks - closures can prevent garbage collection

Use closures for data encapsulation and private variables

üî¨ Under the Hood
javascript
function outer(x) {
    return function inner(y) {
        return x + y;
    };
}

const add5 = outer(5);
console.log(add5(3)); // 8

// What happens:
// 1. outer(5) executes, creates execution context
// 2. inner function is created, captures reference to x (5)
// 3. outer finishes, but inner maintains reference to x
// 4. add5(3) executes, can still access x from closure
Closures are fundamental to JavaScript - they're what make functions first-class citizens and enable functional programming patterns! üöÄ

create tree diagram of above closure


Cancel

Send
I'll create a comprehensive tree diagram of all the JavaScript and React Native concepts from your question list.

üå≥ JavaScript & React Native Knowledge Tree
TRUNK: CORE FOUNDATIONS
1. üåø JavaScript Fundamentals
text
JavaScript Fundamentals
‚îú‚îÄ‚îÄ üì¶ Core Concepts
‚îÇ   ‚îú‚îÄ‚îÄ Event Loop & Call Stack
‚îÇ   ‚îú‚îÄ‚îÄ let vs const vs var
‚îÇ   ‚îú‚îÄ‚îÄ Asynchronous Operations
‚îÇ   ‚îú‚îÄ‚îÄ Hoisting
‚îÇ   ‚îú‚îÄ‚îÄ Closures
‚îÇ   ‚îú‚îÄ‚îÄ this Keyword & Binding
‚îÇ   ‚îú‚îÄ‚îÄ == vs ===
‚îÇ   ‚îú‚îÄ‚îÄ Prototypal Inheritance
‚îÇ   ‚îú‚îÄ‚îÄ Primitive vs Reference Types
‚îÇ   ‚îî‚îÄ‚îÄ Truthy/Falsy Values
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° ES6+ Features
‚îÇ   ‚îú‚îÄ‚îÄ Arrow Functions
‚îÇ   ‚îú‚îÄ‚îÄ Template Literals
‚îÇ   ‚îú‚îÄ‚îÄ Destructuring
‚îÇ   ‚îú‚îÄ‚îÄ Default Parameters
‚îÇ   ‚îú‚îÄ‚îÄ Spread/Rest Operators
‚îÇ   ‚îú‚îÄ‚îÄ Enhanced Object Literals
‚îÇ   ‚îú‚îÄ‚îÄ Loops (for, for...of, for...in, forEach)
‚îÇ   ‚îú‚îÄ‚îÄ Sets, Maps, WeakSet, WeakMap
‚îÇ   ‚îî‚îÄ‚îÄ Class Syntax
‚îÇ
‚îú‚îÄ‚îÄ üîß Functions & Scope
‚îÇ   ‚îú‚îÄ‚îÄ Function vs Block Scope
‚îÇ   ‚îú‚îÄ‚îÄ Lexical Scoping
‚îÇ   ‚îú‚îÄ‚îÄ Higher-Order Functions
‚îÇ   ‚îú‚îÄ‚îÄ Function Currying
‚îÇ   ‚îú‚îÄ‚îÄ bind() Method
‚îÇ   ‚îú‚îÄ‚îÄ Pure Functions
‚îÇ   ‚îî‚îÄ‚îÄ Memoization
‚îÇ
‚îú‚îÄ‚îÄ üîÑ Async JavaScript
‚îÇ   ‚îú‚îÄ‚îÄ Callbacks & Callback Hell
‚îÇ   ‚îú‚îÄ‚îÄ Promises
‚îÇ   ‚îú‚îÄ‚îÄ Promise Lifecycle
‚îÇ   ‚îú‚îÄ‚îÄ Async/Await
‚îÇ   ‚îú‚îÄ‚îÄ Microtasks vs Macrotasks
‚îÇ   ‚îú‚îÄ‚îÄ Promise.all vs Promise.allSettled
‚îÇ   ‚îú‚îÄ‚îÄ AbortController
‚îÇ   ‚îî‚îÄ‚îÄ Error Handling
‚îÇ
‚îî‚îÄ‚îÄ üéØ Objects & Arrays
    ‚îú‚îÄ‚îÄ Iteration Methods
    ‚îú‚îÄ‚îÄ Array Methods (map, filter, reduce, etc.)
    ‚îú‚îÄ‚îÄ Deep Cloning
    ‚îú‚îÄ‚îÄ Object Methods (create, assign, spread)
    ‚îú‚îÄ‚îÄ Object Modification Prevention
    ‚îú‚îÄ‚îÄ Getters/Setters
    ‚îî‚îÄ‚îÄ Prototype Chain
2. üåø React Native Core
text
React Native Core
‚îú‚îÄ‚îÄ üèóÔ∏è Architecture & Fundamentals
‚îÇ   ‚îú‚îÄ‚îÄ React Native vs Other Frameworks
‚îÇ   ‚îú‚îÄ‚îÄ Bridge Concept
‚îÇ   ‚îú‚îÄ‚îÄ Threading Model (UI, JS, Native)
‚îÇ   ‚îú‚îÄ‚îÄ Native Modules vs JS Components
‚îÇ   ‚îú‚îÄ‚îÄ New Architecture (Fabric, Turbo Modules, JSI)
‚îÇ   ‚îú‚îÄ‚îÄ Hermes Engine
‚îÇ   ‚îú‚îÄ‚îÄ Screen Densities & Resolutions
‚îÇ   ‚îú‚îÄ‚îÄ React Native vs Expo
‚îÇ   ‚îú‚îÄ‚îÄ Limitations
‚îÇ   ‚îú‚îÄ‚îÄ Hot Reloading vs Live Reloading
‚îÇ   ‚îú‚îÄ‚îÄ Component Lifecycle
‚îÇ   ‚îú‚îÄ‚îÄ Component Creation Methods
‚îÇ   ‚îú‚îÄ‚îÄ Styling Differences from Web
‚îÇ   ‚îî‚îÄ‚îÄ Metro Bundler
‚îÇ
‚îú‚îÄ‚îÄ üé® Core Components
‚îÇ   ‚îú‚îÄ‚îÄ View vs ScrollView
‚îÇ   ‚îú‚îÄ‚îÄ FlatList vs SectionList
‚îÇ   ‚îú‚îÄ‚îÄ Image vs ImageBackground
‚îÇ   ‚îú‚îÄ‚îÄ Pressable vs Touchable*
‚îÇ   ‚îú‚îÄ‚îÄ Flexbox in RN
‚îÇ   ‚îú‚îÄ‚îÄ Platform-Specific Styling
‚îÇ   ‚îú‚îÄ‚îÄ PixelRatio API
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ useWindowDimensions Hook
‚îÇ   ‚îú‚îÄ‚îÄ Dark/Light Mode
‚îÇ   ‚îú‚îÄ‚îÄ Text Overflow
‚îÇ   ‚îú‚îÄ‚îÄ Custom Components with TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ Image Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Custom Fonts
‚îÇ   ‚îú‚îÄ‚îÄ Screen Size Handling
‚îÇ   ‚îî‚îÄ‚îÄ Safe Areas & Notches
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° State Management & Hooks
‚îÇ   ‚îú‚îÄ‚îÄ Local vs Global State
‚îÇ   ‚îú‚îÄ‚îÄ Redux vs MobX vs Zustand vs Context API
‚îÇ   ‚îú‚îÄ‚îÄ Context API + useReducer
‚îÇ   ‚îú‚îÄ‚îÄ Performance Implications
‚îÇ   ‚îú‚îÄ‚îÄ useState with Complex Objects
‚îÇ   ‚îú‚îÄ‚îÄ useEffect & Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ useMemo vs useCallback
‚îÇ   ‚îú‚îÄ‚îÄ Custom Hooks
‚îÇ   ‚îú‚îÄ‚îÄ useRef Use Cases
‚îÇ   ‚îú‚îÄ‚îÄ Form State Management
‚îÇ   ‚îú‚îÄ‚îÄ useReducer for Complex Logic
‚îÇ   ‚îú‚îÄ‚îÄ AsyncStorage Persistence
‚îÇ   ‚îú‚îÄ‚îÄ API State Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Offline State & Sync
‚îÇ   ‚îú‚îÄ‚îÄ Debouncing & Throttling
‚îÇ   ‚îî‚îÄ‚îÄ Rules of Hooks
‚îÇ
‚îú‚îÄ‚îÄ üöÄ Performance Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Identifying Bottlenecks
‚îÇ   ‚îú‚îÄ‚îÄ Common Performance Issues
‚îÇ   ‚îú‚îÄ‚îÄ Bundle Size Optimization
‚îÇ   ‚îú‚îÄ‚îÄ useMemo & useCallback Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Flipper Debugging
‚îÇ   ‚îú‚îÄ‚îÄ List Keys Importance
‚îÇ   ‚îú‚îÄ‚îÄ Virtualized Lists
‚îÇ   ‚îú‚îÄ‚îÄ React.memo & shouldComponentUpdate
‚îÇ   ‚îú‚îÄ‚îÄ Reducing Re-renders
‚îÇ   ‚îú‚îÄ‚îÄ Image Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Memory Leaks
‚îÇ   ‚îú‚îÄ‚îÄ InteractionManager
‚îÇ   ‚îú‚îÄ‚îÄ Lazy Loading
‚îÇ   ‚îú‚îÄ‚îÄ Bridge Performance
‚îÇ   ‚îú‚îÄ‚îÄ Performance API
‚îÇ   ‚îú‚îÄ‚îÄ Hermes Benefits
‚îÇ   ‚îú‚îÄ‚îÄ Debouncing Search
‚îÇ   ‚îú‚îÄ‚îÄ Throttling Scroll
‚îÇ   ‚îî‚îÄ‚îÄ Animation Optimization
‚îÇ
‚îî‚îÄ‚îÄ üåê APIs & Networking
    ‚îú‚îÄ‚îÄ API Calls Handling
    ‚îú‚îÄ‚îÄ Fetch vs Axios vs React Query
    ‚îú‚îÄ‚îÄ SSL Pinning
    ‚îú‚îÄ‚îÄ Error Handling & Retry
    ‚îú‚îÄ‚îÄ File Uploads/Downloads
    ‚îú‚îÄ‚îÄ FormData API
    ‚îú‚îÄ‚îÄ WebSocket Connections
    ‚îú‚îÄ‚îÄ API Tokens & Auth
    ‚îú‚îÄ‚îÄ Request/Response Interceptors
    ‚îú‚îÄ‚îÄ NetInfo & Offline Detection
    ‚îú‚îÄ‚îÄ Environment Management
    ‚îî‚îÄ‚îÄ API Caching Strategies
BRANCHES: ADVANCED TOPICS
3. üçÇ TypeScript with React
text
TypeScript with React
‚îú‚îÄ‚îÄ üìù Fundamentals
‚îÇ   ‚îú‚îÄ‚îÄ Interface vs Type
‚îÇ   ‚îú‚îÄ‚îÄ Component Props Typing
‚îÇ   ‚îú‚îÄ‚îÄ Generic Types
‚îÇ   ‚îú‚îÄ‚îÄ Hooks Typing (useState, useEffect, useReducer)
‚îÇ   ‚îú‚îÄ‚îÄ Union Types
‚îÇ   ‚îú‚îÄ‚îÄ Optional Props & Defaults
‚îÇ   ‚îú‚îÄ‚îÄ Utility Types (Partial, Pick, Omit, Required)
‚îÇ   ‚îú‚îÄ‚îÄ Event Typing (onClick, onChange)
‚îÇ   ‚îú‚îÄ‚îÄ Type Inference
‚îÇ   ‚îî‚îÄ‚îÄ Custom Hooks with TS
‚îÇ
‚îú‚îÄ‚îÄ üé® Advanced Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Polymorphic Components
‚îÇ   ‚îú‚îÄ‚îÄ Discriminated Unions
‚îÇ   ‚îú‚îÄ‚îÄ Higher-Order Components (HOCs)
‚îÇ   ‚îú‚îÄ‚îÄ as const Assertion
‚îÇ   ‚îú‚îÄ‚îÄ Type-Safe Forms
‚îÇ   ‚îú‚îÄ‚îÄ Redux Slices & Actions
‚îÇ   ‚îú‚îÄ‚îÄ Type-Safe Event Emitters
‚îÇ   ‚îú‚îÄ‚îÄ Dependency Injection
‚îÇ   ‚îú‚îÄ‚îÄ React Context Typing
‚îÇ   ‚îú‚îÄ‚îÄ Children Typing
‚îÇ   ‚îú‚îÄ‚îÄ Component Refs
‚îÇ   ‚îî‚îÄ‚îÄ Template Literal Types
‚îÇ
‚îî‚îÄ‚îÄ ‚ö° Performance & Testing
    ‚îú‚îÄ‚îÄ React.memo with TS
    ‚îú‚îÄ‚îÄ useCallback & useMemo Typing
    ‚îú‚îÄ‚îÄ Large Type Definitions
    ‚îú‚îÄ‚îÄ Type-Safe Tests
    ‚îú‚îÄ‚îÄ Test Utilities & Fixtures
    ‚îú‚îÄ‚îÄ Third-Party Library Types
    ‚îú‚îÄ‚îÄ Error Boundaries
    ‚îî‚îÄ‚îÄ Complex State Shapes
4. üçÇ State Management
text
State Management
‚îú‚îÄ‚îÄ üî¥ Redux Toolkit
‚îÇ   ‚îú‚îÄ‚îÄ Problems Solved
‚îÇ   ‚îú‚îÄ‚îÄ Store Configuration
‚îÇ   ‚îú‚îÄ‚îÄ createSlice
‚îÇ   ‚îú‚îÄ‚îÄ Immutable Updates
‚îÇ   ‚îú‚îÄ‚îÄ Reducers vs ExtraReducers
‚îÇ   ‚îú‚îÄ‚îÄ createAsyncThunk
‚îÇ   ‚îú‚îÄ‚îÄ Loading States
‚îÇ   ‚îú‚îÄ‚îÄ Selector Optimization
‚îÇ   ‚îú‚îÄ‚îÄ createSelector (Reselect)
‚îÇ   ‚îú‚îÄ‚îÄ Preventing Re-renders
‚îÇ   ‚îî‚îÄ‚îÄ Testing
‚îÇ
‚îú‚îÄ‚îÄ üéØ Context API
‚îÇ   ‚îú‚îÄ‚îÄ Context + useReducer
‚îÇ   ‚îú‚îÄ‚îÄ Performance Implications
‚îÇ   ‚îú‚îÄ‚îÄ Selective Re-renders
‚îÇ   ‚îú‚îÄ‚îÄ Context vs Redux
‚îÇ   ‚îî‚îÄ‚îÄ Complex State Management
‚îÇ
‚îî‚îÄ‚îÄ üü¢ React Query (TanStack)
    ‚îú‚îÄ‚îÄ Problems Solved
    ‚îú‚îÄ‚îÄ Setup & Configuration
    ‚îú‚îÄ‚îÄ useQuery Hook
    ‚îú‚îÄ‚îÄ Query Keys Importance
    ‚îú‚îÄ‚îÄ Loading & Error States
    ‚îú‚îÄ‚îÄ Dependent Queries
    ‚îú‚îÄ‚îÄ Pagination
    ‚îú‚îÄ‚îÄ useMutation Hook
    ‚îú‚îÄ‚îÄ Optimistic Updates
    ‚îú‚îÄ‚îÄ Query Invalidation
    ‚îú‚îÄ‚îÄ Direct Data Updates
    ‚îú‚îÄ‚îÄ Request Deduplication
    ‚îî‚îÄ‚îÄ Cache Garbage Collection
5. üçÇ Styling
text
Styling
‚îú‚îÄ‚îÄ üé® StyleSheet API
‚îÇ   ‚îú‚îÄ‚îÄ Advantages over Inline Styles
‚îÇ   ‚îú‚îÄ‚îÄ Performance Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Dynamic Styles
‚îÇ   ‚îú‚îÄ‚îÄ Style Combination
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ Platform-Specific Styles
‚îÇ   ‚îî‚îÄ‚îÄ StyleSheet.create() Benefits
‚îÇ
‚îú‚îÄ‚îÄ üåÄ Tailwind/NativeWind
‚îÇ   ‚îú‚îÄ‚îÄ NativeWind Introduction
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js Configuration
‚îÇ   ‚îú‚îÄ‚îÄ Dark Mode Handling
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ Dynamic Classes
‚îÇ   ‚îú‚îÄ‚îÄ Component Variants
‚îÇ   ‚îî‚îÄ‚îÄ Performance Considerations
‚îÇ
‚îî‚îÄ‚îÄ üíÖ Styled Components
    ‚îú‚îÄ‚îÄ How They Work
    ‚îú‚îÄ‚îÄ Theme Implementation
    ‚îú‚îÄ‚îÄ Responsive Design
    ‚îú‚îÄ‚îÄ Polymorphic Components
    ‚îú‚îÄ‚îÄ Conditional Styling
    ‚îú‚îÄ‚îÄ Performance Implications
    ‚îî‚îÄ‚îÄ Re-render Optimization
LEAVES: SPECIALIZED TOPICS
6. üçÅ Navigation
text
Navigation
‚îú‚îÄ‚îÄ React Navigation vs React Native Navigation
‚îú‚îÄ‚îÄ Stack Navigation with Parameters
‚îú‚îÄ‚îÄ Stack vs Tab vs Drawer Navigators
‚îú‚îÄ‚îÄ Authentication Flows
‚îú‚îÄ‚îÄ Deep Linking
‚îú‚îÄ‚îÄ Complex Object Passing
‚îú‚îÄ‚îÄ Navigation References
‚îú‚îÄ‚îÄ State Persistence
‚îú‚îÄ‚îÄ Lifecycle Methods
‚îú‚îÄ‚îÄ Custom Transitions
‚îú‚îÄ‚îÄ Protected Routes
‚îú‚îÄ‚îÄ Navigation Containers
‚îú‚îÄ‚îÄ Nested Navigation
‚îú‚îÄ‚îÄ Hardware Back Button
‚îî‚îÄ‚îÄ Modal Screens
7. üçÅ Advanced Patterns
text
Advanced Patterns
‚îú‚îÄ‚îÄ Biometric Authentication
‚îú‚îÄ‚îÄ Push Notifications (FCM/APNS)
‚îú‚îÄ‚îÄ In-App Purchases
‚îú‚îÄ‚îÄ Accessibility Best Practices
‚îú‚îÄ‚îÄ RTL Layouts
‚îú‚îÄ‚îÄ LayoutAnimation API
‚îú‚îÄ‚îÄ Component Libraries
‚îú‚îÄ‚îÄ Tablet Support
‚îú‚îÄ‚îÄ Theming in Large Apps
‚îú‚îÄ‚îÄ react-native-reanimated
‚îú‚îÄ‚îÄ Complex Gesture Handling
‚îú‚îÄ‚îÄ Security Best Practices
‚îú‚îÄ‚îÄ Reverse Engineering Prevention
‚îú‚îÄ‚îÄ Version Migration
‚îú‚îÄ‚îÄ Background Tasks
‚îú‚îÄ‚îÄ Deep Linking with Parameters
‚îú‚îÄ‚îÄ Video Streaming
‚îú‚îÄ‚îÄ Maps & Location Services
‚îú‚îÄ‚îÄ Audio Recording/Playback
‚îî‚îÄ‚îÄ Camera & Photo Library
8. üçÅ Testing & Debugging
text
Testing & Debugging
‚îú‚îÄ‚îÄ Testing Frameworks
‚îú‚îÄ‚îÄ Jest Setup
‚îú‚îÄ‚îÄ Unit vs Integration vs E2E Testing
‚îú‚îÄ‚îÄ React Testing Library
‚îú‚îÄ‚îÄ Detox for E2E
‚îú‚îÄ‚îÄ Flipper Debugging
‚îú‚îÄ‚îÄ Chrome DevTools
‚îú‚îÄ‚îÄ Error Tracking & Crash Reporting
‚îú‚îÄ‚îÄ Native Issues Debugging
‚îú‚îÄ‚îÄ Platform-Specific Code Testing
‚îú‚îÄ‚îÄ Native Module Mocking
‚îú‚îÄ‚îÄ Snapshot Testing
‚îú‚îÄ‚îÄ Navigation Flow Testing
‚îú‚îÄ‚îÄ CI/CD Testing
‚îî‚îÄ‚îÄ Test Coverage Measurement
ROOTS: INFRASTRUCTURE
9. üå± Storage & APIs
text
Storage & APIs
‚îú‚îÄ‚îÄ üíæ Storage Options
‚îÇ   ‚îú‚îÄ‚îÄ AsyncStorage vs MMKV vs SQLite vs Realm
‚îÇ   ‚îú‚îÄ‚îÄ SQLite vs Key-Value Storage
‚îÇ   ‚îú‚îÄ‚îÄ Secure Storage for Sensitive Data
‚îÇ   ‚îú‚îÄ‚îÄ Keychain & SharedPreferences
‚îÇ   ‚îú‚îÄ‚îÄ Data Synchronization
‚îÇ   ‚îú‚îÄ‚îÄ Database Schema Migrations
‚îÇ   ‚îú‚îÄ‚îÄ Caching Strategies
‚îÇ   ‚îú‚îÄ‚îÄ MMKV Advantages
‚îÇ   ‚îú‚îÄ‚îÄ Large Dataset Storage
‚îÇ   ‚îú‚îÄ‚îÄ Realm vs SQLite
‚îÇ   ‚îî‚îÄ‚îÄ Offline-First Strategies
‚îÇ
‚îî‚îÄ‚îÄ üåê Advanced APIs
    ‚îú‚îÄ‚îÄ Background Sync
    ‚îú‚îÄ‚îÄ Large File Downloads with Progress
    ‚îú‚îÄ‚îÄ Network Security
    ‚îú‚îÄ‚îÄ WebSocket Connections
    ‚îú‚îÄ‚îÄ Real-time Updates
    ‚îî‚îÄ‚îÄ File Uploads with Progress
10. üå± Deployment & CI/CD
text
Deployment & CI/CD
‚îú‚îÄ‚îÄ iOS App Distribution
‚îú‚îÄ‚îÄ Android App Distribution
‚îú‚îÄ‚îÄ Dev/Staging/Production Builds
‚îú‚îÄ‚îÄ CodePush for OTA Updates
‚îú‚îÄ‚îÄ App Signing Process
‚îú‚îÄ‚îÄ Fastlane Automation
‚îú‚îÄ‚îÄ App Store Submission
‚îú‚îÄ‚îÄ Versioning & Build Numbers
‚îú‚îÄ‚îÄ CI/CD Pipeline Setup
‚îú‚îÄ‚îÄ Environment Configurations
‚îú‚îÄ‚îÄ Deployment Pitfalls
‚îú‚îÄ‚îÄ Beta Testing & Distribution
‚îú‚îÄ‚îÄ Production Performance Monitoring
‚îî‚îÄ‚îÄ Rollbacks & Emergency Updates
FRUITS: PRACTICAL APPLICATIONS
11. üçé Real-World Scenarios
text
Real-World Scenarios
‚îú‚îÄ‚îÄ Debugging Memory Leaks
‚îú‚îÄ‚îÄ Optimizing 1000+ Item Lists
‚îú‚îÄ‚îÄ Real-time Chat with Offline Support
‚îú‚îÄ‚îÄ Poor Network Handling
‚îú‚îÄ‚îÄ Architecture Migration
‚îú‚îÄ‚îÄ Complex Animation Sequences
‚îú‚îÄ‚îÄ Multi-screen Data Sync
‚îú‚îÄ‚îÄ Internationalization (i18n)
‚îú‚îÄ‚îÄ A/B Testing & Feature Flags
‚îî‚îÄ‚îÄ App Startup Time Optimization
12. üçé Library-Specific Expertise
text
Library-Specific Expertise
‚îú‚îÄ‚îÄ üîÑ Axios
‚îÇ   ‚îú‚îÄ‚îÄ vs Fetch API
‚îÇ   ‚îú‚îÄ‚îÄ Custom Configuration
‚îÇ   ‚îú‚îÄ‚îÄ Content Type Handling
‚îÇ   ‚îú‚îÄ‚îÄ Request Cancellation
‚îÇ   ‚îú‚îÄ‚îÄ Timeout Handling
‚îÇ   ‚îú‚îÄ‚îÄ Interceptors
‚îÇ   ‚îú‚îÄ‚îÄ Automatic Token Refresh
‚îÇ   ‚îú‚îÄ‚îÄ Request Retry Logic
‚îÇ   ‚îî‚îÄ‚îÄ Centralized Error Handling
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° Advanced JavaScript
‚îÇ   ‚îú‚îÄ‚îÄ Proxy & Reflect API
‚îÇ   ‚îú‚îÄ‚îÄ WebAssembly Use Cases
‚îÇ   ‚îú‚îÄ‚îÄ Internationalization API (Intl)
‚îÇ   ‚îú‚îÄ‚îÄ JavaScript Decorators
‚îÇ   ‚îú‚îÄ‚îÄ BigInt Handling
‚îÇ   ‚îú‚îÄ‚îÄ WeakRefs
‚îÇ   ‚îî‚îÄ‚îÄ Web Cryptography API
‚îÇ
‚îî‚îÄ‚îÄ üèóÔ∏è System Design
    ‚îú‚îÄ‚îÄ Large App Structure
    ‚îú‚îÄ‚îÄ Clean Code Principles
    ‚îú‚îÄ‚îÄ State Management in Large Apps
    ‚îú‚îÄ‚îÄ Microfrontends
    ‚îú‚îÄ‚îÄ Caching Strategies
    ‚îú‚îÄ‚îÄ API Design Best Practices
    ‚îú‚îÄ‚îÄ Authentication & Authorization
    ‚îú‚îÄ‚îÄ Feature Flags
    ‚îî‚îÄ‚îÄ A/B Testing Implementation
------------------------------------------------------

create tree diagram of above closure
Closure Tree Diagram
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CLOSURES IN JAVESCRIPT                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      CORE DEFINITION: Function + Lexical Environment           ‚îÇ
‚îÇ  "Inner function that remembers outer scope variables"         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   HOW IT      ‚îÇ       ‚îÇ   PRACTICAL   ‚îÇ       ‚îÇ  ADVANCED     ‚îÇ
‚îÇ   WORKS       ‚îÇ       ‚îÇ   USE CASES   ‚îÇ       ‚îÇ  PATTERNS     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Scope Chain   ‚îÇ   ‚îÇ Data Privacy    ‚îÇ   ‚îÇ Module Pattern    ‚îÇ
‚îÇ Lexical Env   ‚îÇ   ‚îÇ Function Factory‚îÇ   ‚îÇ Memoization       ‚îÇ
‚îÇ Memory Persist‚îÇ   ‚îÇ Event Handlers  ‚îÇ   ‚îÇ Currying          ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÇ Partial App     ‚îÇ   ‚îÇ React Hooks-like  ‚îÇ
                    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                                ‚îÇ
                                ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ COMMON PITFALLS &   ‚îÇ
                    ‚îÇ SOLUTIONS           ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Loop Variable ‚îÇ       ‚îÇ Memory Leaks  ‚îÇ       ‚îÇ Performance   ‚îÇ
‚îÇ Capture       ‚îÇ       ‚îÇ               ‚îÇ       ‚îÇ Optimization  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Problem: All  ‚îÇ   ‚îÇ Large data stays ‚îÇ   ‚îÇ Cleanup methods   ‚îÇ
‚îÇ funcs see     ‚îÇ   ‚îÇ in memory        ‚îÇ   ‚îÇ WeakMap/WeakSet   ‚îÇ
‚îÇ final i value ‚îÇ   ‚îÇ                  ‚îÇ   ‚îÇ Proper scoping    ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ                  ‚îÇ   ‚îÇ                   ‚îÇ
‚îÇ Solutions:    ‚îÇ   ‚îÇ Solutions:       ‚îÇ   ‚îÇ                   ‚îÇ
‚îÇ ‚Ä¢ IIFE        ‚îÇ   ‚îÇ ‚Ä¢ Release refs   ‚îÇ   ‚îÇ                   ‚îÇ
‚îÇ ‚Ä¢ let keyword ‚îÇ   ‚îÇ ‚Ä¢ Weak references‚îÇ   ‚îÇ                   ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Detailed Breakdown:
1. CORE MECHANISM
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   CLOSURE CREATION                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Outer Function     ‚îÇ  ‚îÇ  Inner Function     ‚îÇ  ‚îÇ  Lexical        ‚îÇ
‚îÇ  Execution          ‚îÇ  ‚îÇ  Definition         ‚îÇ  ‚îÇ  Environment    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Creates scope  ‚îÇ   ‚îÇ Captures outer   ‚îÇ   ‚îÇ [[Environment]]  ‚îÇ
‚îÇ with variables ‚îÇ   ‚îÇ variables        ‚îÇ   ‚îÇ property stores  ‚îÇ
‚îÇ                ‚îÇ   ‚îÇ                  ‚îÇ   ‚îÇ reference to     ‚îÇ
‚îÇ let count = 0  ‚îÇ   ‚îÇ return count++   ‚îÇ   ‚îÇ outer scope      ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2. PRACTICAL USE CASES TREE
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   PRACTICAL USE CASES                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Data Privacy  ‚îÇ       ‚îÇ Function      ‚îÇ       ‚îÇ Event         ‚îÇ
‚îÇ & Encapsulation‚îÇ      ‚îÇ Factories     ‚îÇ       ‚îÇ Handlers      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Bank Account  ‚îÇ   ‚îÇ Multipliers     ‚îÇ   ‚îÇ Button clicks   ‚îÇ
‚îÇ Module Pattern‚îÇ   ‚îÇ Greeters        ‚îÇ   ‚îÇ with correct    ‚îÇ
‚îÇ Private vars  ‚îÇ   ‚îÇ Configurable    ‚îÇ   ‚îÇ index capture   ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ functions       ‚îÇ   ‚îÇ                 ‚îÇ
‚îÇ let balance   ‚îÇ   ‚îÇ createMultiplier‚îÇ   ‚îÇ for(let i=0)... ‚îÇ
‚îÇ return {deposit}‚îÇ  ‚îÇ (2) => double  ‚îÇ   ‚îÇ                 ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        ‚îÇ                                    
        ‚îÇ                                    
        ‚ñº                                    
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            
‚îÇ Memoization   ‚îÇ                            
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            
        ‚îÇ                                    
        ‚ñº                                    
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                            
‚îÇ Cache results ‚îÇ                            
‚îÇ const cache={}‚îÇ                            
‚îÇ return cached ‚îÇ                            
‚îÇ or compute    ‚îÇ                            
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                            
3. ADVANCED PATTERNS TREE
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   ADVANCED PATTERNS                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Module        ‚îÇ       ‚îÇ Currying &    ‚îÇ       ‚îÇ React Hooks   ‚îÇ
‚îÇ Pattern       ‚îÇ       ‚îÇ Partial App   ‚îÇ       ‚îÇ Implementation‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ IIFE wrapper  ‚îÇ   ‚îÇ Function that    ‚îÇ   ‚îÇ useState-like    ‚îÇ
‚îÇ Private state ‚îÇ   ‚îÇ returns function ‚îÇ   ‚îÇ closure          ‚îÇ
‚îÇ Public API    ‚îÇ   ‚îÇ curry(fn) =>     ‚îÇ   ‚îÇ let state        ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ function that... ‚îÇ   ‚îÇ return [state,   ‚îÇ
‚îÇ (function(){  ‚îÇ   ‚îÇ partial(fn,args) ‚îÇ   ‚îÇ setState]        ‚îÇ
‚îÇ   let private ‚îÇ   ‚îÇ => function...   ‚îÇ   ‚îÇ                  ‚îÇ
‚îÇ   return {public}‚îÇ ‚îÇ                  ‚îÇ   ‚îÇ                  ‚îÇ
‚îÇ })()          ‚îÇ   ‚îÇ                  ‚îÇ   ‚îÇ                  ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4. COMMON ISSUES & SOLUTIONS TREE
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   COMMON PITFALLS                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Loop Variable ‚îÇ       ‚îÇ Memory Leaks  ‚îÇ       ‚îÇ Performance   ‚îÇ
‚îÇ Issue         ‚îÇ       ‚îÇ               ‚îÇ       ‚îÇ Issues        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº                       ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Problem:      ‚îÇ   ‚îÇ Problem:        ‚îÇ   ‚îÇ Problem:        ‚îÇ
‚îÇ for(var i=0)  ‚îÇ   ‚îÇ Large data      ‚îÇ   ‚îÇ Too many        ‚îÇ
‚îÇ all callbacks ‚îÇ   ‚îÇ persists        ‚îÇ   ‚îÇ closures can    ‚îÇ
‚îÇ see final i   ‚îÇ   ‚îÇ in memory       ‚îÇ   ‚îÇ slow execution  ‚îÇ
‚îÇ               ‚îÇ   ‚îÇ                 ‚îÇ   ‚îÇ                 ‚îÇ
‚îÇ Solutions:    ‚îÇ   ‚îÇ Solutions:      ‚îÇ   ‚îÇ Solutions:      ‚îÇ
‚îÇ ‚Ä¢ let i=0     ‚îÇ   ‚îÇ ‚Ä¢ cleanup()     ‚îÇ   ‚îÇ ‚Ä¢ Avoid overuse ‚îÇ
‚îÇ ‚Ä¢ IIFE(i)     ‚îÇ   ‚îÇ ‚Ä¢ WeakMap       ‚îÇ   ‚îÇ ‚Ä¢ Proper scoping‚îÇ
‚îÇ ‚Ä¢ forEach     ‚îÇ   ‚îÇ ‚Ä¢ null refs     ‚îÇ   ‚îÇ ‚Ä¢ Memoization   ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Key Relationships:
Closure = Function + Lexical Environment

Lexical Environment persists after outer function execution

Use cases branch into practical applications

Advanced patterns enable complex programming paradigms

Pitfalls require specific solutions for each scenario

This tree structure shows how closures are fundamental to many JavaScript patterns and why understanding them is crucial for advanced JavaScript development! üå≥ 
-----------------------------------------------------

Explain the this keyword and its binding rules
The this Keyword in JavaScript - Complete Guide
üéØ What is this?
this is a special keyword that refers to the execution context of a function. Its value is determined by how a function is called, not where it's defined.

üìù The 4 Binding Rules (in order of precedence)
1. New Binding (Highest Priority)
When using new keyword with constructor functions.

javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.introduce = function() {
        console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old`);
    };
}

const person1 = new Person('Alice', 25);
person1.introduce(); // "Hi, I'm Alice and I'm 25 years old"
// 'this' refers to the newly created object (person1)

// What happens with 'new':
// 1. Creates a new empty object {}
// 2. Sets 'this' to point to that object
// 3. Executes the constructor function
// 4. Returns the object (unless constructor returns something else)
2. Explicit Binding
When using call(), apply(), or bind().

javascript
function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };
const person2 = { name: 'Bob' };

// call() - immediately invokes with specified 'this'
greet.call(person, 'Hello', '!'); // "Hello, Alice!"

// apply() - similar to call but takes array of arguments
greet.apply(person2, ['Hi', '!!']); // "Hi, Bob!!"

// bind() - returns new function with bound 'this'
const greetAlice = greet.bind(person, 'Hello');
greetAlice('!'); // "Hello, Alice!" - even if called later

// bind() with partial application
const greetBob = greet.bind(person2);
greetBob('Hey', '!'); // "Hey, Bob!"
3. Implicit Binding
When function is called as a method of an object.

javascript
const user = {
    name: 'Alice',
    age: 25,
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    },
    address: {
        city: 'New York',
        getCity() {
            console.log(`City: ${this.city}`);
        }
    }
};

user.greet(); // "Hello, I'm Alice" - 'this' refers to 'user'
user.address.getCity(); // "City: New York" - 'this' refers to 'address'

// Lost implicit binding
const greetFunc = user.greet;
greetFunc(); // "Hello, I'm undefined" - 'this' is lost!
4. Default Binding (Lowest Priority)
When no other rules apply - falls back to global object (or undefined in strict mode).

javascript
// Non-strict mode
function showThis() {
    console.log(this);
}

showThis(); // Window (browser) or Global (Node.js) - global object

// Strict mode
function showThisStrict() {
    'use strict';
    console.log(this);
}

showThisStrict(); // undefined
üîÑ this in Different Contexts
Arrow Functions
Arrow functions don't have their own this - they inherit this from the enclosing lexical scope.

javascript
const obj = {
    name: 'Alice',
    regularFunction: function() {
        console.log('Regular:', this.name); // "Regular: Alice"
        
        setTimeout(function() {
            console.log('Timeout regular:', this.name); // "Timeout regular: undefined"
        }, 100);
    },
    arrowFunction: function() {
        console.log('Arrow outer:', this.name); // "Arrow outer: Alice"
        
        setTimeout(() => {
            console.log('Timeout arrow:', this.name); // "Timeout arrow: Alice"
        }, 100);
    }
};

obj.regularFunction();
obj.arrowFunction();

// More arrow function examples
const globalObject = {
    value: 'global',
    createFunctions: function() {
        return {
            regular: function() {
                console.log(this.value); // undefined - new 'this'
            },
            arrow: () => {
                console.log(this.value); // 'global' - inherits from createFunctions
            }
        };
    }
};

globalObject.createFunctions().regular(); // undefined
globalObject.createFunctions().arrow();   // 'global'
Event Handlers
javascript
const button = document.createElement('button');
button.textContent = 'Click me';

// In regular functions, 'this' refers to the element
button.addEventListener('click', function() {
    console.log(this); // <button> element
    console.log(this.textContent); // "Click me"
});

// In arrow functions, 'this' refers to enclosing scope
button.addEventListener('click', () => {
    console.log(this); // Window (or enclosing scope)
    // console.log(this.textContent); // undefined or error
});

document.body.appendChild(button);
Class Methods
javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    
    // Class methods are automatically bound to the instance
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }
    
    // Arrow function in class - bound to instance
    greetArrow = () => {
        console.log(`Hello from arrow, I'm ${this.name}`);
    }
}

const person = new Person('Alice');
person.greet(); // "Hello, I'm Alice"

const greet = person.greet;
// greet(); // Error in strict mode - 'this' is undefined

const greetArrow = person.greetArrow;
greetArrow(); // "Hello from arrow, I'm Alice" - works!
üé≠ Common this Pitfalls & Solutions
1. Method Losing Context
javascript
const obj = {
    name: 'Alice',
    greet: function() {
        console.log(`Hello, ${this.name}`);
    }
};

// ‚ùå Problem: Lost context
const greetFunc = obj.greet;
greetFunc(); // "Hello, undefined"

// ‚úÖ Solution 1: Bind the method
const boundGreet = obj.greet.bind(obj);
boundGreet(); // "Hello, Alice"

// ‚úÖ Solution 2: Use arrow function in object method definition
const obj2 = {
    name: 'Alice',
    greet: () => {
        console.log(`Hello, ${this.name}`); // Still problematic!
    }
};

// ‚úÖ Solution 3: Proper object method pattern
const obj3 = {
    name: 'Alice',
    greet() {
        console.log(`Hello, ${this.name}`);
    }
};
2. Callback Functions
javascript
const user = {
    name: 'Alice',
    hobbies: ['reading', 'gaming'],
    showHobbies: function() {
        // ‚ùå Problem: 'this' is lost in forEach callback
        this.hobbies.forEach(function(hobby) {
            console.log(`${this.name} likes ${hobby}`); // 'this' is undefined
        });
    }
};

// ‚úÖ Solution 1: Use arrow function
showHobbiesFixed: function() {
    this.hobbies.forEach((hobby) => {
        console.log(`${this.name} likes ${hobby}`); // Works!
    });
}

// ‚úÖ Solution 2: Bind 'this'
showHobbiesBound: function() {
    this.hobbies.forEach(function(hobby) {
        console.log(`${this.name} likes ${hobby}`);
    }.bind(this));
}

// ‚úÖ Solution 3: Store 'this' in variable
showHobbiesVariable: function() {
    const self = this;
    this.hobbies.forEach(function(hobby) {
        console.log(`${self.name} likes ${hobby}`);
    });
}

// ‚úÖ Solution 4: Use second parameter of forEach
showHobbiesThisArg: function() {
    this.hobbies.forEach(function(hobby) {
        console.log(`${this.name} likes ${hobby}`);
    }, this); // 'this' as second parameter
}
3. Constructor Functions Without new
javascript
function Car(make, model) {
    this.make = make;
    this.model = model;
}

// ‚ùå Problem: Forgot 'new' - 'this' refers to global object
const car1 = Car('Toyota', 'Camry');
console.log(car1); // undefined
console.log(make); // 'Toyota' (polluted global scope!)

// ‚úÖ Solution 1: Always use 'new'
const car2 = new Car('Honda', 'Civic');

// ‚úÖ Solution 2: Safety check in constructor
function SafeCar(make, model) {
    if (!(this instanceof SafeCar)) {
        return new SafeCar(make, model);
    }
    this.make = make;
    this.model = model;
}

const car3 = SafeCar('Ford', 'Focus'); // Works without 'new'
const car4 = new SafeCar('BMW', 'X5'); // Also works
üîß Advanced this Patterns
Partial Application with bind
javascript
function multiply(a, b, c) {
    return a * b * c;
}

// Bind first argument
const multiplyByTwo = multiply.bind(null, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

// Bind multiple arguments
const multiplyByTwoAndThree = multiply.bind(null, 2, 3);
console.log(multiplyByTwoAndThree(4)); // 24 (2 * 3 * 4)
Method Borrowing
javascript
const person1 = {
    name: 'Alice',
    greet: function(greeting) {
        return `${greeting}, I'm ${this.name}`;
    }
};

const person2 = {
    name: 'Bob'
};

// Borrow person1's greet method for person2
console.log(person1.greet.call(person2, 'Hello')); // "Hello, I'm Bob"
console.log(person1.greet.apply(person2, ['Hi'])); // "Hi, I'm Bob"

const borrowedGreet = person1.greet.bind(person2, 'Hey');
console.log(borrowedGreet()); // "Hey, I'm Bob"
this in DOM Event Handlers
javascript
class ButtonComponent {
    constructor() {
        this.count = 0;
        this.button = document.createElement('button');
        this.button.textContent = 'Click me';
        
        // ‚ùå Problem: 'this' is lost
        // this.button.addEventListener('click', this.handleClick);
        
        // ‚úÖ Solution 1: Bind in constructor
        this.button.addEventListener('click', this.handleClick.bind(this));
        
        // ‚úÖ Solution 2: Use arrow function
        this.button.addEventListener('click', () => this.handleClick());
        
        // ‚úÖ Solution 3: Class field with arrow function
        // handleClick = () => { ... }
    }
    
    handleClick() {
        this.count++;
        console.log(`Clicked ${this.count} times`);
        this.button.textContent = `Clicked ${this.count} times`;
    }
}
üìä this Binding Rules Summary Table
Rule	Example	What this refers to	Priority
New Binding	new Person()	Newly created object	1st
Explicit Binding	fn.call(obj)	First argument of call/apply/bind	2nd
Implicit Binding	obj.method()	Object before dot	3rd
Default Binding	fn()	Global object (or undefined)	4th
üéØ Interview Ready Summary
"The this keyword in JavaScript refers to the execution context of a function and is determined by how the function is called, not where it's defined. There are four binding rules in order of precedence:

New Binding - when using new keyword

Explicit Binding - when using call(), apply(), or bind()

Implicit Binding - when called as object method

Default Binding - falls back to global/undefined

Arrow functions don't have their own this - they inherit from their lexical scope. Common pitfalls include losing context in callbacks and event handlers, which can be solved using bind(), arrow functions, or storing this in a variable."

üí° Quick Reference
javascript
// Determine 'this' in any situation:
function checkThis() {
    console.log(this);
}

// 1. New binding
new checkThis(); // {} (new object)

// 2. Explicit binding
checkThis.call({name: 'Alice'}); // {name: 'Alice'}

// 3. Implicit binding
const obj = { method: checkThis };
obj.method(); // obj

// 4. Default binding
checkThis(); // Window/Global/undefined
Mastering this is crucial for understanding JavaScript's object-oriented patterns and avoiding common bugs! üöÄ

----------------------------------------------------------------------------------------------------------


How does JavaScript's prototypal inheritance work?
99. What are primitive and reference types in JavaScript?
100. Explain the concept of truthy and falsy values
I'll answer all four questions comprehensively:

98. How JavaScript's Prototypal Inheritance Works
üéØ Core Concept
JavaScript uses prototype-based inheritance instead of classical inheritance. Objects inherit directly from other objects.

üîó The Prototype Chain
javascript
// Every object has a hidden [[Prototype]] property
const parent = {
    type: 'animal',
    breathe() {
        console.log('Breathing...');
    }
};

const child = {
    name: 'Leo'
};

// Set up inheritance (modern way)
Object.setPrototypeOf(child, parent);

// Old way (not recommended): child.__proto__ = parent;

console.log(child.name);     // "Leo" - own property
console.log(child.type);     // "animal" - inherited
child.breathe();            // "Breathing..." - inherited method

// Check prototype
console.log(Object.getPrototypeOf(child) === parent); // true
üèóÔ∏è Constructor Functions & Prototypes
javascript
function Animal(name) {
    this.name = name;
}

// Add methods to prototype
Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

Animal.prototype.eat = function() {
    console.log(`${this.name} is eating`);
};

// Create instances
const dog = new Animal('Rex');
const cat = new Animal('Whiskers');

dog.speak(); // "Rex makes a sound"
cat.speak(); // "Whiskers makes a sound"

// Prototype chain:
// dog -> Animal.prototype -> Object.prototype -> null
console.log(dog.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null
üìö ES6 Classes (Syntactic Sugar)
javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
    
    eat() {
        console.log(`${this.name} is eating`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call parent constructor
        this.breed = breed;
    }
    
    speak() {
        console.log(`${this.name} barks!`);
    }
    
    fetch() {
        console.log(`${this.name} fetches the ball`);
    }
}

const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.speak(); // "Buddy barks!" (overridden)
myDog.eat();   // "Buddy is eating" (inherited)

// Prototype chain:
// myDog -> Dog.prototype -> Animal.prototype -> Object.prototype -> null
üîß Prototype Methods & Properties
javascript
function Person(name) {
    this.name = name;
}

Person.prototype.species = 'Homo sapiens';
Person.prototype.introduce = function() {
    console.log(`Hi, I'm ${this.name}`);
};

const john = new Person('John');
const jane = new Person('Jane');

console.log(john.species); // "Homo sapiens" (shared)
console.log(jane.species); // "Homo sapiens" (shared)

// hasOwnProperty - checks if property exists on object itself
console.log(john.hasOwnProperty('name'));     // true
console.log(john.hasOwnProperty('species'));  // false
console.log(john.hasOwnProperty('introduce')); // false

// in operator - checks entire prototype chain
console.log('name' in john);     // true
console.log('species' in john);  // true
console.log('introduce' in john); // true
99. Primitive vs Reference Types in JavaScript
üìä Primitive Types (7 types)
Stored by VALUE - copied when assigned/passed

javascript
// String, Number, Boolean, Undefined, Null, Symbol, BigInt

let a = 10;
let b = a; // Copy the value
b = 20;

console.log(a); // 10 (unchanged)
console.log(b); // 20

// Examples of primitives
const str = "hello";          // String
const num = 42;               // Number
const bool = true;            // Boolean
const undef = undefined;      // Undefined
const empty = null;           // Null
const sym = Symbol('unique'); // Symbol
const big = 9007199254740991n; // BigInt
üè¢ Reference Types (Objects)
Stored by REFERENCE - point to same memory location

javascript
// Objects, Arrays, Functions, Dates, etc.

let obj1 = { name: 'Alice' };
let obj2 = obj1; // Copy the reference (both point to same object)

obj2.name = 'Bob';

console.log(obj1.name); // "Bob" (changed!)
console.log(obj2.name); // "Bob"

// More examples
const array1 = [1, 2, 3];
const array2 = array1;
array2.push(4);

console.log(array1); // [1, 2, 3, 4] (changed!)
console.log(array2); // [1, 2, 3, 4]

const func1 = function() { return 'hello'; };
const func2 = func1;
console.log(func1 === func2); // true (same reference)
üîÑ Comparison Behavior
javascript
// Primitives - compared by VALUE
console.log(5 === 5);           // true
console.log('hello' === 'hello'); // true
console.log(true === true);     // true

// References - compared by REFERENCE (memory location)
console.log({} === {});         // false (different objects)
console.log([] === []);         // false (different arrays)

const objA = { x: 1 };
const objB = { x: 1 };
const objC = objA;

console.log(objA === objB); // false (different references)
console.log(objA === objC); // true (same reference)
üõ†Ô∏è Working with References
javascript
// Shallow copy objects
const original = { a: 1, b: { c: 2 } };

// Spread operator (shallow copy)
const copy1 = { ...original };
copy1.a = 10;
console.log(original.a); // 1 (unchanged)
console.log(copy1.a);    // 10

// But nested objects still share reference!
copy1.b.c = 20;
console.log(original.b.c); // 20 (changed!) - shallow copy issue

// Deep copy solutions
const deepCopy1 = JSON.parse(JSON.stringify(original));
const deepCopy2 = structuredClone(original); // Modern browsers
100. Truthy and Falsy Values
üìù Falsy Values (6 values that evaluate to false)
javascript
// All these evaluate to false in boolean context
if (false) {}
if (null) {}
if (undefined) {}
if (0) {}
if (-0) {}
if (0n) {}        // BigInt zero
if (NaN) {}
if ("") {}        // Empty string

// Verification
console.log(Boolean(false));     // false
console.log(Boolean(null));      // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0));         // false
console.log(Boolean(-0));        // false
console.log(Boolean(0n));        // false
console.log(Boolean(NaN));       // false
console.log(Boolean(""));        // false

-------------------------------------------------------------------------------------------------------------

‚úÖ Truthy Values (Everything else)
javascript
// All these evaluate to true in boolean context
if (true) {}
if ({}) {}           // Empty object
if ([]) {}           // Empty array
if (42) {}           // Non-zero number
if ("0") {}          // Non-empty string
if ("false") {}      // Non-empty string
if (new Date()) {}   // Date object
if (-42) {}          // Negative number
if (12n) {}          // BigInt
if (3.14) {}         // Float
if (-3.14) {}        // Negative float
if (Infinity) {}     // Infinity
if (-Infinity) {}    // Negative Infinity

// Verification
console.log(Boolean(true));        // true
console.log(Boolean({}));          // true
console.log(Boolean([]));          // true
console.log(Boolean(42));          // true
console.log(Boolean("0"));         // true
console.log(Boolean("false"));     // true
console.log(Boolean(new Date()));  // true
üéØ Practical Usage Patterns
javascript
// 1. Default values with logical OR
const username = userInput || "Anonymous";
const count = userCount || 0;

// 2. Optional chaining with nullish coalescing
const name = user?.profile?.name ?? "Unknown";

// 3. Conditional rendering
const message = hasError && "Error occurred";
const greeting = isLoggedIn && `Welcome, ${username}!`;

// 4. Input validation
function processInput(input) {
    if (!input) {
        return "No input provided";
    }
    return `Processing: ${input}`;
}

console.log(processInput(""));     // "No input provided"
console.log(processInput("hello")); // "Processing: hello"

// 5. Array filtering
const mixedArray = [0, 1, false, 2, '', 3, null, undefined, 4, NaN];
const truthyArray = mixedArray.filter(Boolean);
console.log(truthyArray); // [1, 2, 3, 4]
‚ö†Ô∏è Common Gotchas & Surprises
javascript
// Surprising truthy values
console.log(Boolean('0'));      // true (non-empty string)
console.log(Boolean(' '));      // true (space is non-empty)
console.log(Boolean([]));       // true (empty array)
console.log(Boolean({}));       // true (empty object)
console.log(Boolean(function() {})); // true (function)

// Surprising falsy values
console.log(Boolean(0));        // false
console.log(Boolean(-0));       // false
console.log(Boolean(0n));       // false (BigInt zero)
console.log(Boolean(''));       // false

// Comparison quirks
console.log(false == 0);        // true (type coercion)
console.log(false === 0);       // false (strict equality)
console.log('' == 0);           // true
console.log('' === 0);          // false
console.log(null == undefined); // true
console.log(null === undefined); // false
üõ†Ô∏è Real-World Examples
javascript
// Form validation
function validateForm(formData) {
    if (!formData.username?.trim()) {
        return "Username is required";
    }
    
    if (!formData.email?.includes('@')) {
        return "Valid email is required";
    }
    
    if (!formData.age || formData.age < 18) {
        return "Must be 18 or older";
    }
    
    return "Form valid!";
}

// API response handling
async function fetchUserData(userId) {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();
    
    // Check if data exists and has required properties
    if (!data?.user?.profile) {
        throw new Error("Invalid user data received");
    }
    
    return data.user;
}

// Component rendering logic (React-like)
function UserProfile({ user }) {
    if (!user) {
        return <div>Loading...</div>;
    }
    
    return (
        <div>
            <h1>{user.name || 'Anonymous User'}</h1>
            {user.bio && <p>{user.bio}</p>}
            {user.isAdmin && <AdminPanel />}
        </div>
    );
}
üéØ Interview Ready Summary
Prototypal Inheritance:
"JavaScript uses prototype-based inheritance where objects inherit directly from other objects. Every object has a hidden [[Prototype]] property pointing to another object. When accessing a property, JavaScript looks up the prototype chain until it finds the property or reaches null."

Primitive vs Reference:
"Primitives (string, number, boolean, etc.) are stored by value and copied when assigned. Reference types (objects, arrays) are stored by reference, and variables point to the same memory location. This affects comparison behavior and mutation."

Truthy/Falsy:
"JavaScript has 6 falsy values: false, 0, "", null, undefined, and NaN. Everything else is truthy. This is used extensively for conditional logic, default values, and input validation."

----------------------------------------------------------------------------------------------------------------------------


101. What are the main features introduced in ES6?
102. Explain arrow functions and their differences from regular functions
103. What are template literals and their advantages?
ES6+ Features Deep Dive
101. Main Features Introduced in ES6
üéØ ES6 (ECMAScript 2015) - The Big Update
javascript
// ES5 (Old Way)
var name = "John";
var age = 30;
var message = "Hello " + name + ", you are " + age + " years old";

function multiply(a, b) {
    return a * b;
}

// ES6 (New Way) - All these features introduced!
const name = "John";
let age = 30;
const message = `Hello ${name}, you are ${age} years old`;

const multiply = (a, b) => a * b;
üìã Complete ES6 Feature List:
1. Variable Declarations
javascript
// let & const - block scoping
let counter = 0;        // Can be reassigned
const PI = 3.14159;     // Cannot be reassigned

{
    let blockScoped = "I exist only here";
    const alsoBlockScoped = "Me too";
}
// console.log(blockScoped); // ReferenceError
2. Arrow Functions
javascript
// Concise syntax
const add = (a, b) => a + b;

// Implicit return
const square = x => x * x;

// No 'this' binding (major difference)
const obj = {
    value: 10,
    traditional: function() {
        console.log(this.value); // 10
    },
    arrow: () => {
        console.log(this.value); // undefined (lexical this)
    }
};
3. Template Literals
javascript
// String interpolation
const name = "Alice";
const age = 25;
console.log(`Hello ${name}, you are ${age} years old!`);

// Multi-line strings
const html = `
    <div class="user">
        <h1>${name}</h1>
        <p>Age: ${age}</p>
    </div>
`;

// Expressions
console.log(`Next year you'll be ${age + 1}`);
4. Destructuring
javascript
// Array destructuring
const numbers = [1, 2, 3];
const [first, second, third] = numbers;
console.log(first, second); // 1, 2

// Object destructuring
const user = { name: "John", age: 30, city: "NYC" };
const { name, age, country = "USA" } = user;
console.log(name, country); // John, USA

// Function parameter destructuring
function greet({ name, age }) {
    return `Hello ${name}, age ${age}`;
}
5. Default Parameters
javascript
function createUser(name, age = 18, isActive = true) {
    return { name, age, isActive };
}

console.log(createUser("John"));        // {name: "John", age: 18, isActive: true}
console.log(createUser("Jane", 25));    // {name: "Jane", age: 25, isActive: true}
6. Spread & Rest Operators
javascript
// Spread (...)
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 }; // {a: 1, b: 2, c: 3}

// Rest (...)
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3, 4)); // 10
7. Enhanced Object Literals
javascript
const name = "John";
const age = 30;

// Shorthand property names
const user = { name, age }; // {name: "John", age: 30}

// Method shorthand
const calculator = {
    add(a, b) {    // Instead of add: function(a, b)
        return a + b;
    },
    multiply(a, b) {
        return a * b;
    }
};

// Computed property names
const key = "userStatus";
const obj = {
    [key]: "active",
    [`get${key}`]() {
        return this[key];
    }
};
8. Promises
javascript
const fetchData = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            Math.random() > 0.5 
                ? resolve("Data received!") 
                : reject("Error occurred!");
        }, 1000);
    });
};

fetchData()
    .then(data => console.log(data))
    .catch(error => console.error(error));
9. Classes
javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Method
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // Static method
    static species = "Homo sapiens";
}

class Student extends Person {
    constructor(name, age, grade) {
        super(name, age);
        this.grade = grade;
    }
    
    study() {
        return `${this.name} is studying`;
    }
}
10. Modules
javascript
// math.js
export const PI = 3.14159;
export function add(a, b) { return a + b; }
export default function multiply(a, b) { return a * b; }

// app.js
import multiply, { PI, add } from './math.js';
console.log(multiply(2, 3)); // 6
11. New Built-in Methods
javascript
// String methods
"hello".startsWith("he");    // true
"hello".endsWith("lo");      // true
"hello".includes("ell");     // true
"hello".repeat(3);           // "hellohellohello"

// Array methods
[1, 2, 3].find(x => x > 1);     // 2
[1, 2, 3].findIndex(x => x > 1); // 1
[1, 2, 3].fill(0);              // [0, 0, 0]

// Object methods
Object.assign({}, {a: 1}, {b: 2}); // {a: 1, b: 2}
Object.is(NaN, NaN);               // true (unlike ===)
102. Arrow Functions vs Regular Functions
üéØ Complete Comparison
javascript
// REGULAR FUNCTION
function add(a, b) {
    return a + b;
}

// ARROW FUNCTION
const add = (a, b) => a + b;
üìä Key Differences Table
Feature	Regular Function	Arrow Function
this binding	Dynamic (call-site)	Lexical (enclosing scope)
arguments object	‚úÖ Available	‚ùå Not available
Constructor	‚úÖ Can use new	‚ùå Cannot use new
Method definition	‚úÖ Good for methods	‚ùå Poor for methods
Hoisting	‚úÖ Fully hoisted	‚ùå Not hoisted
üîç Detailed Examples
1. this Binding (MAJOR DIFFERENCE)
javascript
const obj = {
    name: "John",
    
    // Regular function - 'this' refers to obj
    regularFunc: function() {
        console.log("Regular:", this.name); // "John"
        
        setTimeout(function() {
            console.log("Timeout regular:", this.name); // undefined (global)
        }, 100);
    },
    
    // Arrow function - 'this' refers to lexical scope (obj)
    arrowFunc: function() {
        console.log("Arrow outer:", this.name); // "John"
        
        setTimeout(() => {
            console.log("Timeout arrow:", this.name); // "John" (lexical)
        }, 100);
    },
    
    // ‚ùå Bad: Arrow function as method
    badArrow: () => {
        console.log("Bad arrow:", this.name); // undefined (lexical = global)
    }
};

obj.regularFunc();
obj.arrowFunc();
obj.badArrow();
2. arguments Object
javascript
function regular() {
    console.log(arguments); // [1, 2, 3]
}

const arrow = () => {
    // console.log(arguments); // ReferenceError: arguments is not defined
};

regular(1, 2, 3);
arrow(1, 2, 3);

// ‚úÖ Arrow function alternative: use rest parameters
const arrowWithRest = (...args) => {
    console.log(args); // [1, 2, 3]
};
3. Constructor Usage
javascript
function Person(name) {
    this.name = name;
}
const john = new Person("John"); // ‚úÖ Works

const ArrowPerson = (name) => {
    this.name = name;
};
// const jane = new ArrowPerson("Jane"); // ‚ùå TypeError: ArrowPerson is not a constructor
4. Method Definitions
javascript
class Calculator {
    constructor() {
        this.value = 0;
    }
    
    // ‚úÖ Good: Regular function for methods
    addRegular(num) {
        this.value += num;
        return this;
    }
    
    // ‚ùå Bad: Arrow function loses 'this' context
    addArrow = (num) => {
        this.value += num; // 'this' refers to instance (due to class fields)
        return this;
    }
}

const calc = new Calculator();
calc.addRegular(5).addRegular(3);
console.log(calc.value); // 8
5. Event Handlers
javascript
class Button {
    constructor() {
        this.clicked = false;
        this.button = document.createElement('button');
        
        // ‚ùå Problem: 'this' refers to button element
        this.button.addEventListener('click', function() {
            this.clicked = true; // ‚ùå Wrong 'this'
        });
        
        // ‚úÖ Solution 1: Arrow function
        this.button.addEventListener('click', () => {
            this.clicked = true; // ‚úÖ Correct 'this'
        });
        
        // ‚úÖ Solution 2: Bind
        this.button.addEventListener('click', function() {
            this.clicked = true;
        }.bind(this));
    }
}
üéØ When to Use Each
Use Arrow Functions For:
javascript
// 1. Callbacks
[1, 2, 3].map(x => x * 2);

// 2. Short, simple functions
const double = x => x * 2;

// 3. When you need lexical 'this'
class Component {
    constructor() {
        this.value = 0;
        setTimeout(() => {
            this.value++; // 'this' refers to Component instance
        }, 1000);
    }
}

// 4. Functional programming
const users = users.filter(user => user.isActive);
Use Regular Functions For:
javascript
// 1. Object methods
const obj = {
    value: 0,
    increment: function() {
        this.value++;
    }
};

// 2. Constructor functions
function User(name) {
    this.name = name;
}

// 3. When you need 'arguments'
function sum() {
    return Array.from(arguments).reduce((a, b) => a + b);
}

// 4. Generator functions
function* generator() {
    yield 1;
    yield 2;
}
103. Template Literals & Advantages
üéØ What are Template Literals?
Template literals are string literals allowing embedded expressions, denoted by backticks (`) instead of quotes.

üìù Basic Syntax
javascript
// OLD WAY - String concatenation
const name = "John";
const age = 30;
const message = "Hello " + name + ", you are " + age + " years old";

// NEW WAY - Template literals
const message = `Hello ${name}, you are ${age} years old`;
üöÄ Key Advantages & Features
1. String Interpolation
javascript
const product = "iPhone";
const price = 999;
const rating = 4.5;

console.log(`The ${product} costs $${price} and has ${rating} stars`);
// "The iPhone costs $999 and has 4.5 stars"
2. Multi-line Strings
javascript
// OLD WAY - Messy
const html = "<div>\n" +
             "  <h1>Title</h1>\n" +
             "  <p>Content</p>\n" +
             "</div>";

// NEW WAY - Clean
const html = `
    <div>
        <h1>Title</h1>
        <p>Content</p>
    </div>
`;
3. Expression Evaluation
javascript
const a = 5;
const b = 10;

console.log(`The sum is ${a + b}`); // "The sum is 15"
console.log(`Is a greater? ${a > b ? 'Yes' : 'No'}`); // "Is a greater? No"

// Complex expressions
const user = { name: "Alice", age: 25 };
console.log(`Next year: ${user.age + 1}`); // "Next year: 26"
4. Function Calls in Templates
javascript
function formatCurrency(amount) {
    return `$${amount.toFixed(2)}`;
}

const price = 19.99;
console.log(`Total: ${formatCurrency(price)}`); // "Total: $19.99"
5. Nested Template Literals
javascript
const isMember = true;
const discount = 0.1;
const price = 100;

console.log(`Price: $${price} ${isMember ? `(Member discount: $${price * discount})` : ''}`);
// "Price: $100 (Member discount: $10)"
üî• Advanced Features
1. Tagged Templates
javascript
// Custom template processor
function highlight(strings, ...values) {
    return strings.reduce((result, string, i) => {
        const value = values[i] ? `<mark>${values[i]}</mark>` : '';
        return result + string + value;
    }, '');
}

const name = "John";
const age = 30;

const message = highlight`Hello ${name}, you are ${age} years old`;
console.log(message); 
// "Hello <mark>John</mark>, you are <mark>30</mark> years old"
2. SQL Query Building
javascript
function sql(strings, ...values) {
    return {
        query: strings.join('?'),
        params: values
    };
}

const userId = 123;
const status = 'active';

const { query, params } = sql`
    SELECT * FROM users 
    WHERE id = ${userId} 
    AND status = ${status}
`;

console.log(query); // "SELECT * FROM users WHERE id = ? AND status = ?"
console.log(params); // [123, 'active']
3. Localization (i18n)
javascript
function localize(strings, ...values) {
    const translations = {
        "Hello": "Hola",
        "years old": "a√±os"
    };
    
    return strings.map((str, i) => 
        translations[str.trim()] || str + (values[i] || '')
    ).join('');
}

const name = "John";
const age = 30;

console.log(localize`Hello ${name}, you are ${age} years old`);
// "Hola John, you are 30 a√±os"
4. CSS-in-JS Styling
javascript
function css(strings, ...values) {
    const style = strings.reduce((result, string, i) => {
        return result + string + (values[i] || '');
    }, '');
    
    return { __css: style };
}

const color = "red";
const size = "16px";

const buttonStyle = css`
    color: ${color};
    font-size: ${size};
    padding: 10px;
`;

console.log(buttonStyle);
// { __css: "color: red; font-size: 16px; padding: 10px;" }
üìä Performance Considerations
javascript
// Template literals are generally fast, but...

// ‚ùå Avoid in hot loops
for (let i = 0; i < 1000000; i++) {
    const msg = `Value: ${i}`; // Creates new string each iteration
}

// ‚úÖ Better for hot loops
let result = '';
for (let i = 0; i < 1000000; i++) {
    result += `Value: ${i}\n`; // More efficient
}
üéØ When to Use Template Literals
‚úÖ Perfect For:
Dynamic strings with variables

Multi-line content (HTML, SQL, etc.)

Readable string building

Internationalization

Styled components

‚ùå Stick with Regular Strings For:
Simple, static strings

Performance-critical loops

When backticks would need escaping

üí° Pro Tips
javascript
// 1. Escaping backticks
const message = `This is a backtick: \` and this is a dollar: \${}`;

// 2. Raw strings
console.log(String.raw`Hello\nWorld`); // "Hello\\nWorld" (literal \n)

// 3. Nested templates for complex logic
const condition = true;
const value = 42;
console.log(`Result: ${
    condition 
        ? `The value is ${value}` 
        : `No value available`
}`);

// 4. Template literals with array methods
const users = [{ name: "John", age: 30 }, { name: "Jane", age: 25 }];
const userList = users.map(user => `- ${user.name} (${user.age})`).join('\n');
Template literals make string manipulation in JavaScript much more readable and maintainable! üöÄ