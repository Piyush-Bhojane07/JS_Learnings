JavaScript Fundamentals 

What is the difference between == and ===? 


== (Loose Equality)
Compares values after type conversion

Converts both values to a common type before comparing

Also called "type coercion"

=== (Strict Equality)
Compares both value AND type

No type conversion - both must be exactly the same

Examples:
javascript
// == (Loose Equality) - with type coercion
console.log(5 == "5");        // true (string "5" converted to number 5)
console.log(1 == true);       // true (true converted to number 1)
console.log(0 == false);      // true (false converted to number 0)
console.log(null == undefined); // true
console.log("" == false);     // true

// === (Strict Equality) - no type coercion
console.log(5 === "5");       // false (number vs string)
console.log(1 === true);      // false (number vs boolean)
console.log(0 === false);     // false (number vs boolean)
console.log(null === undefined); // false
console.log("" === false);    // false
Best Practice:
Always use === (strict equality) unless you have a specific reason to use ==. It's more predictable and prevents unexpected type coercion bugs.

javascript
// Good practice
if (age === "25") {
  // This will only execute if age is exactly string "25"
}

// Potentially problematic
if (age == "25") {
  // This executes for number 25 OR string "25"
}-----------------------------------------------------


Explain JavaScript's event loop and call stack

JavaScript's Event Loop & Call Stack
1. Call Stack
What it is: A data structure that tracks function execution (LIFO - Last In, First Out)

How it works: When a function is called, it's pushed to the stack. When it returns, it's popped off.

javascript
function first() {
    console.log('First');
    second();
}

function second() {
    console.log('Second');
    third();
}

function third() {
    console.log('Third');
}

first();

// Call Stack flow:
// 1. first() enters stack
// 2. console.log('First') enters stack ‚Üí executes ‚Üí leaves stack
// 3. second() enters stack
// 4. console.log('Second') enters stack ‚Üí executes ‚Üí leaves stack
// 5. third() enters stack
// 6. console.log('Third') enters stack ‚Üí executes ‚Üí leaves stack
// 7. All functions leave stack in reverse order
2. Event Loop
Purpose: Monitors Call Stack and Callback Queue

How it works: When Call Stack is empty, it moves callbacks from Queue to Stack

The Complete Picture:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise callback');
});

console.log('End');

// Output order:
// "Start"
// "End" 
// "Promise callback"  (Microtask queue - higher priority)
// "Timeout callback"  (Macrotask queue - lower priority)
Key Components:
1. Call Stack
Synchronous function execution

One thing at a time

2. Web APIs (Browser Environment)
setTimeout, setInterval, DOM events, HTTP requests

Handle asynchronous operations outside JS engine

3. Callback Queues
Microtask Queue: Promises, MutationObserver (higher priority)

Macrotask Queue: setTimeout, setInterval, I/O operations (lower priority)

Visual Flow:
text
Call Stack ‚Üí Web APIs ‚Üí Callback Queues ‚Üí Event Loop ‚Üí Back to Call Stack
Detailed Example:
javascript
console.log('Script start'); // 1

setTimeout(function() {
    console.log('setTimeout'); // 4
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 3.1
});

console.log('Script end'); // 2

// Execution order:
// 1. "Script start"
// 2. "Script end"
// 3. "Promise 1", "Promise 2" (Microtasks)
// 4. "setTimeout" (Macrotask)
Key Takeaways:
JavaScript is single-threaded but can handle async operations

Call Stack handles synchronous code

Event Loop enables non-blocking behavior

Microtasks have higher priority than Macrotasks

Never block the call stack - it freezes the UI
This architecture allows JavaScript to handle concurrent operations while remaining single-threaded!

------------------------------------------------

What is the difference between let, const, and var?

var, let, and const - Complete Guide
üéØ Quick Summary
var: Function-scoped, hoisted, can be redeclared and reassigned

let: Block-scoped, hoisted but in TDZ, can be reassigned but not redeclared

const: Block-scoped, hoisted but in TDZ, cannot be reassigned or redeclared

üìù Detailed Breakdown
1. var (Legacy - Avoid in Modern Code)
javascript
// ‚úÖ Function-scoped
function varExample() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10 - accessible outside the block
}

// ‚úÖ Hoisted with undefined
console.log(a); // undefined (not ReferenceError)
var a = 5;

// ‚úÖ Can be redeclared
var b = 1;
var b = 2; // No error

// ‚úÖ Can be reassigned
var c = 10;
c = 20; // Allowed
2. let (Modern - Use when reassignment needed)
javascript
// ‚úÖ Block-scoped
function letExample() {
    if (true) {
        let y = 20;
        console.log(y); // 20
    }
    // console.log(y); // ReferenceError: y is not defined
}

// ‚ùå Hoisted but in Temporal Dead Zone (TDZ)
// console.log(d); // ReferenceError: Cannot access 'd' before initialization
let d = 5;

// ‚ùå Cannot be redeclared in same scope
let e = 1;
// let e = 2; // SyntaxError: Identifier 'e' has already been declared

// ‚úÖ Can be reassigned
let f = 10;
f = 20; // Allowed

// ‚úÖ Can be redeclared in different blocks
if (true) {
    let g = 1;
}
if (true) {
    let g = 2; // Allowed - different block scope
}
3. const (Modern - Use by default)
javascript
// ‚úÖ Block-scoped
function constExample() {
    if (true) {
        const z = 30;
        console.log(z); // 30
    }
    // console.log(z); // ReferenceError: z is not defined
}

// ‚ùå Must be initialized during declaration
// const h; // SyntaxError: Missing initializer in const declaration
const h = 10;

// ‚ùå Cannot be reassigned
const i = 10;
// i = 20; // TypeError: Assignment to constant variable

// ‚ùå Cannot be redeclared
const j = 1;
// const j = 2; // SyntaxError: Identifier 'j' has already been declared

// ‚úÖ But object properties can be modified!
const person = {
    name: "John",
    age: 30
};
person.age = 31; // ‚úÖ Allowed
person.city = "NYC"; // ‚úÖ Allowed

// ‚úÖ Same for arrays
const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ Allowed
numbers[0] = 10; // ‚úÖ Allowed
üîç Deep Dive Examples
Temporal Dead Zone (TDZ)
javascript
// var - hoisted and initialized with undefined
console.log(varVariable); // undefined
var varVariable = "hello";

// let/const - hoisted but NOT initialized (TDZ)
// console.log(letVariable); // ReferenceError: Cannot access 'letVariable' before initialization
let letVariable = "world";

// console.log(constVariable); // ReferenceError: Cannot access 'constVariable' before initialization
const constVariable = "!";
Loop Behavior
javascript
// var in loops - problematic
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100); // 3, 3, 3
}

// let in loops - works as expected
for (let j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100); // 0, 1, 2
}

// const in loops - each iteration gets new binding
for (const k of [1, 2, 3]) {
    console.log(k); // 1, 2, 3
}
Object/Array Mutation with const
javascript
// ‚úÖ Objects can be modified
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
};

config.timeout = 10000; // ‚úÖ Allowed
config.retries = 3; // ‚úÖ Allowed

// ‚ùå But reassignment is not allowed
// config = { new: "object" }; // TypeError

// ‚úÖ Arrays can be modified
const fruits = ["apple", "banana"];
fruits.push("orange"); // ‚úÖ Allowed
fruits[0] = "grape"; // ‚úÖ Allowed

// To prevent mutation entirely:
Object.freeze(config);
// config.newProp = "value"; // Fails silently in non-strict mode
üìä Comparison Table
Feature	var	let	const
Scope	Function	Block	Block
Hoisting	Yes (initialized)	Yes (TDZ)	Yes (TDZ)
Redeclaration	‚úÖ Allowed	‚ùå Not allowed	‚ùå Not allowed
Reassignment	‚úÖ Allowed	‚úÖ Allowed	‚ùå Not allowed
Temporal Dead Zone	‚ùå No	‚úÖ Yes	‚úÖ Yes
Global Property	‚úÖ Creates	‚ùå Doesn't create	‚ùå Doesn't create
üèÜ Best Practices
Use const by default
javascript
// ‚úÖ Good
const API_URL = "https://api.example.com";
const MAX_RETRIES = 3;
const userPreferences = { theme: "dark" };
const availableLanguages = ["en", "es", "fr"];

// Only use let when you need reassignment
let isLoading = false;
let currentPage = 1;
let userInput = "";

// Avoid var in modern code
// ‚ùå var oldVariable = "deprecated";
Practical Usage Patterns
javascript
// Configuration objects
const APP_CONFIG = {
    apiBaseUrl: "https://api.example.com",
    version: "1.0.0",
    features: {
        darkMode: true,
        notifications: false
    }
};

// Arrays that will be modified
const TODO_ITEMS = [
    { id: 1, text: "Learn JavaScript", completed: true },
    { id: 2, text: "Master React Native", completed: false }
];

// Variables that change
let currentUser = null;
let networkStatus = "online";
let attemptCount = 0;

// In React Native components
const UserProfile = () => {
    const [user, setUser] = useState(null); // const for state setters
    const navigation = useNavigation(); // const for hooks
    
    let temporaryValue = ""; // let for values that change within function
};
‚ö†Ô∏è Common Pitfalls & Solutions
1. Accidental Reassignment
javascript
const items = [1, 2, 3];
// items = [4, 5, 6]; // ‚ùå Error

// ‚úÖ Solution: Modify instead of reassign
items.length = 0; // Clear array
items.push(4, 5, 6); // Add new items
2. Block Scope Confusion
javascript
if (true) {
    let blockScoped = "I'm here";
    const alsoBlockScoped = "Me too";
}
// console.log(blockScoped); // ‚ùå ReferenceError
3. Loop Variables
javascript
// ‚úÖ Correct - let creates new binding each iteration
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100); // 0, 1, 2, 3, 4
}

// ‚ùå Problematic - var shares same binding
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 100); // 5, 5, 5, 5, 5
}
üéØ Interview Ready Summary
When asked in interviews:

"I use const by default for all variables that won't be reassigned, let for variables that need reassignment, and avoid var due to its function scoping and hoisting behavior which can lead to unexpected bugs. const doesn't make values immutable, it only prevents reassignment of the variable itself."

This answer shows:

Understanding of modern JS practices

Awareness of scope and hoisting implications

Practical experience with real-world usage
----------------------------------------------

How does JavaScript handle asynchronous operations? explain
How JavaScript Handles Asynchronous Operations
üéØ The Core Problem
JavaScript is single-threaded, meaning it can only do one thing at a time. But we need to handle multiple operations like:

API calls (take 2-3 seconds)

File operations

Timers

User interactions

Without blocking the main thread!

üîÑ The Solution: Event Loop + Callback Queue
Synchronous (Blocking) Code:
javascript
console.log('Start');

function syncOperation() {
    console.log('Processing...');
    // Simulate heavy computation
    for (let i = 0; i < 1000000000; i++) {}
    console.log('Done');
}

syncOperation(); // Blocks everything for seconds

console.log('End');

// Output:
// "Start"
// "Processing..."
// "Done" (after delay)
// "End"
Asynchronous (Non-blocking) Code:
javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout completed');
}, 2000);

console.log('End');

// Output:
// "Start"
// "End" (immediately)
// "Timeout completed" (after 2 seconds)
üèóÔ∏è JavaScript Runtime Architecture
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CALL STACK    ‚îÇ    ‚îÇ  WEB APIs        ‚îÇ    ‚îÇ  CALLBACK QUEUE ‚îÇ
‚îÇ (Main Thread)   ‚îÇ    ‚îÇ (Browser/Node)   ‚îÇ    ‚îÇ (Task Queue)    ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ function calls  ‚îÇ    ‚îÇ setTimeout       ‚îÇ    ‚îÇ Callbacks       ‚îÇ
‚îÇ execution       ‚îÇ    ‚îÇ fetch            ‚îÇ    ‚îÇ waiting         ‚îÇ
‚îÇ context         ‚îÇ    ‚îÇ DOM events       ‚îÇ    ‚îÇ to execute      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ  EVENT LOOP   ‚îÇ
                         ‚îÇ               ‚îÇ
                         ‚îÇ Monitors      ‚îÇ
                         ‚îÇ Stack & Queue ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üìö Async Mechanisms Evolution
1. Callbacks (The OG Way)
javascript
// Simple callback
function fetchData(callback) {
    setTimeout(() => {
        callback('Data received');
    }, 1000);
}

fetchData((result) => {
    console.log(result); // "Data received" after 1 second
});

// ‚ùå Callback Hell (Pyramid of Doom)
getUser(userId, (user) => {
    getPosts(user.id, (posts) => {
        getComments(posts[0].id, (comments) => {
            getReplies(comments[0].id, (replies) => {
                console.log(replies); // üòµ‚Äçüí´ Nested mess!
            });
        });
    });
});
2. Promises (ES6)
javascript
// Promise-based approach
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const success = Math.random() > 0.3;
            success ? resolve('Data received') : reject('Error occurred');
        }, 1000);
    });
}

// Usage
fetchData()
    .then(result => {
        console.log(result);
        return processData(result);
    })
    .then(processed => {
        console.log(processed);
    })
    .catch(error => {
        console.error('Error:', error);
    })
    .finally(() => {
        console.log('Operation completed');
    });

// ‚úÖ Multiple async operations
Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
])
.then(([user, posts, comments]) => {
    console.log('All data loaded');
})
.catch(error => {
    console.error('One request failed');
});
3. Async/Await (ES2017) - Modern Way
javascript
// Async/await - syntactic sugar over Promises
async function loadUserData() {
    try {
        console.log('Loading user data...');
        
        const user = await fetchUser();
        const posts = await fetchPosts(user.id);
        const comments = await fetchComments(posts[0].id);
        
        console.log('All data loaded:', { user, posts, comments });
        return { user, posts, comments };
    } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
    } finally {
        console.log('Data loading attempt completed');
    }
}

// Usage
loadUserData()
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Failure:', error));
üîß Detailed Execution Flow
Example with All Components:
javascript
console.log('Script start'); // 1

// Macro-task (setTimeout)
setTimeout(() => {
    console.log('setTimeout'); // 4
}, 0);

// Micro-task (Promise)
Promise.resolve()
    .then(() => {
        console.log('Promise 1'); // 3
    })
    .then(() => {
        console.log('Promise 2'); // 3.1
    });

// Synchronous code
console.log('Script end'); // 2

// Output Order:
// "Script start"
// "Script end" 
// "Promise 1"
// "Promise 2"
// "setTimeout"
üé™ Task Queues Priority
Microtasks vs Macrotasks:
javascript
console.log('Start');

// Macrotask (lower priority)
setTimeout(() => console.log('Timeout'), 0);

// Microtask (higher priority)
Promise.resolve().then(() => console.log('Promise'));

// Synchronous
console.log('End');

// Execution:
// 1. Call Stack: "Start", "End"
// 2. Microtask Queue: "Promise"
// 3. Macrotask Queue: "Timeout"

// Output:
// "Start"
// "End"
// "Promise"
// "Timeout"
Complex Example:
javascript
console.log('1 - Sync');

setTimeout(() => console.log('2 - Timeout'), 0);

Promise.resolve()
    .then(() => {
        console.log('3 - Promise');
        setTimeout(() => console.log('4 - Timeout in Promise'), 0);
    });

Promise.resolve()
    .then(() => console.log('5 - Promise 2'));

console.log('6 - Sync end');

// Output:
// "1 - Sync"
// "6 - Sync end"
// "3 - Promise"
// "5 - Promise 2"
// "2 - Timeout"
// "4 - Timeout in Promise"
üåê Real-World Async Patterns
1. API Calls with Error Handling
javascript
async function fetchUserWithRetry(userId, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(`/api/users/${userId}`);
            if (!response.ok) throw new Error('Network error');
            return await response.json();
        } catch (error) {
            if (i === retries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
    }
}

// Usage
fetchUserWithRetry(123)
    .then(user => console.log('User:', user))
    .catch(error => console.error('Failed after retries:', error));
2. Parallel Execution
javascript
// Sequential (slow)
async function sequentialFetch() {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);    // Waits for user first
    const comments = await fetchComments(posts[0].id); // Waits for posts
    return { user, posts, comments };
}

// Parallel (fast)
async function parallelFetch() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    return { user, posts, comments };
}

// Mixed approach
async function smartFetch(userId) {
    const user = await fetchUser(userId);
    
    const [posts, profile] = await Promise.all([
        fetchPosts(userId),
        fetchProfile(userId)
    ]);
    
    return { user, posts, profile };
}
3. Race Conditions & Cancellation
javascript
// Using AbortController for cancellation
function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    return fetch(url, { signal: controller.signal })
        .then(response => {
            clearTimeout(timeoutId);
            return response.json();
        })
        .catch(error => {
            clearTimeout(timeoutId);
            throw error;
        });
}

// Race: First to complete wins
Promise.race([
    fetchWithTimeout('/api/data', 2000),
    new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 3000)
    )
])
.then(data => console.log('Data:', data))
.catch(error => console.error('Error:', error.message));
‚ö° Performance Implications
Blocking the Event Loop:
javascript
// ‚ùå DON'T: Blocking operation
function calculateHashSync(data) {
    // Heavy computation blocks everything
    let hash = 0;
    for (let i = 0; i < 1000000000; i++) {
        hash = (hash << 5) - hash + i;
    }
    return hash;
}

// ‚úÖ DO: Use Web Workers or break into chunks
async function calculateHashAsync(data) {
    // Use setTimeout to yield control
    return new Promise(resolve => {
        setTimeout(() => {
            const hash = performCalculation(data);
            resolve(hash);
        }, 0);
    });
}
üéØ Key Takeaways
JavaScript is single-threaded but handles async via Event Loop

Call Stack executes synchronous code

Web APIs handle async operations (timers, network requests)

Callback Queue holds completed async operations

Event Loop moves callbacks from queue to stack when stack is empty

Microtasks (Promises) have higher priority than Macrotasks (setTimeout)

Async/Await is the modern, readable way to handle async code

üí° Interview Ready Summary
"JavaScript handles asynchronous operations through its event-driven architecture. While the call stack handles synchronous execution, async operations like timers, network requests, and file I/O are delegated to browser/Node.js APIs. When these operations complete, their callbacks are placed in task queues. The event loop continuously monitors the call stack and when empty, pushes callbacks from the queues to the stack for execution. This non-blocking I/O model allows JavaScript to handle concurrent operations efficiently despite being single-threaded."

This architecture is why JavaScript can handle thousands of concurrent connections with great performance! üöÄ


--------------------------------------------------------------------------------------------------------

xplain the concept of hoisting in JavaScript explain
Hoisting in JavaScript - Complete Guide
üéØ What is Hoisting?
Hoisting is JavaScript's behavior of moving declarations to the top of their scope during the compilation phase, before code execution.

üìù Key Concept
Note: Only declarations are hoisted, not initializations!

üîç Variable Hoisting
var Hoisting
javascript
// How we write it:
console.log(x); // undefined (not ReferenceError)
var x = 5;
console.log(x); // 5

// How JavaScript interprets it:
var x;          // Declaration hoisted to top
console.log(x); // undefined
x = 5;          // Initialization stays in place
console.log(x); // 5
let and const Hoisting (Temporal Dead Zone)
javascript
// ‚ùå Temporal Dead Zone (TDZ)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

console.log(z); // ReferenceError: Cannot access 'z' before initialization
const z = 15;

// How JavaScript interprets it:
let y;          // Declaration hoisted but NOT initialized
const z;        // Declaration hoisted but NOT initialized
console.log(y); // Error - in TDZ
console.log(z); // Error - in TDZ
y = 10;         // Initialization
z = 15;         // Initialization
üé™ Function Hoisting
Function Declarations (Fully Hoisted)
javascript
// ‚úÖ Function declarations are fully hoisted
sayHello(); // "Hello!" - works fine

function sayHello() {
    console.log("Hello!");
}

// How JavaScript interprets it:
function sayHello() {  // Entire function hoisted
    console.log("Hello!");
}
sayHello(); // Works!
Function Expressions (Partially Hoisted)
javascript
// ‚ùå Function expressions - only variable is hoisted
// sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
    console.log("Hi!");
};

sayHi(); // "Hi!" - works here

// How JavaScript interprets it:
var sayHi;              // Declaration hoisted (undefined)
// sayHi();             // Error - sayHi is undefined
sayHi = function() {    // Assignment stays here
    console.log("Hi!");
};
sayHi(); // Works!
Arrow Functions (Same as Function Expressions)
javascript
// ‚ùå Arrow functions - only variable is hoisted
// greet(); // TypeError: greet is not a function

var greet = () => {
    console.log("Greetings!");
};

greet(); // "Greetings!" - works here
‚ö° Hoisting in Different Scopes
Global Scope
javascript
console.log(globalVar); // undefined
var globalVar = "I'm global";

// Equivalent to:
var globalVar;
console.log(globalVar);
globalVar = "I'm global";
Function Scope
javascript
function test() {
    console.log(localVar); // undefined
    var localVar = "I'm local";
    console.log(localVar); // "I'm local"
}
test();

// Equivalent to:
function test() {
    var localVar;
    console.log(localVar); // undefined
    localVar = "I'm local";
    console.log(localVar); // "I'm local"
}
Block Scope (let/const)
javascript
function blockExample() {
    console.log(beforeBlock); // undefined
    
    {
        // console.log(blockVar); // ReferenceError: TDZ!
        let blockVar = "inside block";
        console.log(blockVar); // "inside block"
    }
    
    // console.log(blockVar); // ReferenceError: not accessible
    var beforeBlock = "hoisted";
}
blockExample();
üé≠ Hoisting Order of Precedence
Functions First, Then Variables
javascript
// Example 1
console.log(typeof myFunc); // "function"
console.log(typeof myVar);  // "undefined"

function myFunc() {
    return "I'm a function";
}
var myVar = "I'm a variable";

// How JavaScript interprets it:
function myFunc() {         // Function hoisted first
    return "I'm a function";
}
var myVar;                  // Variable declaration hoisted
console.log(typeof myFunc); // "function"
console.log(typeof myVar);  // "undefined"
myVar = "I'm a variable";   // Initialization
Duplicate Declarations
javascript
// Function declaration overrides variable declaration
console.log(typeof example); // "function"

var example = "I'm a variable";
function example() {
    return "I'm a function";
}

console.log(typeof example); // "string"

// How JavaScript interprets it:
function example() {        // Function hoisted first
    return "I'm a function";
}
var example;                // Variable declaration (ignored - function exists)
console.log(typeof example); // "function"
example = "I'm a variable"; // Reassignment
console.log(typeof example); // "string"
üî• Practical Examples & Gotchas
Example 1: Tricky Hoisting
javascript
var x = 1;

function test() {
    console.log(x); // undefined (not 1!)
    var x = 2;
    console.log(x); // 2
}

test();
console.log(x); // 1

// Equivalent to:
var x = 1;

function test() {
    var x;        // Declaration hoisted (shadows global x)
    console.log(x); // undefined
    x = 2;        // Initialization
    console.log(x); // 2
}

test();
console.log(x); // 1 (global x unchanged)
Example 2: Function vs Variable
javascript
// Scenario 1
var a = 1;
function a() {}
console.log(typeof a); // "number"

// Scenario 2
function b() {}
var b = 1;
console.log(typeof b); // "number"

// Both scenarios interpreted as:
function a() {}  // Function hoisted
function b() {}  // Function hoisted
var a;           // Ignored (function exists)
var b;           // Ignored (function exists)
a = 1;           // Reassignment
b = 1;           // Reassignment
console.log(typeof a); // "number"
console.log(typeof b); // "number"
Example 3: Conditional Function Declarations
javascript
// ‚ùå Avoid this - behavior is inconsistent
if (true) {
    function conditionalFunc() {
        return "I'm in true block";
    }
} else {
    function conditionalFunc() {
        return "I'm in false block";
    }
}

console.log(conditionalFunc()); // Varies by browser and strict mode
üõ°Ô∏è Best Practices to Avoid Hoisting Issues
1. Use let and const
javascript
// ‚úÖ Good - no hoisting surprises
console.log(myLet);    // ReferenceError
console.log(myConst);  // ReferenceError
let myLet = "value";
const myConst = "value";

// ‚ùå Avoid - hoisting can cause bugs
console.log(myVar); // undefined (silent failure)
var myVar = "value";
2. Declare Variables at Top
javascript
// ‚úÖ Good practice
function cleanFunction() {
    // Declare all variables at top
    const config = getConfig();
    let isLoading = false;
    const data = [];
    
    // Then use them
    if (config.enabled) {
        isLoading = true;
        // ... rest of logic
    }
}
3. Use Function Expressions for Conditional Logic
javascript
// ‚úÖ Clear and predictable
let myFunction;

if (condition) {
    myFunction = function() {
        console.log("Condition true");
    };
} else {
    myFunction = function() {
        console.log("Condition false");
    };
}

myFunction(); // Always works as expected
üìä Hoisting Summary Table
Declaration Type	Hoisting	Initial Value	Scope
var	‚úÖ Yes	undefined	Function
let	‚úÖ Yes (TDZ)	Uninitialized	Block
const	‚úÖ Yes (TDZ)	Uninitialized	Block
Function Declaration	‚úÖ Yes	Function itself	Block (strict)
Function Expression	‚ö†Ô∏è Variable only	undefined	Depends on variable
Arrow Function	‚ö†Ô∏è Variable only	undefined	Depends on variable
üéØ Interview Ready Explanation
"Hoisting is JavaScript's mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution. However, only declarations are hoisted, not initializations.

Key points:

var declarations are hoisted and initialized with undefined

let and const are hoisted but remain uninitialized (Temporal Dead Zone)

Function declarations are fully hoisted with their definitions

Function expressions follow variable hoisting rules

Best practice is to use let/const and declare variables at the top of their scope to avoid unexpected behavior."

üí° Quick Mental Model
javascript
// What you write:
console.log(a);
var a = 10;
function b() { return 20; }

// What JavaScript does:
function b() { return 20; }  // Functions first
var a;                       // Then variables
console.log(a); // undefined
a = 10;         // Then assignments
Understanding hoisting helps you avoid subtle bugs and write more predictable JavaScript code! üöÄ
------------------------------------------------------------------------

What are closures and how do they work?
Closures in JavaScript - Complete Guide
üéØ What is a Closure?
A closure is a function that has access to variables from its outer (enclosing) scope even after the outer function has finished executing.

üí° Simple Definition
"A closure gives you access to an outer function's scope from an inner function"

üîç Basic Example
javascript
function outer() {
    const outerVar = "I'm from outer scope!";
    
    function inner() {
        console.log(outerVar); // Accesses outerVar
    }
    
    return inner;
}

const closureFunc = outer();
closureFunc(); // "I'm from outer scope!" - Still remembers outerVar!
üèóÔ∏è How Closures Work
Step-by-Step Execution:
javascript
function createCounter() {
    let count = 0; // This variable is "closed over"
    
    return function() {
        count++;    // Remembers count between calls
        return count;
    };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Each call remembers the same 'count' variable!
üìö Types of Closures
1. Function Returning Function
javascript
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

console.log(sayHello("Alice")); // "Hello, Alice!"
console.log(sayHi("Bob"));      // "Hi, Bob!"

// Each function remembers its own 'greeting'
2. IIFE (Immediately Invoked Function Expression)
javascript
const uniqueId = (function() {
    let id = 0;
    
    return function() {
        return id++;
    };
})();

console.log(uniqueId()); // 0
console.log(uniqueId()); // 1
console.log(uniqueId()); // 2
3. Event Handlers
javascript
function setupButtons() {
    const buttons = document.querySelectorAll('button');
    
    for (var i = 0; i < buttons.length; i++) {
        // Without closure - problem!
        buttons[i].addEventListener('click', function() {
            console.log('Button ' + i + ' clicked'); // Always "Button 3 clicked"
        });
    }
}

// Fixed with closure:
function setupButtonsFixed() {
    const buttons = document.querySelectorAll('button');
    
    for (var i = 0; i < buttons.length; i++) {
        (function(index) {
            buttons[index].addEventListener('click', function() {
                console.log('Button ' + index + ' clicked'); // Correct index!
            });
        })(i);
    }
}

// Modern solution with let:
function setupButtonsModern() {
    const buttons = document.querySelectorAll('button');
    
    for (let i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
            console.log('Button ' + i + ' clicked'); // Works with let!
        });
    }
}
üî• Practical Use Cases
1. Data Privacy & Encapsulation
javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return "Insufficient funds";
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);
console.log(account.getBalance()); // 1000
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300

// ‚ùå Cannot access balance directly
// console.log(account.balance); // undefined
2. Function Factories
javascript
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5));  // 10
console.log(triple(5));  // 15
console.log(quadruple(5)); // 20
3. Memoization (Caching)
javascript
function memoize(fn) {
    const cache = {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache[key]) {
            console.log('Returning cached result');
            return cache[key];
        }
        
        console.log('Calculating result');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// Expensive function
function slowSquare(n) {
    for (let i = 0; i < 1000000000; i++) {} // Simulate slow operation
    return n * n;
}

const memoizedSquare = memoize(slowSquare);

console.log(memoizedSquare(5)); // "Calculating result" then 25
console.log(memoizedSquare(5)); // "Returning cached result" then 25 (fast!)
4. Partial Application & Currying
javascript
// Partial application
function partial(fn, ...fixedArgs) {
    return function(...remainingArgs) {
        return fn.apply(this, fixedArgs.concat(remainingArgs));
    };
}

function multiply(a, b, c) {
    return a * b * c;
}

const multiplyByTwo = partial(multiply, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

// Currying
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)); // 24
üîß Advanced Closure Patterns
1. Module Pattern
javascript
const Calculator = (function() {
    let memory = 0;
    
    function add(a, b) {
        return a + b;
    }
    
    function subtract(a, b) {
        return a - b;
    }
    
    function store(value) {
        memory = value;
    }
    
    function recall() {
        return memory;
    }
    
    // Public API
    return {
        add,
        subtract,
        store,
        recall
    };
})();

console.log(Calculator.add(5, 3)); // 8
Calculator.store(100);
console.log(Calculator.recall()); // 100

// ‚ùå Private variables inaccessible
// console.log(Calculator.memory); // undefined
2. React Hooks (Closures in Action)
javascript
// Simplified useState implementation
function useState(initialValue) {
    let state = initialValue;
    
    function setState(newValue) {
        state = newValue;
        // Trigger re-render logic here
        console.log('State updated to:', state);
    }
    
    function getState() {
        return state;
    }
    
    return [getState, setState];
}

// Usage similar to React
const [getCount, setCount] = useState(0);
console.log(getCount()); // 0
setCount(5);
console.log(getCount()); // 5
‚ö†Ô∏è Common Pitfalls & Solutions
1. Loop Variable Capture
javascript
// ‚ùå Problem: All functions share same 'i'
function createFunctionsProblem() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i); // Always 3!
        });
    }
    
    return functions;
}

const funcs = createFunctionsProblem();
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3

// ‚úÖ Solution 1: IIFE
function createFunctionsFixed() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        (function(index) {
            functions.push(function() {
                console.log(index); // 0, 1, 2
            });
        })(i);
    }
    
    return functions;
}

// ‚úÖ Solution 2: Use let
function createFunctionsModern() {
    var functions = [];
    
    for (let i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i); // 0, 1, 2
        });
    }
    
    return functions;
}
2. Memory Leaks
javascript
// ‚ùå Potential memory leak
function createHeavyClosure() {
    const largeData = new Array(1000000).fill("data");
    
    return function() {
        console.log('Closure using large data');
        // largeData stays in memory even if not used!
    };
}

// ‚úÖ Solution: Release references
function createOptimizedClosure() {
    let largeData = new Array(1000000).fill("data");
    
    const usefulFunction = function() {
        console.log('Using data:', largeData[0]);
    };
    
    // Allow cleanup
    usefulFunction.cleanup = function() {
        largeData = null;
    };
    
    return usefulFunction;
}
üéØ Interview Questions & Answers
Q: What creates a closure?
A: A closure is created when a function is defined inside another function and the inner function references variables from the outer function's scope.

Q: Why are closures useful?
A: Closures enable:

Data privacy and encapsulation

Function factories and currying

Memoization and caching

Event handlers with preserved context

Module patterns

Q: What's the relationship between closures and scope?
A: Closures have access to:

Their own scope (variables defined between curly braces)

Outer function's scope

Global scope

üí° Key Takeaways
Closures remember their lexical environment - variables available at creation time

Every function in JavaScript is a closure (except arrow functions in some cases)

Closures enable powerful patterns like modules, memoization, and currying

Watch for memory leaks - closures can prevent garbage collection

Use closures for data encapsulation and private variables

üî¨ Under the Hood
javascript
function outer(x) {
    return function inner(y) {
        return x + y;
    };
}

const add5 = outer(5);
console.log(add5(3)); // 8

// What happens:
// 1. outer(5) executes, creates execution context
// 2. inner function is created, captures reference to x (5)
// 3. outer finishes, but inner maintains reference to x
// 4. add5(3) executes, can still access x from closure
Closures are fundamental to JavaScript - they're what make functions first-class citizens and enable functional programming patterns! üöÄ

create tree diagram of above closure


Cancel

Send
I'll create a comprehensive tree diagram of all the JavaScript and React Native concepts from your question list.

üå≥ JavaScript & React Native Knowledge Tree
TRUNK: CORE FOUNDATIONS
1. üåø JavaScript Fundamentals
text
JavaScript Fundamentals
‚îú‚îÄ‚îÄ üì¶ Core Concepts
‚îÇ   ‚îú‚îÄ‚îÄ Event Loop & Call Stack
‚îÇ   ‚îú‚îÄ‚îÄ let vs const vs var
‚îÇ   ‚îú‚îÄ‚îÄ Asynchronous Operations
‚îÇ   ‚îú‚îÄ‚îÄ Hoisting
‚îÇ   ‚îú‚îÄ‚îÄ Closures
‚îÇ   ‚îú‚îÄ‚îÄ this Keyword & Binding
‚îÇ   ‚îú‚îÄ‚îÄ == vs ===
‚îÇ   ‚îú‚îÄ‚îÄ Prototypal Inheritance
‚îÇ   ‚îú‚îÄ‚îÄ Primitive vs Reference Types
‚îÇ   ‚îî‚îÄ‚îÄ Truthy/Falsy Values
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° ES6+ Features
‚îÇ   ‚îú‚îÄ‚îÄ Arrow Functions
‚îÇ   ‚îú‚îÄ‚îÄ Template Literals
‚îÇ   ‚îú‚îÄ‚îÄ Destructuring
‚îÇ   ‚îú‚îÄ‚îÄ Default Parameters
‚îÇ   ‚îú‚îÄ‚îÄ Spread/Rest Operators
‚îÇ   ‚îú‚îÄ‚îÄ Enhanced Object Literals
‚îÇ   ‚îú‚îÄ‚îÄ Loops (for, for...of, for...in, forEach)
‚îÇ   ‚îú‚îÄ‚îÄ Sets, Maps, WeakSet, WeakMap
‚îÇ   ‚îî‚îÄ‚îÄ Class Syntax
‚îÇ
‚îú‚îÄ‚îÄ üîß Functions & Scope
‚îÇ   ‚îú‚îÄ‚îÄ Function vs Block Scope
‚îÇ   ‚îú‚îÄ‚îÄ Lexical Scoping
‚îÇ   ‚îú‚îÄ‚îÄ Higher-Order Functions
‚îÇ   ‚îú‚îÄ‚îÄ Function Currying
‚îÇ   ‚îú‚îÄ‚îÄ bind() Method
‚îÇ   ‚îú‚îÄ‚îÄ Pure Functions
‚îÇ   ‚îî‚îÄ‚îÄ Memoization
‚îÇ
‚îú‚îÄ‚îÄ üîÑ Async JavaScript
‚îÇ   ‚îú‚îÄ‚îÄ Callbacks & Callback Hell
‚îÇ   ‚îú‚îÄ‚îÄ Promises
‚îÇ   ‚îú‚îÄ‚îÄ Promise Lifecycle
‚îÇ   ‚îú‚îÄ‚îÄ Async/Await
‚îÇ   ‚îú‚îÄ‚îÄ Microtasks vs Macrotasks
‚îÇ   ‚îú‚îÄ‚îÄ Promise.all vs Promise.allSettled
‚îÇ   ‚îú‚îÄ‚îÄ AbortController
‚îÇ   ‚îî‚îÄ‚îÄ Error Handling
‚îÇ
‚îî‚îÄ‚îÄ üéØ Objects & Arrays
    ‚îú‚îÄ‚îÄ Iteration Methods
    ‚îú‚îÄ‚îÄ Array Methods (map, filter, reduce, etc.)
    ‚îú‚îÄ‚îÄ Deep Cloning
    ‚îú‚îÄ‚îÄ Object Methods (create, assign, spread)
    ‚îú‚îÄ‚îÄ Object Modification Prevention
    ‚îú‚îÄ‚îÄ Getters/Setters
    ‚îî‚îÄ‚îÄ Prototype Chain
2. üåø React Native Core
text
React Native Core
‚îú‚îÄ‚îÄ üèóÔ∏è Architecture & Fundamentals
‚îÇ   ‚îú‚îÄ‚îÄ React Native vs Other Frameworks
‚îÇ   ‚îú‚îÄ‚îÄ Bridge Concept
‚îÇ   ‚îú‚îÄ‚îÄ Threading Model (UI, JS, Native)
‚îÇ   ‚îú‚îÄ‚îÄ Native Modules vs JS Components
‚îÇ   ‚îú‚îÄ‚îÄ New Architecture (Fabric, Turbo Modules, JSI)
‚îÇ   ‚îú‚îÄ‚îÄ Hermes Engine
‚îÇ   ‚îú‚îÄ‚îÄ Screen Densities & Resolutions
‚îÇ   ‚îú‚îÄ‚îÄ React Native vs Expo
‚îÇ   ‚îú‚îÄ‚îÄ Limitations
‚îÇ   ‚îú‚îÄ‚îÄ Hot Reloading vs Live Reloading
‚îÇ   ‚îú‚îÄ‚îÄ Component Lifecycle
‚îÇ   ‚îú‚îÄ‚îÄ Component Creation Methods
‚îÇ   ‚îú‚îÄ‚îÄ Styling Differences from Web
‚îÇ   ‚îî‚îÄ‚îÄ Metro Bundler
‚îÇ
‚îú‚îÄ‚îÄ üé® Core Components
‚îÇ   ‚îú‚îÄ‚îÄ View vs ScrollView
‚îÇ   ‚îú‚îÄ‚îÄ FlatList vs SectionList
‚îÇ   ‚îú‚îÄ‚îÄ Image vs ImageBackground
‚îÇ   ‚îú‚îÄ‚îÄ Pressable vs Touchable*
‚îÇ   ‚îú‚îÄ‚îÄ Flexbox in RN
‚îÇ   ‚îú‚îÄ‚îÄ Platform-Specific Styling
‚îÇ   ‚îú‚îÄ‚îÄ PixelRatio API
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ useWindowDimensions Hook
‚îÇ   ‚îú‚îÄ‚îÄ Dark/Light Mode
‚îÇ   ‚îú‚îÄ‚îÄ Text Overflow
‚îÇ   ‚îú‚îÄ‚îÄ Custom Components with TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ Image Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Custom Fonts
‚îÇ   ‚îú‚îÄ‚îÄ Screen Size Handling
‚îÇ   ‚îî‚îÄ‚îÄ Safe Areas & Notches
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° State Management & Hooks
‚îÇ   ‚îú‚îÄ‚îÄ Local vs Global State
‚îÇ   ‚îú‚îÄ‚îÄ Redux vs MobX vs Zustand vs Context API
‚îÇ   ‚îú‚îÄ‚îÄ Context API + useReducer
‚îÇ   ‚îú‚îÄ‚îÄ Performance Implications
‚îÇ   ‚îú‚îÄ‚îÄ useState with Complex Objects
‚îÇ   ‚îú‚îÄ‚îÄ useEffect & Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ useMemo vs useCallback
‚îÇ   ‚îú‚îÄ‚îÄ Custom Hooks
‚îÇ   ‚îú‚îÄ‚îÄ useRef Use Cases
‚îÇ   ‚îú‚îÄ‚îÄ Form State Management
‚îÇ   ‚îú‚îÄ‚îÄ useReducer for Complex Logic
‚îÇ   ‚îú‚îÄ‚îÄ AsyncStorage Persistence
‚îÇ   ‚îú‚îÄ‚îÄ API State Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Offline State & Sync
‚îÇ   ‚îú‚îÄ‚îÄ Debouncing & Throttling
‚îÇ   ‚îî‚îÄ‚îÄ Rules of Hooks
‚îÇ
‚îú‚îÄ‚îÄ üöÄ Performance Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Identifying Bottlenecks
‚îÇ   ‚îú‚îÄ‚îÄ Common Performance Issues
‚îÇ   ‚îú‚îÄ‚îÄ Bundle Size Optimization
‚îÇ   ‚îú‚îÄ‚îÄ useMemo & useCallback Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Flipper Debugging
‚îÇ   ‚îú‚îÄ‚îÄ List Keys Importance
‚îÇ   ‚îú‚îÄ‚îÄ Virtualized Lists
‚îÇ   ‚îú‚îÄ‚îÄ React.memo & shouldComponentUpdate
‚îÇ   ‚îú‚îÄ‚îÄ Reducing Re-renders
‚îÇ   ‚îú‚îÄ‚îÄ Image Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Memory Leaks
‚îÇ   ‚îú‚îÄ‚îÄ InteractionManager
‚îÇ   ‚îú‚îÄ‚îÄ Lazy Loading
‚îÇ   ‚îú‚îÄ‚îÄ Bridge Performance
‚îÇ   ‚îú‚îÄ‚îÄ Performance API
‚îÇ   ‚îú‚îÄ‚îÄ Hermes Benefits
‚îÇ   ‚îú‚îÄ‚îÄ Debouncing Search
‚îÇ   ‚îú‚îÄ‚îÄ Throttling Scroll
‚îÇ   ‚îî‚îÄ‚îÄ Animation Optimization
‚îÇ
‚îî‚îÄ‚îÄ üåê APIs & Networking
    ‚îú‚îÄ‚îÄ API Calls Handling
    ‚îú‚îÄ‚îÄ Fetch vs Axios vs React Query
    ‚îú‚îÄ‚îÄ SSL Pinning
    ‚îú‚îÄ‚îÄ Error Handling & Retry
    ‚îú‚îÄ‚îÄ File Uploads/Downloads
    ‚îú‚îÄ‚îÄ FormData API
    ‚îú‚îÄ‚îÄ WebSocket Connections
    ‚îú‚îÄ‚îÄ API Tokens & Auth
    ‚îú‚îÄ‚îÄ Request/Response Interceptors
    ‚îú‚îÄ‚îÄ NetInfo & Offline Detection
    ‚îú‚îÄ‚îÄ Environment Management
    ‚îî‚îÄ‚îÄ API Caching Strategies
BRANCHES: ADVANCED TOPICS
3. üçÇ TypeScript with React
text
TypeScript with React
‚îú‚îÄ‚îÄ üìù Fundamentals
‚îÇ   ‚îú‚îÄ‚îÄ Interface vs Type
‚îÇ   ‚îú‚îÄ‚îÄ Component Props Typing
‚îÇ   ‚îú‚îÄ‚îÄ Generic Types
‚îÇ   ‚îú‚îÄ‚îÄ Hooks Typing (useState, useEffect, useReducer)
‚îÇ   ‚îú‚îÄ‚îÄ Union Types
‚îÇ   ‚îú‚îÄ‚îÄ Optional Props & Defaults
‚îÇ   ‚îú‚îÄ‚îÄ Utility Types (Partial, Pick, Omit, Required)
‚îÇ   ‚îú‚îÄ‚îÄ Event Typing (onClick, onChange)
‚îÇ   ‚îú‚îÄ‚îÄ Type Inference
‚îÇ   ‚îî‚îÄ‚îÄ Custom Hooks with TS
‚îÇ
‚îú‚îÄ‚îÄ üé® Advanced Patterns
‚îÇ   ‚îú‚îÄ‚îÄ Polymorphic Components
‚îÇ   ‚îú‚îÄ‚îÄ Discriminated Unions
‚îÇ   ‚îú‚îÄ‚îÄ Higher-Order Components (HOCs)
‚îÇ   ‚îú‚îÄ‚îÄ as const Assertion
‚îÇ   ‚îú‚îÄ‚îÄ Type-Safe Forms
‚îÇ   ‚îú‚îÄ‚îÄ Redux Slices & Actions
‚îÇ   ‚îú‚îÄ‚îÄ Type-Safe Event Emitters
‚îÇ   ‚îú‚îÄ‚îÄ Dependency Injection
‚îÇ   ‚îú‚îÄ‚îÄ React Context Typing
‚îÇ   ‚îú‚îÄ‚îÄ Children Typing
‚îÇ   ‚îú‚îÄ‚îÄ Component Refs
‚îÇ   ‚îî‚îÄ‚îÄ Template Literal Types
‚îÇ
‚îî‚îÄ‚îÄ ‚ö° Performance & Testing
    ‚îú‚îÄ‚îÄ React.memo with TS
    ‚îú‚îÄ‚îÄ useCallback & useMemo Typing
    ‚îú‚îÄ‚îÄ Large Type Definitions
    ‚îú‚îÄ‚îÄ Type-Safe Tests
    ‚îú‚îÄ‚îÄ Test Utilities & Fixtures
    ‚îú‚îÄ‚îÄ Third-Party Library Types
    ‚îú‚îÄ‚îÄ Error Boundaries
    ‚îî‚îÄ‚îÄ Complex State Shapes
4. üçÇ State Management
text
State Management
‚îú‚îÄ‚îÄ üî¥ Redux Toolkit
‚îÇ   ‚îú‚îÄ‚îÄ Problems Solved
‚îÇ   ‚îú‚îÄ‚îÄ Store Configuration
‚îÇ   ‚îú‚îÄ‚îÄ createSlice
‚îÇ   ‚îú‚îÄ‚îÄ Immutable Updates
‚îÇ   ‚îú‚îÄ‚îÄ Reducers vs ExtraReducers
‚îÇ   ‚îú‚îÄ‚îÄ createAsyncThunk
‚îÇ   ‚îú‚îÄ‚îÄ Loading States
‚îÇ   ‚îú‚îÄ‚îÄ Selector Optimization
‚îÇ   ‚îú‚îÄ‚îÄ createSelector (Reselect)
‚îÇ   ‚îú‚îÄ‚îÄ Preventing Re-renders
‚îÇ   ‚îî‚îÄ‚îÄ Testing
‚îÇ
‚îú‚îÄ‚îÄ üéØ Context API
‚îÇ   ‚îú‚îÄ‚îÄ Context + useReducer
‚îÇ   ‚îú‚îÄ‚îÄ Performance Implications
‚îÇ   ‚îú‚îÄ‚îÄ Selective Re-renders
‚îÇ   ‚îú‚îÄ‚îÄ Context vs Redux
‚îÇ   ‚îî‚îÄ‚îÄ Complex State Management
‚îÇ
‚îî‚îÄ‚îÄ üü¢ React Query (TanStack)
    ‚îú‚îÄ‚îÄ Problems Solved
    ‚îú‚îÄ‚îÄ Setup & Configuration
    ‚îú‚îÄ‚îÄ useQuery Hook
    ‚îú‚îÄ‚îÄ Query Keys Importance
    ‚îú‚îÄ‚îÄ Loading & Error States
    ‚îú‚îÄ‚îÄ Dependent Queries
    ‚îú‚îÄ‚îÄ Pagination
    ‚îú‚îÄ‚îÄ useMutation Hook
    ‚îú‚îÄ‚îÄ Optimistic Updates
    ‚îú‚îÄ‚îÄ Query Invalidation
    ‚îú‚îÄ‚îÄ Direct Data Updates
    ‚îú‚îÄ‚îÄ Request Deduplication
    ‚îî‚îÄ‚îÄ Cache Garbage Collection
5. üçÇ Styling
text
Styling
‚îú‚îÄ‚îÄ üé® StyleSheet API
‚îÇ   ‚îú‚îÄ‚îÄ Advantages over Inline Styles
‚îÇ   ‚îú‚îÄ‚îÄ Performance Optimization
‚îÇ   ‚îú‚îÄ‚îÄ Dynamic Styles
‚îÇ   ‚îú‚îÄ‚îÄ Style Combination
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ Platform-Specific Styles
‚îÇ   ‚îî‚îÄ‚îÄ StyleSheet.create() Benefits
‚îÇ
‚îú‚îÄ‚îÄ üåÄ Tailwind/NativeWind
‚îÇ   ‚îú‚îÄ‚îÄ NativeWind Introduction
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js Configuration
‚îÇ   ‚îú‚îÄ‚îÄ Dark Mode Handling
‚îÇ   ‚îú‚îÄ‚îÄ Responsive Designs
‚îÇ   ‚îú‚îÄ‚îÄ Dynamic Classes
‚îÇ   ‚îú‚îÄ‚îÄ Component Variants
‚îÇ   ‚îî‚îÄ‚îÄ Performance Considerations
‚îÇ
‚îî‚îÄ‚îÄ üíÖ Styled Components
    ‚îú‚îÄ‚îÄ How They Work
    ‚îú‚îÄ‚îÄ Theme Implementation
    ‚îú‚îÄ‚îÄ Responsive Design
    ‚îú‚îÄ‚îÄ Polymorphic Components
    ‚îú‚îÄ‚îÄ Conditional Styling
    ‚îú‚îÄ‚îÄ Performance Implications
    ‚îî‚îÄ‚îÄ Re-render Optimization
LEAVES: SPECIALIZED TOPICS
6. üçÅ Navigation
text
Navigation
‚îú‚îÄ‚îÄ React Navigation vs React Native Navigation
‚îú‚îÄ‚îÄ Stack Navigation with Parameters
‚îú‚îÄ‚îÄ Stack vs Tab vs Drawer Navigators
‚îú‚îÄ‚îÄ Authentication Flows
‚îú‚îÄ‚îÄ Deep Linking
‚îú‚îÄ‚îÄ Complex Object Passing
‚îú‚îÄ‚îÄ Navigation References
‚îú‚îÄ‚îÄ State Persistence
‚îú‚îÄ‚îÄ Lifecycle Methods
‚îú‚îÄ‚îÄ Custom Transitions
‚îú‚îÄ‚îÄ Protected Routes
‚îú‚îÄ‚îÄ Navigation Containers
‚îú‚îÄ‚îÄ Nested Navigation
‚îú‚îÄ‚îÄ Hardware Back Button
‚îî‚îÄ‚îÄ Modal Screens
7. üçÅ Advanced Patterns
text
Advanced Patterns
‚îú‚îÄ‚îÄ Biometric Authentication
‚îú‚îÄ‚îÄ Push Notifications (FCM/APNS)
‚îú‚îÄ‚îÄ In-App Purchases
‚îú‚îÄ‚îÄ Accessibility Best Practices
‚îú‚îÄ‚îÄ RTL Layouts
‚îú‚îÄ‚îÄ LayoutAnimation API
‚îú‚îÄ‚îÄ Component Libraries
‚îú‚îÄ‚îÄ Tablet Support
‚îú‚îÄ‚îÄ Theming in Large Apps
‚îú‚îÄ‚îÄ react-native-reanimated
‚îú‚îÄ‚îÄ Complex Gesture Handling
‚îú‚îÄ‚îÄ Security Best Practices
‚îú‚îÄ‚îÄ Reverse Engineering Prevention
‚îú‚îÄ‚îÄ Version Migration
‚îú‚îÄ‚îÄ Background Tasks
‚îú‚îÄ‚îÄ Deep Linking with Parameters
‚îú‚îÄ‚îÄ Video Streaming
‚îú‚îÄ‚îÄ Maps & Location Services
‚îú‚îÄ‚îÄ Audio Recording/Playback
‚îî‚îÄ‚îÄ Camera & Photo Library
8. üçÅ Testing & Debugging
text
Testing & Debugging
‚îú‚îÄ‚îÄ Testing Frameworks
‚îú‚îÄ‚îÄ Jest Setup
‚îú‚îÄ‚îÄ Unit vs Integration vs E2E Testing
‚îú‚îÄ‚îÄ React Testing Library
‚îú‚îÄ‚îÄ Detox for E2E
‚îú‚îÄ‚îÄ Flipper Debugging
‚îú‚îÄ‚îÄ Chrome DevTools
‚îú‚îÄ‚îÄ Error Tracking & Crash Reporting
‚îú‚îÄ‚îÄ Native Issues Debugging
‚îú‚îÄ‚îÄ Platform-Specific Code Testing
‚îú‚îÄ‚îÄ Native Module Mocking
‚îú‚îÄ‚îÄ Snapshot Testing
‚îú‚îÄ‚îÄ Navigation Flow Testing
‚îú‚îÄ‚îÄ CI/CD Testing
‚îî‚îÄ‚îÄ Test Coverage Measurement
ROOTS: INFRASTRUCTURE
9. üå± Storage & APIs
text
Storage & APIs
‚îú‚îÄ‚îÄ üíæ Storage Options
‚îÇ   ‚îú‚îÄ‚îÄ AsyncStorage vs MMKV vs SQLite vs Realm
‚îÇ   ‚îú‚îÄ‚îÄ SQLite vs Key-Value Storage
‚îÇ   ‚îú‚îÄ‚îÄ Secure Storage for Sensitive Data
‚îÇ   ‚îú‚îÄ‚îÄ Keychain & SharedPreferences
‚îÇ   ‚îú‚îÄ‚îÄ Data Synchronization
‚îÇ   ‚îú‚îÄ‚îÄ Database Schema Migrations
‚îÇ   ‚îú‚îÄ‚îÄ Caching Strategies
‚îÇ   ‚îú‚îÄ‚îÄ MMKV Advantages
‚îÇ   ‚îú‚îÄ‚îÄ Large Dataset Storage
‚îÇ   ‚îú‚îÄ‚îÄ Realm vs SQLite
‚îÇ   ‚îî‚îÄ‚îÄ Offline-First Strategies
‚îÇ
‚îî‚îÄ‚îÄ üåê Advanced APIs
    ‚îú‚îÄ‚îÄ Background Sync
    ‚îú‚îÄ‚îÄ Large File Downloads with Progress
    ‚îú‚îÄ‚îÄ Network Security
    ‚îú‚îÄ‚îÄ WebSocket Connections
    ‚îú‚îÄ‚îÄ Real-time Updates
    ‚îî‚îÄ‚îÄ File Uploads with Progress
10. üå± Deployment & CI/CD
text
Deployment & CI/CD
‚îú‚îÄ‚îÄ iOS App Distribution
‚îú‚îÄ‚îÄ Android App Distribution
‚îú‚îÄ‚îÄ Dev/Staging/Production Builds
‚îú‚îÄ‚îÄ CodePush for OTA Updates
‚îú‚îÄ‚îÄ App Signing Process
‚îú‚îÄ‚îÄ Fastlane Automation
‚îú‚îÄ‚îÄ App Store Submission
‚îú‚îÄ‚îÄ Versioning & Build Numbers
‚îú‚îÄ‚îÄ CI/CD Pipeline Setup
‚îú‚îÄ‚îÄ Environment Configurations
‚îú‚îÄ‚îÄ Deployment Pitfalls
‚îú‚îÄ‚îÄ Beta Testing & Distribution
‚îú‚îÄ‚îÄ Production Performance Monitoring
‚îî‚îÄ‚îÄ Rollbacks & Emergency Updates
FRUITS: PRACTICAL APPLICATIONS
11. üçé Real-World Scenarios
text
Real-World Scenarios
‚îú‚îÄ‚îÄ Debugging Memory Leaks
‚îú‚îÄ‚îÄ Optimizing 1000+ Item Lists
‚îú‚îÄ‚îÄ Real-time Chat with Offline Support
‚îú‚îÄ‚îÄ Poor Network Handling
‚îú‚îÄ‚îÄ Architecture Migration
‚îú‚îÄ‚îÄ Complex Animation Sequences
‚îú‚îÄ‚îÄ Multi-screen Data Sync
‚îú‚îÄ‚îÄ Internationalization (i18n)
‚îú‚îÄ‚îÄ A/B Testing & Feature Flags
‚îî‚îÄ‚îÄ App Startup Time Optimization
12. üçé Library-Specific Expertise
text
Library-Specific Expertise
‚îú‚îÄ‚îÄ üîÑ Axios
‚îÇ   ‚îú‚îÄ‚îÄ vs Fetch API
‚îÇ   ‚îú‚îÄ‚îÄ Custom Configuration
‚îÇ   ‚îú‚îÄ‚îÄ Content Type Handling
‚îÇ   ‚îú‚îÄ‚îÄ Request Cancellation
‚îÇ   ‚îú‚îÄ‚îÄ Timeout Handling
‚îÇ   ‚îú‚îÄ‚îÄ Interceptors
‚îÇ   ‚îú‚îÄ‚îÄ Automatic Token Refresh
‚îÇ   ‚îú‚îÄ‚îÄ Request Retry Logic
‚îÇ   ‚îî‚îÄ‚îÄ Centralized Error Handling
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° Advanced JavaScript
‚îÇ   ‚îú‚îÄ‚îÄ Proxy & Reflect API
‚îÇ   ‚îú‚îÄ‚îÄ WebAssembly Use Cases
‚îÇ   ‚îú‚îÄ‚îÄ Internationalization API (Intl)
‚îÇ   ‚îú‚îÄ‚îÄ JavaScript Decorators
‚îÇ   ‚îú‚îÄ‚îÄ BigInt Handling
‚îÇ   ‚îú‚îÄ‚îÄ WeakRefs
‚îÇ   ‚îî‚îÄ‚îÄ Web Cryptography API
‚îÇ
‚îî‚îÄ‚îÄ üèóÔ∏è System Design
    ‚îú‚îÄ‚îÄ Large App Structure
    ‚îú‚îÄ‚îÄ Clean Code Principles
    ‚îú‚îÄ‚îÄ State Management in Large Apps
    ‚îú‚îÄ‚îÄ Microfrontends
    ‚îú‚îÄ‚îÄ Caching Strategies
    ‚îú‚îÄ‚îÄ API Design Best Practices
    ‚îú‚îÄ‚îÄ Authentication & Authorization
    ‚îú‚îÄ‚îÄ Feature Flags
    ‚îî‚îÄ‚îÄ A/B Testing Implementation
