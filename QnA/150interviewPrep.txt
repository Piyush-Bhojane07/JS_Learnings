üî∑ JavaScript (50 Questions)
Core Concepts
What is the difference between let, const, and var?

var, let, and const - Complete Explanation
1. var (Function-Scoped)
javascript
// 1. FUNCTION SCOPE
function testVar() {
    var x = 10;
    if (true) {
        var x = 20; // Same variable!
        console.log(x); // 20
    }
    console.log(x); // 20 (not 10!)
}
testVar();

// 2. HOISTING
console.log(y); // undefined (not ReferenceError)
var y = 5;
console.log(y); // 5

// The above is interpreted as:
var y;
console.log(y); // undefined
y = 5;
console.log(y); // 5

// 3. RE-DECLARATION ALLOWED
var z = 10;
var z = 20; // No error
console.log(z); // 20
2. let (Block-Scoped)
javascript
// 1. BLOCK SCOPE
function testLet() {
    let x = 10;
    if (true) {
        let x = 20; // Different variable!
        console.log(x); // 20
    }
    console.log(x); // 10 (not affected by inner block)
}
testLet();

// 2. HOISTING (Temporal Dead Zone)
// console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 5;
console.log(a); // 5

// 3. NO RE-DECLARATION IN SAME SCOPE
let b = 10;
// let b = 20; // SyntaxError: Identifier 'b' has already been declared

// But different scopes are fine
let c = 10;
if (true) {
    let c = 20; // Different scope - no error
    console.log(c); // 20
}
console.log(c); // 10
3. const (Block-Scoped + Constant)
javascript
// 1. MUST BE INITIALIZED
// const PI; // SyntaxError: Missing initializer in const declaration
const PI = 3.14159;

// 2. CANNOT REASSIGN PRIMITIVE VALUES
const MAX_SIZE = 100;
// MAX_SIZE = 200; // TypeError: Assignment to constant variable

// 3. BUT OBJECTS/ARRAYS ARE MUTABLE!
const person = { name: "John", age: 30 };
person.age = 31; // ‚úÖ This is allowed!
console.log(person); // { name: "John", age: 31 }

// But you cannot reassign the entire object
// person = { name: "Jane" }; // TypeError: Assignment to constant variable

const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ This is allowed!
console.log(numbers); // [1, 2, 3, 4]

// numbers = [5, 6, 7]; // TypeError: Assignment to constant variable
üìä Comparison Table
Feature	var	let	const
Scope	Function	Block	Block
Hoisting	Yes (initialized as undefined)	Yes (TDZ - cannot access before declaration)	Yes (TDZ - cannot access before declaration)
Re-declaration	‚úÖ Allowed	‚ùå Not allowed	‚ùå Not allowed
Re-assignment	‚úÖ Allowed	‚úÖ Allowed	‚ùå Not allowed (for primitives)
Temporal Dead Zone	‚ùå No	‚úÖ Yes	‚úÖ Yes
üîç Real-World Examples
React Native Example:
javascript
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';

const UserProfile = () => {
    // ‚úÖ Good - use const for state since we don't reassign the setter
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        // ‚úÖ Good - use let for values that might change
        let isMounted = true;
        
        const fetchUser = async () => {
            try {
                // ‚úÖ Good - const for API responses
                const response = await fetch('/api/user');
                const userData = await response.json();
                
                if (isMounted) {
                    setUser(userData);
                    setLoading(false);
                }
            } catch (error) {
                // ‚úÖ Good - const for error objects
                const errorMessage = error.message;
                console.error(errorMessage);
            }
        };
        
        fetchUser();
        
        return () => {
            isMounted = false; // ‚úÖ let allows reassignment for cleanup
        };
    }, []);
    
    // ‚ùå Bad - this would cause issues
    // var count = 0; // Function-scoped, could cause bugs
    
    // ‚úÖ Good
    let count = 0; // Block-scoped, safer
    
    if (loading) {
        count = 1; // Reassignment is fine with let
        return <Text>Loading...</Text>;
    }
    
    return (
        <View>
            <Text>Welcome, {user.name}!</Text>
        </View>
    );
};
Common Patterns:
javascript
// ‚úÖ Use const by default
const API_URL = 'https://api.example.com';
const DEFAULT_CONFIG = { timeout: 5000 };

// ‚úÖ Use let when you need to reassign
let retryCount = 0;
let isLoading = false;

// ‚ùå Avoid var in modern code
// var oldVariable = "don't use this";

// Loop examples
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100); // 0, 1, 2, 3, 4
}

// With var it would be different:
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 100); // 5, 5, 5, 5, 5
}
üéØ Interview Answer Summary:
"The main differences are:

var is function-scoped and hoisted with undefined initialization

let and const are block-scoped and hoisted but cannot be accessed before declaration (Temporal Dead Zone)

let allows reassignment, const does not (though objects/arrays are still mutable)

In modern development, use const by default and let when you need reassignment. Avoid var."
-------------------------------------------------

Explain JavaScript's event loop
JavaScript Event Loop - Complete Explanation
The Event Loop is JavaScript's concurrency model that enables non-blocking I/O operations despite JavaScript being single-threaded.

üîÑ Core Components
javascript
// Visualizing the Event Loop Architecture
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Call Stack         ‚îÇ  <- Functions currently executing
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Web APIs           ‚îÇ  <- Browser/Runtime APIs (setTimeout, fetch, etc.)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Callback Queue (Task)   ‚îÇ  <- setTimeout, setInterval, I/O callbacks
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Microtask Queue          ‚îÇ  <- Promises, queueMicrotask, MutationObserver
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Event Loop            ‚îÇ  <- Coordinates everything
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
üìù How It Works - Step by Step
1. Basic Example
javascript
console.log('1 - Start');

setTimeout(() => {
    console.log('2 - Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('3 - Promise callback');
});

console.log('4 - End');

// Output:
// 1 - Start
// 4 - End
// 3 - Promise callback
// 2 - Timeout callback
2. Detailed Execution Flow
javascript
function main() {
    console.log('A');
    
    setTimeout(() => {
        console.log('B - Timeout');
    }, 0);
    
    Promise.resolve().then(() => {
        console.log('C - Promise');
    });
    
    console.log('D');
}

main();
console.log('E');

/*
EXECUTION STEPS:
1. Call Stack: [main]
   - Log: "A"
   - setTimeout ‚Üí Web API
   - Promise.then ‚Üí Microtask Queue
   - Log: "D"
   - main() pops from stack

2. Call Stack: [ ]
   - Log: "E"

3. Call Stack empty ‚Üí Check Microtask Queue
   - Execute Promise callback
   - Log: "C - Promise"

4. Call Stack empty ‚Üí Check Callback Queue
   - Execute setTimeout callback
   - Log: "B - Timeout"
*/
üéØ Queue Priority System
Priority Order:
Call Stack (synchronous code)

Microtask Queue (Promises, queueMicrotask)

Callback Queue (setTimeout, setInterval, I/O)

javascript
console.log('Script start');

// Macro-task (Callback Queue)
setTimeout(() => {
    console.log('setTimeout');
}, 0);

// Micro-task (Microtask Queue)
Promise.resolve().then(() => {
    console.log('Promise 1');
});

// Another Micro-task
queueMicrotask(() => {
    console.log('queueMicrotask');
});

// Synchronous code
console.log('Script end');

/*
OUTPUT:
Script start
Script end
Promise 1          ‚Üê Microtask (higher priority)
queueMicrotask     ‚Üê Microtask
setTimeout         ‚Üê Macro-task (lower priority)
*/
üî• Advanced Examples
Example 1: Nested Promises & Timeouts
javascript
console.log('Start');

setTimeout(() => console.log('Timeout 1'), 0);

Promise.resolve()
    .then(() => {
        console.log('Promise 1');
        return Promise.resolve();
    })
    .then(() => {
        console.log('Promise 2');
        setTimeout(() => {
            console.log('Timeout from Promise');
        }, 0);
    });

setTimeout(() => console.log('Timeout 2'), 0);

console.log('End');

/*
OUTPUT:
Start
End
Promise 1
Promise 2
Timeout 1
Timeout 2
Timeout from Promise
*/
Example 2: Microtasks Blocking the Event Loop
javascript
console.log('Start');

// This microtask will block the event loop until complete
Promise.resolve().then(() => {
    console.log('Microtask 1 start');
    // Long synchronous operation
    for (let i = 0; i < 1000000000; i++) {} // Blocking!
    console.log('Microtask 1 end');
});

setTimeout(() => {
    console.log('Timeout - delayed by microtask');
}, 0);

console.log('End');

/*
OUTPUT:
Start
End
Microtask 1 start
... (long delay) ...
Microtask 1 end
Timeout - delayed by microtask
*/
Example 3: Real-world Async Operations
javascript
// Simulating API calls and user interactions
function fetchUserData() {
    console.log('1. Starting API call...');
    
    // This goes to Web API, then Callback Queue
    setTimeout(() => {
        console.log('4. API Response received');
        
        // Promise goes to Microtask Queue
        Promise.resolve().then(() => {
            console.log('5. Processing response data');
        });
    }, 1000);
    
    // This goes to Microtask Queue immediately
    Promise.resolve().then(() => {
        console.log('2. Setting up UI');
    });
}

console.log('0. App started');
fetchUserData();
console.log('3. Waiting for data...');

/*
OUTPUT:
0. App started
1. Starting API call...
3. Waiting for data...
2. Setting up UI
4. API Response received
5. Processing response data
*/
‚ö° React Native Specific Examples
Example 1: Network Requests in React Native
javascript
import { useState, useEffect } from 'react';

const UserComponent = () => {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        console.log('1. Effect started');
        
        // Macro-task - goes to Web API
        const timeoutId = setTimeout(() => {
            console.log('4. Timeout - simulating debounce');
        }, 1000);
        
        // Micro-task - higher priority
        Promise.resolve().then(() => {
            console.log('2. Setting initial state');
            setUser({ name: 'Loading...' });
        });
        
        // Async function execution
        const fetchData = async () => {
            console.log('3. Starting fetch...');
            
            try {
                // fetch goes to Web API
                const response = await fetch('/api/user');
                // await puts the rest in Microtask Queue
                const data = await response.json();
                
                console.log('5. Data received');
                setUser(data);
            } catch (error) {
                console.log('5. Error handling');
            }
        };
        
        fetchData();
        
        console.log('6. Effect setup complete');
        
        return () => {
            clearTimeout(timeoutId);
            console.log('Cleanup');
        };
    }, []);
    
    return null;
};

/*
OUTPUT:
1. Effect started
6. Effect setup complete
2. Setting initial state
3. Starting fetch...
5. Data received (or Error handling)
4. Timeout - simulating debounce
*/
Example 2: Animation and State Updates
javascript
const handleButtonPress = () => {
    console.log('1. Button pressed');
    
    // State update (React batches these in microtasks)
    setLoading(true);
    
    // Macro-task - animation frame
    requestAnimationFrame(() => {
        console.log('4. Animation frame');
    });
    
    // Micro-task - Promise
    Promise.resolve().then(() => {
        console.log('3. State updated, UI re-rendered');
    });
    
    // Macro-task - timeout
    setTimeout(() => {
        console.log('5. Timeout completed');
        setLoading(false);
    }, 1000);
    
    console.log('2. Event handler finished');
};

/*
OUTPUT:
1. Button pressed
2. Event handler finished
3. State updated, UI re-rendered
4. Animation frame
5. Timeout completed
*/
üéØ Interview Answer Summary
"The Event Loop is JavaScript's mechanism for handling asynchronous operations. It consists of:

Call Stack - Executes synchronous code

Web APIs - Browser-provided async functions (setTimeout, fetch)

Callback Queue - Holds macro-tasks (setTimeout, setInterval, I/O)

Microtask Queue - Holds micro-tasks (Promises, queueMicrotask)

The Event Loop constantly checks:

First: Is Call Stack empty?

Second: Execute all Microtasks

Third: Execute one Macro-task

Repeat

This ensures non-blocking execution while maintaining single-threaded semantics."

üí° Key Takeaways for Interview:
Microtasks have higher priority than Macrotasks

Promises execute before setTimeout, even with 0 delay

Async/Await uses Promises (microtasks)

Heavy microtasks can block the event loop

Understanding this helps debug tricky timing issues
--------------------------------------------------------

What is hoisting in JavaScript?
JavaScript Hoisting - Complete Explanation
Hoisting is JavaScript's behavior of moving declarations to the top of their scope during the compilation phase, before code execution.

üìù Types of Hoisting
1. var Hoisting
javascript
// Example 1: Basic var hoisting
console.log(name); // undefined (not ReferenceError)
var name = 'John';
console.log(name); // 'John'

// How JavaScript interprets it:
var name;          // Declaration hoisted (initialized as undefined)
console.log(name); // undefined
name = 'John';     // Assignment remains in place
console.log(name); // 'John'
2. let and const Hoisting (Temporal Dead Zone)
javascript
// Example 2: let/const hoisting with TDZ
console.log(age); // ReferenceError: Cannot access 'age' before initialization
let age = 25;

// How JavaScript interprets it:
let age;          // Declaration hoisted BUT not initialized
console.log(age); // ‚ùå Throws error - Temporal Dead Zone
age = 25;         // Assignment

// Same for const
console.log(PI); // ReferenceError
const PI = 3.14;
3. Function Hoisting
javascript
// Example 3: Function declarations are fully hoisted
sayHello(); // "Hello!" - works fine

function sayHello() {
    console.log("Hello!");
}

// How JavaScript interprets it:
function sayHello() {  // Entire function is hoisted
    console.log("Hello!");
}
sayHello(); // Works!
4. Function Expressions Hoisting
javascript
// Example 4: Function expressions follow variable hoisting rules
// Function expression with var
sayHi(); // TypeError: sayHi is not a function
var sayHi = function() {
    console.log("Hi!");
};

// How JavaScript interprets it:
var sayHi;            // undefined
sayHi();              // ‚ùå TypeError - trying to call undefined
sayHi = function() {  // Assignment
    console.log("Hi!");
};

// Function expression with let/const
sayBye(); // ReferenceError: Cannot access 'sayBye' before initialization
const sayBye = function() {
    console.log("Bye!");
};
üî• Advanced Hoisting Scenarios
Example 1: Mixed Declarations
javascript
var x = 1;
function test() {
    console.log(x); // undefined (not 1!)
    var x = 2;
    console.log(x); // 2
}
test();

// How JavaScript interprets it:
var x = 1;
function test() {
    var x;          // Declaration hoisted to top of function
    console.log(x); // undefined (local variable shadows global)
    x = 2;          // Assignment
    console.log(x); // 2
}
test();
Example 2: Functions vs Variables
javascript
// Scenario 1: Function declaration vs var
console.log(typeof myFunc); // "function" - function wins

var myFunc = "I'm a variable";
function myFunc() {
    return "I'm a function";
}

console.log(typeof myFunc); // "string" - variable assignment wins

// How JavaScript interprets it:
function myFunc() {         // Function hoisted first
    return "I'm a function";
}
var myFunc;                 // var declaration (ignored since name exists)
console.log(typeof myFunc); // "function"
myFunc = "I'm a variable";  // Assignment
console.log(typeof myFunc); // "string"
Example 3: Multiple Declarations
javascript
var a = 10;
function hoistTest() {
    console.log(a); // undefined
    if (false) {
        var a = 20; // Still hoisted even though block never executes!
    }
    console.log(a); // undefined
}
hoistTest();

// How JavaScript interprets it:
var a = 10;
function hoistTest() {
    var a;          // Hoisted to top of function (initialized as undefined)
    console.log(a); // undefined
    if (false) {
        a = 20;     // Never executes
    }
    console.log(a); // undefined
}
hoistTest();
Example 4: Class Hoisting
javascript
// Classes are NOT hoisted like functions
const person = new Person(); // ReferenceError: Cannot access 'Person' before initialization

class Person {
    constructor(name) {
        this.name = name;
    }
}

// This works:
const Person = class { /* ... */ };
const person = new Person(); // OK - but this is different syntax
‚ö° Real-World React Native Examples
Example 1: Component Function Hoisting
javascript
import React from 'react';
import { View, Text } from 'react-native';

// ‚úÖ Function declarations are hoisted - can call before definition
const App = () => {
    return (
        <View>
            <WelcomeMessage />  {/* Works due to hoisting */}
            <UserProfile />
        </View>
    );
};

// Function declaration - hoisted
function WelcomeMessage() {
    return <Text>Welcome to our app!</Text>;
}

// Function expression - not hoisted (if using const/let)
const UserProfile = () => {
    return <Text>User Profile</Text>;
};

// ‚ùå This would cause issues:
const AnotherComponent = () => {
    return (
        <View>
            <NonHoistedComponent /> {/* ReferenceError if using const/let */}
        </View>
    );
};

const NonHoistedComponent = () => <Text>Not hoisted</Text>;
Example 2: Hook Usage and Hoisting
javascript
import { useState, useEffect } from 'react';

// ‚úÖ Correct - hooks at top level, functions can be called later
function UserContainer() {
    const [user, setUser] = useState(null);
    
    // useEffect can call functions defined later
    useEffect(() => {
        fetchUserData();
    }, []);
    
    // Function declaration - hoisted, so useEffect can call it
    function fetchUserData() {
        fetch('/api/user')
            .then(response => response.json())
            .then(data => setUser(data));
    }
    
    return <UserDisplay user={user} />;
}

// ‚ùå Problematic - function expression with const
function ProblematicComponent() {
    const [data, setData] = useState(null);
    
    useEffect(() => {
        fetchData(); // ReferenceError!
    }, []);
    
    const fetchData = () => {  // Not hoisted
        // fetch logic
    };
    
    return null;
}
Example 3: Import Hoisting Behavior
javascript
// In React Native, imports are effectively "hoisted"
import React, { useState } from 'react';
import { View, Text } from 'react-native';

// All imports are available throughout the module
const Component = () => {
    const [state, setState] = useState(); // useState available everywhere
    
    return (
        <View>
            <Text>Hello</Text>
        </View>
    );
};
üéØ Hoisting Rules Summary
Declaration Type	Hoisting Behavior	Initial Value	Temporal Dead Zone
var	‚úÖ Hoisted	undefined	‚ùå No
let	‚úÖ Hoisted	Not initialized	‚úÖ Yes
const	‚úÖ Hoisted	Not initialized	‚úÖ Yes
function	‚úÖ Hoisted	Function itself	‚ùå No
function expression (with var)	‚úÖ Hoisted	undefined	‚ùå No
function expression (with let/const)	‚úÖ Hoisted	Not initialized	‚úÖ Yes
class	‚ùå Not hoisted	-	‚úÖ Yes
üí° Best Practices for Modern JavaScript
‚úÖ DO:
javascript
// Use const/let and declare at the top
const initializeApp = () => {
    const user = getUser();
    const config = loadConfig();
    
    // Use functions
    return renderUI(user, config);
};

// Function declarations are fine for utilities
function getUser() {
    return { name: 'John' };
}

function renderUI(user, config) {
    // rendering logic
}
‚ùå DON'T:
javascript
// Avoid relying on var hoisting
function problematicFunction() {
    console.log(value); // undefined - confusing!
    processData();      // Might work or might not
    
    var value = 10;
    var processData = function() {
        // logic
    };
}
üéØ Interview Answer Summary
"Hoisting is JavaScript's mechanism where variable and function declarations are moved to the top of their containing scope during compilation.

Key points:

var declarations are hoisted and initialized with undefined

let/const declarations are hoisted but not initialized (Temporal Dead Zone)

Function declarations are fully hoisted with their definition

Function expressions follow variable hoisting rules

Classes are not hoisted

In practice, we use const/let and declare variables at the top to avoid confusion with hoisting behavior."
--------------------------------------------------------------


Difference between null and undefined
In JavaScript, null and undefined are both primitive values that represent ‚Äúnothing‚Äù or ‚Äúno value,‚Äù but they are not the same.

Here‚Äôs a clear breakdown üëá

Feature	undefined	null
Meaning	A variable has been declared but not assigned a value.	A variable has been explicitly assigned ‚Äúno value.‚Äù
Type	"undefined"	"object" (this is actually a historical bug in JavaScript)
Default value	Default for uninitialized variables, missing function parameters, and missing object properties.	Not a default ‚Äî must be explicitly set by the programmer.
Example	js\nlet a;\nconsole.log(a); // undefined\n	js\nlet b = null;\nconsole.log(b); // null\n
Comparison (==)	null == undefined ‚Üí true	
Strict comparison (===)	null === undefined ‚Üí false	
Typical use case	Indicates a variable or property hasn‚Äôt been assigned a value yet.	Indicates intentional absence of a value (like ‚Äúnothing here‚Äù).
Example:
let x;
let y = null;

console.log(x);        // undefined (no value assigned)
console.log(y);        // null (explicitly set to "no value")

console.log(x == y);   // true  (loose equality)
console.log(x === y);  // false (strict equality)

Summary:

Use undefined when a variable is not initialized.

Use null when you intentionally want to represent ‚Äúno value.‚Äù
-------------------------------------------------


What are closures and provide an example?
You said:
in simpl words with basic example
You said:
function greet() {
  let name = "Alice";

  function sayHello() {
    console.log("Hello " + name);
  }

  return sayHello;
}
//why greet method not called at below ine
const hello = greet(); 
hello(); // prints "Hello Alice"
You said:
do explaning in code itselft
------------------------------------------------------

Explain the this keyword in different contexts

What is the difference between == and ===?

How does JavaScript handle asynchronous operations?

What are arrow functions and how do they differ from regular functions?

Explain call, apply, and bind methods

ES6+ Features
What are template literals?

Explain destructuring assignment

What are default parameters?

Explain the spread and rest operators

What are Promises and how do they work?

Explain async/await syntax

What are JavaScript modules (import/export)?

What are Map and Set objects?

Explain Object.keys(), Object.values(), Object.entries()

What are generators and how do they work?

Advanced Concepts
What is the prototype chain?

Explain event delegation

What is currying in JavaScript?

Difference between deep copy and shallow copy

How does setTimeout and setInterval work?

What is memoization and provide an example?

Explain JavaScript's memory management

What are Web Workers?

Explain the Module Pattern

What is the Revealing Module Pattern?

Array Methods
Difference between map, filter, and reduce

When would you use forEach vs map?

Explain some and every array methods

What does Array.prototype.flat() do?

How does Array.prototype.find() work?

Explain Array.prototype.includes() vs Array.prototype.indexOf()

What is the purpose of Array.prototype.splice()?

How to remove duplicates from an array?

Explain Array.prototype.sort() method

How to flatten a nested array?

Object & Functions
How to check if an object is empty?

Difference between Object.create() and constructor functions

What are getters and setters?

Explain function composition

What are higher-order functions?

How to merge two objects in JavaScript?

What is method chaining?

Explain the Factory Pattern

What is the Singleton Pattern?

How to prevent object modification?

‚öõÔ∏è React Native (50 Questions)
Core Concepts
What is React Native and how is it different from React?

Explain the bridge architecture in React Native

Difference between React Native and Flutter

What are the main components in React Native?

How does React Native communicate with native modules?

What is the difference between View and ScrollView?

When would you use FlatList vs ScrollView?

Explain the VirtualizedList component

What is the purpose of SafeAreaView?

How do you handle different screen sizes in React Native?

Components & APIs
Difference between TextInput and Text components

How do you handle touch events in React Native?

Explain the TouchableOpacity component

What is the ActivityIndicator component used for?

How do you implement pull-to-refresh?

Explain the Modal component

What is StatusBar and how do you customize it?

How to use the Alert API?

Explain the KeyboardAvoidingView component

How to handle device orientation changes?

Navigation
What are the main navigation libraries in React Native?

How do you implement stack navigation?

Explain tab navigation implementation

How to pass parameters between screens?

What is deep linking in React Native?

How to handle authentication flow with navigation?

Explain navigation lifecycle methods

How to prevent going back to a specific screen?

What is the purpose of navigationRef?

How to handle conditional navigation?

Performance & Optimization
How do you optimize React Native app performance?

What is Hermes and what are its benefits?

How to reduce bundle size in React Native?

Explain the useMemo hook in React Native context

When to use useCallback in React Native?

How to implement lazy loading of components?

What are the common performance bottlenecks?

How to use the Performance API?

Explain how to debug React Native apps

What is Flipper and how is it used?

Native Modules & Deployment
How do you create a native module?

What is CodePush and how does it work?

Explain the difference between development and production builds

How to handle different environments (dev, staging, prod)?

What are the app store submission requirements?

How to handle versioning in React Native apps?

What is Fastlane and how is it used?

How to implement in-app purchases?

Explain push notification implementation

How to handle deep linking in React Native?

üé® Styling (20 Questions)
Core Styling
What are the different ways to style React Native components?

Difference between inline styles and StyleSheet API

How does Flexbox work in React Native?

Explain the main Flexbox properties

How to handle responsive design in React Native?

What is the difference between width: '100%' and flex: 1?

How to implement dark/light theme?

What are styled-components and how to use them in RN?

How to handle platform-specific styles?

Explain the transform property in React Native

Advanced Styling
How to create custom animations?

What is the LayoutAnimation API?

How to use the Animated API?

Difference between Animated.timing and Animated.spring

How to create gradient backgrounds?

What is react-native-vector-icons and how to use it?

How to handle text overflow and ellipsis?

Explain zIndex and stacking context in React Native

How to create shadow effects on both iOS and Android?

What is the PixelRatio API and when to use it?

üóÉÔ∏è Redux (30 Questions)
Core Concepts
What is Redux and why is it used?

Explain the three principles of Redux

What are actions in Redux?

What are reducers and how do they work?

What is the Redux store?

Explain the Redux data flow

What is the difference between Redux and Context API?

When should you use Redux vs local state?

What are action creators?

How to handle asynchronous actions in Redux?

Middleware & Async
What is Redux Thunk and how does it work?

How is Redux Saga different from Redux Thunk?

What are Redux middleware and how do they work?

How to implement custom middleware?

Explain the applyMiddleware function

How to handle side effects in Redux?

What is redux-persist and how to use it?

How to implement optimistic updates in Redux?

What is normalizing state shape?

How to handle errors in Redux?

React-Redux & Tools
What is the connect function in react-redux?

How to use the useSelector hook?

How to use the useDispatch hook?

What is the purpose of the Provider component?

How to structure a Redux application?

What is Redux Toolkit and why is it recommended?

Explain createSlice in Redux Toolkit

What is createAsyncThunk and how to use it?

How to use Redux DevTools?

How to implement code splitting with Redux?

üîÑ TanStack Query (20 Questions)
Core Concepts
What is TanStack Query and what problems does it solve?

How is TanStack Query different from Redux?

Explain the main concepts of TanStack Query

What are query keys and how are they used?

How does caching work in TanStack Query?

What is stale time vs cache time?

How to handle pagination with TanStack Query?

Explain infinite queries

How to implement prefetching?

What is background fetching and how does it work?

Advanced Features
How to handle mutations with useMutation?

What are query invalidation strategies?

How to implement optimistic updates?

What is the QueryClient and its responsibilities?

How to handle errors in TanStack Query?

What are query retries and how to configure them?

How to implement dependent queries?

What is the useQueries hook used for?

How to handle offline support?

How to test components that use TanStack Query?

üéØ Quick Preparation Tips:
For JavaScript:

Practice array methods and async/await patterns

Understand closure and this keyword thoroughly

Be ready to write code snippets

For React Native:

Focus on performance optimization techniques

Know navigation patterns thoroughly

Understand native module integration

For State Management:

Compare different state management solutions

Understand when to use each tool

Be prepared to discuss trade-offs

General Tips:

Practice explaining concepts in simple terms

Have real project examples ready

Be honest about what you don't know

Show enthusiasm for learning

Good luck with your interview! Remember to relate answers to your 1-year experience with specific examples from your projects. üöÄ