üî∑ JavaScript (50 Questions)
Core Concepts
What is the difference between let, const, and var?

var, let, and const - Complete Explanation
1. var (Function-Scoped)
javascript
// 1. FUNCTION SCOPE
function testVar() {
    var x = 10;
    if (true) {
        var x = 20; // Same variable!
        console.log(x); // 20
    }
    console.log(x); // 20 (not 10!)
}
testVar();

// 2. HOISTING
console.log(y); // undefined (not ReferenceError)
var y = 5;
console.log(y); // 5

// The above is interpreted as:
var y;
console.log(y); // undefined
y = 5;
console.log(y); // 5

// 3. RE-DECLARATION ALLOWED
var z = 10;
var z = 20; // No error
console.log(z); // 20
2. let (Block-Scoped)
javascript
// 1. BLOCK SCOPE
function testLet() {
    let x = 10;
    if (true) {
        let x = 20; // Different variable!
        console.log(x); // 20
    }
    console.log(x); // 10 (not affected by inner block)
}
testLet();

// 2. HOISTING (Temporal Dead Zone)
// console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 5;
console.log(a); // 5

// 3. NO RE-DECLARATION IN SAME SCOPE
let b = 10;
// let b = 20; // SyntaxError: Identifier 'b' has already been declared

// But different scopes are fine
let c = 10;
if (true) {
    let c = 20; // Different scope - no error
    console.log(c); // 20
}
console.log(c); // 10
3. const (Block-Scoped + Constant)
javascript
// 1. MUST BE INITIALIZED
// const PI; // SyntaxError: Missing initializer in const declaration
const PI = 3.14159;

// 2. CANNOT REASSIGN PRIMITIVE VALUES
const MAX_SIZE = 100;
// MAX_SIZE = 200; // TypeError: Assignment to constant variable

// 3. BUT OBJECTS/ARRAYS ARE MUTABLE!
const person = { name: "John", age: 30 };
person.age = 31; // ‚úÖ This is allowed!
console.log(person); // { name: "John", age: 31 }

// But you cannot reassign the entire object
// person = { name: "Jane" }; // TypeError: Assignment to constant variable

const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ This is allowed!
console.log(numbers); // [1, 2, 3, 4]

// numbers = [5, 6, 7]; // TypeError: Assignment to constant variable
üìä Comparison Table
Feature	var	let	const
Scope	Function	Block	Block
Hoisting	Yes (initialized as undefined)	Yes (TDZ - cannot access before declaration)	Yes (TDZ - cannot access before declaration)
Re-declaration	‚úÖ Allowed	‚ùå Not allowed	‚ùå Not allowed
Re-assignment	‚úÖ Allowed	‚úÖ Allowed	‚ùå Not allowed (for primitives)
Temporal Dead Zone	‚ùå No	‚úÖ Yes	‚úÖ Yes
üîç Real-World Examples
React Native Example:
javascript
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';

const UserProfile = () => {
    // ‚úÖ Good - use const for state since we don't reassign the setter
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        // ‚úÖ Good - use let for values that might change
        let isMounted = true;
        
        const fetchUser = async () => {
            try {
                // ‚úÖ Good - const for API responses
                const response = await fetch('/api/user');
                const userData = await response.json();
                
                if (isMounted) {
                    setUser(userData);
                    setLoading(false);
                }
            } catch (error) {
                // ‚úÖ Good - const for error objects
                const errorMessage = error.message;
                console.error(errorMessage);
            }
        };
        
        fetchUser();
        
        return () => {
            isMounted = false; // ‚úÖ let allows reassignment for cleanup
        };
    }, []);
    
    // ‚ùå Bad - this would cause issues
    // var count = 0; // Function-scoped, could cause bugs
    
    // ‚úÖ Good
    let count = 0; // Block-scoped, safer
    
    if (loading) {
        count = 1; // Reassignment is fine with let
        return <Text>Loading...</Text>;
    }
    
    return (
        <View>
            <Text>Welcome, {user.name}!</Text>
        </View>
    );
};
Common Patterns:
javascript
// ‚úÖ Use const by default
const API_URL = 'https://api.example.com';
const DEFAULT_CONFIG = { timeout: 5000 };

// ‚úÖ Use let when you need to reassign
let retryCount = 0;
let isLoading = false;

// ‚ùå Avoid var in modern code
// var oldVariable = "don't use this";

// Loop examples
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100); // 0, 1, 2, 3, 4
}

// With var it would be different:
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 100); // 5, 5, 5, 5, 5
}
üéØ Interview Answer Summary:
"The main differences are:

var is function-scoped and hoisted with undefined initialization

let and const are block-scoped and hoisted but cannot be accessed before declaration (Temporal Dead Zone)

let allows reassignment, const does not (though objects/arrays are still mutable)

In modern development, use const by default and let when you need reassignment. Avoid var."
-------------------------------------------------

Explain JavaScript's event loop
JavaScript Event Loop - Complete Explanation
The Event Loop is JavaScript's concurrency model that enables non-blocking I/O operations despite JavaScript being single-threaded.

üîÑ Core Components
javascript
// Visualizing the Event Loop Architecture
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Call Stack         ‚îÇ  <- Functions currently executing
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Web APIs           ‚îÇ  <- Browser/Runtime APIs (setTimeout, fetch, etc.)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Callback Queue (Task)   ‚îÇ  <- setTimeout, setInterval, I/O callbacks
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Microtask Queue          ‚îÇ  <- Promises, queueMicrotask, MutationObserver
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Event Loop            ‚îÇ  <- Coordinates everything
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
üìù How It Works - Step by Step
1. Basic Example
javascript
console.log('1 - Start');

setTimeout(() => {
    console.log('2 - Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('3 - Promise callback');
});

console.log('4 - End');

// Output:
// 1 - Start
// 4 - End
// 3 - Promise callback
// 2 - Timeout callback
2. Detailed Execution Flow
javascript
function main() {
    console.log('A');
    
    setTimeout(() => {
        console.log('B - Timeout');
    }, 0);
    
    Promise.resolve().then(() => {
        console.log('C - Promise');
    });
    
    console.log('D');
}

main();
console.log('E');

/*
EXECUTION STEPS:
1. Call Stack: [main]
   - Log: "A"
   - setTimeout ‚Üí Web API
   - Promise.then ‚Üí Microtask Queue
   - Log: "D"
   - main() pops from stack

2. Call Stack: [ ]
   - Log: "E"

3. Call Stack empty ‚Üí Check Microtask Queue
   - Execute Promise callback
   - Log: "C - Promise"

4. Call Stack empty ‚Üí Check Callback Queue
   - Execute setTimeout callback
   - Log: "B - Timeout"
*/
üéØ Queue Priority System
Priority Order:
Call Stack (synchronous code)

Microtask Queue (Promises, queueMicrotask)

Callback Queue (setTimeout, setInterval, I/O)

javascript
console.log('Script start');

// Macro-task (Callback Queue)
setTimeout(() => {
    console.log('setTimeout');
}, 0);

// Micro-task (Microtask Queue)
Promise.resolve().then(() => {
    console.log('Promise 1');
});

// Another Micro-task
queueMicrotask(() => {
    console.log('queueMicrotask');
});

// Synchronous code
console.log('Script end');

/*
OUTPUT:
Script start
Script end
Promise 1          ‚Üê Microtask (higher priority)
queueMicrotask     ‚Üê Microtask
setTimeout         ‚Üê Macro-task (lower priority)
*/
üî• Advanced Examples
Example 1: Nested Promises & Timeouts
javascript
console.log('Start');

setTimeout(() => console.log('Timeout 1'), 0);

Promise.resolve()
    .then(() => {
        console.log('Promise 1');
        return Promise.resolve();
    })
    .then(() => {
        console.log('Promise 2');
        setTimeout(() => {
            console.log('Timeout from Promise');
        }, 0);
    });

setTimeout(() => console.log('Timeout 2'), 0);

console.log('End');

/*
OUTPUT:
Start
End
Promise 1
Promise 2
Timeout 1
Timeout 2
Timeout from Promise
*/
Example 2: Microtasks Blocking the Event Loop
javascript
console.log('Start');

// This microtask will block the event loop until complete
Promise.resolve().then(() => {
    console.log('Microtask 1 start');
    // Long synchronous operation
    for (let i = 0; i < 1000000000; i++) {} // Blocking!
    console.log('Microtask 1 end');
});

setTimeout(() => {
    console.log('Timeout - delayed by microtask');
}, 0);

console.log('End');

/*
OUTPUT:
Start
End
Microtask 1 start
... (long delay) ...
Microtask 1 end
Timeout - delayed by microtask
*/
Example 3: Real-world Async Operations
javascript
// Simulating API calls and user interactions
function fetchUserData() {
    console.log('1. Starting API call...');
    
    // This goes to Web API, then Callback Queue
    setTimeout(() => {
        console.log('4. API Response received');
        
        // Promise goes to Microtask Queue
        Promise.resolve().then(() => {
            console.log('5. Processing response data');
        });
    }, 1000);
    
    // This goes to Microtask Queue immediately
    Promise.resolve().then(() => {
        console.log('2. Setting up UI');
    });
}

console.log('0. App started');
fetchUserData();
console.log('3. Waiting for data...');

/*
OUTPUT:
0. App started
1. Starting API call...
3. Waiting for data...
2. Setting up UI
4. API Response received
5. Processing response data
*/
‚ö° React Native Specific Examples
Example 1: Network Requests in React Native
javascript
import { useState, useEffect } from 'react';

const UserComponent = () => {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        console.log('1. Effect started');
        
        // Macro-task - goes to Web API
        const timeoutId = setTimeout(() => {
            console.log('4. Timeout - simulating debounce');
        }, 1000);
        
        // Micro-task - higher priority
        Promise.resolve().then(() => {
            console.log('2. Setting initial state');
            setUser({ name: 'Loading...' });
        });
        
        // Async function execution
        const fetchData = async () => {
            console.log('3. Starting fetch...');
            
            try {
                // fetch goes to Web API
                const response = await fetch('/api/user');
                // await puts the rest in Microtask Queue
                const data = await response.json();
                
                console.log('5. Data received');
                setUser(data);
            } catch (error) {
                console.log('5. Error handling');
            }
        };
        
        fetchData();
        
        console.log('6. Effect setup complete');
        
        return () => {
            clearTimeout(timeoutId);
            console.log('Cleanup');
        };
    }, []);
    
    return null;
};

/*
OUTPUT:
1. Effect started
6. Effect setup complete
2. Setting initial state
3. Starting fetch...
5. Data received (or Error handling)
4. Timeout - simulating debounce
*/
Example 2: Animation and State Updates
javascript
const handleButtonPress = () => {
    console.log('1. Button pressed');
    
    // State update (React batches these in microtasks)
    setLoading(true);
    
    // Macro-task - animation frame
    requestAnimationFrame(() => {
        console.log('4. Animation frame');
    });
    
    // Micro-task - Promise
    Promise.resolve().then(() => {
        console.log('3. State updated, UI re-rendered');
    });
    
    // Macro-task - timeout
    setTimeout(() => {
        console.log('5. Timeout completed');
        setLoading(false);
    }, 1000);
    
    console.log('2. Event handler finished');
};

/*
OUTPUT:
1. Button pressed
2. Event handler finished
3. State updated, UI re-rendered
4. Animation frame
5. Timeout completed
*/
üéØ Interview Answer Summary
"The Event Loop is JavaScript's mechanism for handling asynchronous operations. It consists of:

Call Stack - Executes synchronous code

Web APIs - Browser-provided async functions (setTimeout, fetch)

Callback Queue - Holds macro-tasks (setTimeout, setInterval, I/O)

Microtask Queue - Holds micro-tasks (Promises, queueMicrotask)

The Event Loop constantly checks:

First: Is Call Stack empty?

Second: Execute all Microtasks

Third: Execute one Macro-task

Repeat

This ensures non-blocking execution while maintaining single-threaded semantics."

üí° Key Takeaways for Interview:
Microtasks have higher priority than Macrotasks

Promises execute before setTimeout, even with 0 delay

Async/Await uses Promises (microtasks)

Heavy microtasks can block the event loop

Understanding this helps debug tricky timing issues
--------------------------------------------------------

What is hoisting in JavaScript?
JavaScript Hoisting - Complete Explanation
Hoisting is JavaScript's behavior of moving declarations to the top of their scope during the compilation phase, before code execution.

üìù Types of Hoisting
1. var Hoisting
javascript
// Example 1: Basic var hoisting
console.log(name); // undefined (not ReferenceError)
var name = 'John';
console.log(name); // 'John'

// How JavaScript interprets it:
var name;          // Declaration hoisted (initialized as undefined)
console.log(name); // undefined
name = 'John';     // Assignment remains in place
console.log(name); // 'John'
2. let and const Hoisting (Temporal Dead Zone)
javascript
// Example 2: let/const hoisting with TDZ
console.log(age); // ReferenceError: Cannot access 'age' before initialization
let age = 25;

// How JavaScript interprets it:
let age;          // Declaration hoisted BUT not initialized
console.log(age); // ‚ùå Throws error - Temporal Dead Zone
age = 25;         // Assignment

// Same for const
console.log(PI); // ReferenceError
const PI = 3.14;
3. Function Hoisting
javascript
// Example 3: Function declarations are fully hoisted
sayHello(); // "Hello!" - works fine

function sayHello() {
    console.log("Hello!");
}

// How JavaScript interprets it:
function sayHello() {  // Entire function is hoisted
    console.log("Hello!");
}
sayHello(); // Works!
4. Function Expressions Hoisting
javascript
// Example 4: Function expressions follow variable hoisting rules
// Function expression with var
sayHi(); // TypeError: sayHi is not a function
var sayHi = function() {
    console.log("Hi!");
};

// How JavaScript interprets it:
var sayHi;            // undefined
sayHi();              // ‚ùå TypeError - trying to call undefined
sayHi = function() {  // Assignment
    console.log("Hi!");
};

// Function expression with let/const
sayBye(); // ReferenceError: Cannot access 'sayBye' before initialization
const sayBye = function() {
    console.log("Bye!");
};
üî• Advanced Hoisting Scenarios
Example 1: Mixed Declarations
javascript
var x = 1;
function test() {
    console.log(x); // undefined (not 1!)
    var x = 2;
    console.log(x); // 2
}
test();

// How JavaScript interprets it:
var x = 1;
function test() {
    var x;          // Declaration hoisted to top of function
    console.log(x); // undefined (local variable shadows global)
    x = 2;          // Assignment
    console.log(x); // 2
}
test();
Example 2: Functions vs Variables
javascript
// Scenario 1: Function declaration vs var
console.log(typeof myFunc); // "function" - function wins

var myFunc = "I'm a variable";
function myFunc() {
    return "I'm a function";
}

console.log(typeof myFunc); // "string" - variable assignment wins

// How JavaScript interprets it:
function myFunc() {         // Function hoisted first
    return "I'm a function";
}
var myFunc;                 // var declaration (ignored since name exists)
console.log(typeof myFunc); // "function"
myFunc = "I'm a variable";  // Assignment
console.log(typeof myFunc); // "string"
Example 3: Multiple Declarations
javascript
var a = 10;
function hoistTest() {
    console.log(a); // undefined
    if (false) {
        var a = 20; // Still hoisted even though block never executes!
    }
    console.log(a); // undefined
}
hoistTest();

// How JavaScript interprets it:
var a = 10;
function hoistTest() {
    var a;          // Hoisted to top of function (initialized as undefined)
    console.log(a); // undefined
    if (false) {
        a = 20;     // Never executes
    }
    console.log(a); // undefined
}
hoistTest();
Example 4: Class Hoisting
javascript
// Classes are NOT hoisted like functions
const person = new Person(); // ReferenceError: Cannot access 'Person' before initialization

class Person {
    constructor(name) {
        this.name = name;
    }
}

// This works:
const Person = class { /* ... */ };
const person = new Person(); // OK - but this is different syntax
‚ö° Real-World React Native Examples
Example 1: Component Function Hoisting
javascript
import React from 'react';
import { View, Text } from 'react-native';

// ‚úÖ Function declarations are hoisted - can call before definition
const App = () => {
    return (
        <View>
            <WelcomeMessage />  {/* Works due to hoisting */}
            <UserProfile />
        </View>
    );
};

// Function declaration - hoisted
function WelcomeMessage() {
    return <Text>Welcome to our app!</Text>;
}

// Function expression - not hoisted (if using const/let)
const UserProfile = () => {
    return <Text>User Profile</Text>;
};

// ‚ùå This would cause issues:
const AnotherComponent = () => {
    return (
        <View>
            <NonHoistedComponent /> {/* ReferenceError if using const/let */}
        </View>
    );
};

const NonHoistedComponent = () => <Text>Not hoisted</Text>;
Example 2: Hook Usage and Hoisting
javascript
import { useState, useEffect } from 'react';

// ‚úÖ Correct - hooks at top level, functions can be called later
function UserContainer() {
    const [user, setUser] = useState(null);
    
    // useEffect can call functions defined later
    useEffect(() => {
        fetchUserData();
    }, []);
    
    // Function declaration - hoisted, so useEffect can call it
    function fetchUserData() {
        fetch('/api/user')
            .then(response => response.json())
            .then(data => setUser(data));
    }
    
    return <UserDisplay user={user} />;
}

// ‚ùå Problematic - function expression with const
function ProblematicComponent() {
    const [data, setData] = useState(null);
    
    useEffect(() => {
        fetchData(); // ReferenceError!
    }, []);
    
    const fetchData = () => {  // Not hoisted
        // fetch logic
    };
    
    return null;
}
Example 3: Import Hoisting Behavior
javascript
// In React Native, imports are effectively "hoisted"
import React, { useState } from 'react';
import { View, Text } from 'react-native';

// All imports are available throughout the module
const Component = () => {
    const [state, setState] = useState(); // useState available everywhere
    
    return (
        <View>
            <Text>Hello</Text>
        </View>
    );
};
üéØ Hoisting Rules Summary
Declaration Type	Hoisting Behavior	Initial Value	Temporal Dead Zone
var	‚úÖ Hoisted	undefined	‚ùå No
let	‚úÖ Hoisted	Not initialized	‚úÖ Yes
const	‚úÖ Hoisted	Not initialized	‚úÖ Yes
function	‚úÖ Hoisted	Function itself	‚ùå No
function expression (with var)	‚úÖ Hoisted	undefined	‚ùå No
function expression (with let/const)	‚úÖ Hoisted	Not initialized	‚úÖ Yes
class	‚ùå Not hoisted	-	‚úÖ Yes
üí° Best Practices for Modern JavaScript
‚úÖ DO:
javascript
// Use const/let and declare at the top
const initializeApp = () => {
    const user = getUser();
    const config = loadConfig();
    
    // Use functions
    return renderUI(user, config);
};

// Function declarations are fine for utilities
function getUser() {
    return { name: 'John' };
}

function renderUI(user, config) {
    // rendering logic
}
‚ùå DON'T:
javascript
// Avoid relying on var hoisting
function problematicFunction() {
    console.log(value); // undefined - confusing!
    processData();      // Might work or might not
    
    var value = 10;
    var processData = function() {
        // logic
    };
}
üéØ Interview Answer Summary
"Hoisting is JavaScript's mechanism where variable and function declarations are moved to the top of their containing scope during compilation.

Key points:

var declarations are hoisted and initialized with undefined

let/const declarations are hoisted but not initialized (Temporal Dead Zone)

Function declarations are fully hoisted with their definition

Function expressions follow variable hoisting rules

Classes are not hoisted

In practice, we use const/let and declare variables at the top to avoid confusion with hoisting behavior."
--------------------------------------------------------------


Difference between null and undefined
In JavaScript, null and undefined are both primitive values that represent ‚Äúnothing‚Äù or ‚Äúno value,‚Äù but they are not the same.

Here‚Äôs a clear breakdown üëá

Feature	undefined	null
Meaning	A variable has been declared but not assigned a value.	A variable has been explicitly assigned ‚Äúno value.‚Äù
Type	"undefined"	"object" (this is actually a historical bug in JavaScript)
Default value	Default for uninitialized variables, missing function parameters, and missing object properties.	Not a default ‚Äî must be explicitly set by the programmer.
Example	js\nlet a;\nconsole.log(a); // undefined\n	js\nlet b = null;\nconsole.log(b); // null\n
Comparison (==)	null == undefined ‚Üí true	
Strict comparison (===)	null === undefined ‚Üí false	
Typical use case	Indicates a variable or property hasn‚Äôt been assigned a value yet.	Indicates intentional absence of a value (like ‚Äúnothing here‚Äù).
Example:
let x;
let y = null;

console.log(x);        // undefined (no value assigned)
console.log(y);        // null (explicitly set to "no value")

console.log(x == y);   // true  (loose equality)
console.log(x === y);  // false (strict equality)

Summary:

Use undefined when a variable is not initialized.

Use null when you intentionally want to represent ‚Äúno value.‚Äù
-------------------------------------------------


What are closures and provide an example?
You said:
in simpl words with basic example
You said:
function greet() {
  let name = "Alice";

  function sayHello() {
    console.log("Hello " + name);
  }

  return sayHello;
}
//why greet method not called at below ine
const hello = greet(); 
hello(); // prints "Hello Alice"
You said:
do explaning in code itselft
------------------------------------------------------

Explain the this keyword in different contexts
The this keyword in JavaScript can be tricky because its value depends on how a function is called, not where it‚Äôs defined.
Here‚Äôs a breakdown of the main contexts with examples:

1. Global context
In the global scope (outside any function or object):
console.log(this); 



In a browser, this refers to the window object.


In Node.js, it refers to an empty object {} (in modules).



2. Inside a regular function
function showThis() {
  console.log(this);
}
showThis();



In strict mode, this is undefined.


In non-strict mode, this refers to the global object (window in browsers).



3. Inside a method (object function)
const person = {
  name: "Alice",
  sayHi() {
    console.log(this.name);
  }
};
person.sayHi(); // "Alice"

Here, this refers to the object before the dot ‚Äî person.

4. Using this in arrow functions
const person = {
  name: "Alice",
  greet: () => {
    console.log(this.name);
  }
};
person.greet(); // undefined

Arrow functions don‚Äôt have their own this.
They use this from where they were defined (the outer scope).
So here, this doesn‚Äôt refer to person but the global scope.

5. In constructors (with new)
function User(name) {
  this.name = name;
}

const user1 = new User("Alice");
console.log(user1.name); // "Alice"

When used with new, this refers to the newly created object.

6. With call, apply, or bind
These methods let you manually set the value of this.
function sayHello() {
  console.log("Hello " + this.name);
}

const person = { name: "Bob" };

sayHello.call(person);  // "Hello Bob"
sayHello.apply(person); // "Hello Bob"

const boundHello = sayHello.bind(person);
boundHello();           // "Hello Bob"


In short:
Contextthis refers toGlobal scopeGlobal object (window or {})Regular functionundefined (strict) or global objectMethod in objectThe object itselfArrow functionThe outer (lexical) thisConstructor (new)The new instancecall, apply, bindWhatever you manually set it to
Would you like a single code example that shows all these cases in one go?
------------------------------------------------

What is the difference between == and ===?

How does JavaScript handle asynchronous operations?

What are arrow functions and how do they differ from regular functions?

Explain call, apply, and bind methods

ES6+ Features
What are template literals?

The call, apply, and bind methods in JavaScript are Function methods that let you explicitly control the value of this when invoking a function.
They‚Äôre tools for function borrowing and manual context binding, especially useful when dealing with methods that depend on this.

Let‚Äôs dissect them cleanly and without fluff.

1. call()
Purpose:

Calls a function immediately, with a specified this value and individual arguments.

Syntax:
func.call(thisArg, arg1, arg2, ...)

Example:
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "Piyush" };

greet.call(person, "Hello", "!"); // Hello, Piyush!


Here, this inside greet is explicitly set to person.

The arguments "Hello" and "!" are passed individually.

2. apply()
Purpose:

Almost identical to call(), but arguments are passed as an array or array-like object.

Syntax:
func.apply(thisArg, [arg1, arg2, ...])

Example:
greet.apply(person, ["Hi", "!!"]); // Hi, Piyush!!


The only difference: arguments are passed as an array.

Historically used before the spread operator (...) existed.

Modern equivalent:
greet.call(person, ...["Hi", "!!"]); // Same as apply

3. bind()
Purpose:

Creates a new function with a permanently bound this value and optional preset arguments.
It does not execute immediately ‚Äî it returns a new function.

Syntax:
const newFunc = func.bind(thisArg, arg1, arg2, ...);

Example:
const greetPiyush = greet.bind(person, "Hey");
greetPiyush("?"); // Hey, Piyush?


bind() locks this to person.

You can call the new function later, and this will always refer to person.

4. Practical Differences
Method	When It Executes	Argument Style	Returns a New Function?	Main Use
call()	Immediately	Comma-separated	‚ùå No	Immediate invocation with custom this
apply()	Immediately	Array	‚ùå No	Immediate invocation when args are in an array
bind()	Later	Comma-separated	‚úÖ Yes	Permanent binding for future calls
5. Common Use Cases
a. Function Borrowing

Use methods from one object in another:

const person1 = { name: "Piyush" };
const person2 = { name: "Alex" };

function sayHello() {
  console.log(`Hello, ${this.name}`);
}

sayHello.call(person2); // Hello, Alex

b. Working with setTimeout

When this context is lost:

const user = {
  name: "Piyush",
  greet() {
    setTimeout(function() {
      console.log(`Hi, ${this.name}`); // 'this' is undefined or global
    }.bind(this), 1000);
  }
};

user.greet(); // Hi, Piyush

c. Using apply for Math operations

Borrowing methods from the Math object:

const nums = [5, 10, 2, 8];
const max = Math.max.apply(null, nums); // 10


(null because Math.max doesn‚Äôt care about this)

In summary:

call ‚Äî same as normal call, but lets you specify this and arguments directly.

apply ‚Äî same as call, but arguments go in an array.

bind ‚Äî doesn‚Äôt call the function immediately; returns a new function with fixed this.

Bottom Line

If you need a one-time control over this, use call or apply.
If you need to lock this for later, use bind.
------------------------------------------------------------

Explain destructuring assignment

Destructuring assignment in JavaScript lets you unpack values from arrays or extract properties from objects into separate variables ‚Äî all in one concise statement.

1. Array Destructuring
const nums = [10, 20, 30];
const [a, b, c] = nums;

console.log(a); // 10
console.log(b); // 20
console.log(c); // 30


You can skip elements:

const [first, , third] = [1, 2, 3];
console.log(third); // 3


Set default values:

const [x = 5, y = 10] = [7];
console.log(x, y); // 7 10

2. Object Destructuring
const user = { name: "Piyush", age: 22 };
const { name, age } = user;

console.log(name); // Piyush
console.log(age);  // 22


Rename variables:

const { name: username } = user;
console.log(username); // Piyush


Set defaults:

const { country = "India" } = user;
console.log(country); // India

3. Nested Destructuring
const person = { info: { first: "Piyush", last: "Kumar" } };
const { info: { first, last } } = person;
console.log(first, last); // Piyush Kumar

4. Function Parameters

You can destructure directly in function arguments:

function greet({ name, age }) {
  console.log(`Hi ${name}, age ${age}`);
}

greet({ name: "Piyush", age: 22 }); // Hi Piyush, age 22


‚úÖ In short:
Destructuring lets you extract multiple values from arrays or objects elegantly and efficiently ‚Äî making your code shorter, cleaner, and easier to read.
------------------------------------------------
What are default parameters?
Default parameters let you assign a default value to a function parameter if no argument is provided (or if it's undefined).

Example
function greet(name = "Guest") {
  console.log(`Hello, ${name}!`);
}

greet("Piyush"); // Hello, Piyush!
greet();         // Hello, Guest!

Key Points

Defaults apply only when the argument is undefined, not null or 0.

You can use expressions as defaults:

function add(a, b = a * 2) {
  return a + b;
}
console.log(add(3)); // 9


‚úÖ In short:
Default parameters ensure functions have fallback values ‚Äî preventing undefined results when arguments are missing.
------------------------------------------


Explain the spread and rest operators
The spread (...) and rest (...) operators use the same syntax (...), but they do opposite things depending on where they‚Äôre used.

1. Spread Operator (...)
Purpose:

Expands (spreads) elements of an array or object into individual items.

Examples:

Array expansion:

const nums = [1, 2, 3];
const newNums = [...nums, 4, 5];
console.log(newNums); // [1, 2, 3, 4, 5]


Object expansion:

const user = { name: "Piyush", age: 22 };
const updated = { ...user, country: "India" };
console.log(updated); // { name: "Piyush", age: 22, country: "India" }


Function arguments:

const arr = [5, 10, 15];
console.log(Math.max(...arr)); // 15

2. Rest Operator (...)
Purpose:

Collects multiple elements into a single array or object ‚Äî the reverse of spread.

Examples:

Function parameters:

function sum(...numbers) {
  return numbers.reduce((a, b) => a + b);
}

console.log(sum(1, 2, 3, 4)); // 10


Array destructuring:

const [first, ...rest] = [10, 20, 30, 40];
console.log(first); // 10
console.log(rest);  // [20, 30, 40]


Object destructuring:

const { name, ...info } = { name: "Piyush", age: 22, country: "India" };
console.log(name); // Piyush
console.log(info); // { age: 22, country: "India" }

Quick Summary
Operator	Meaning	Used In	Example
Spread (...)	Expands values	Arrays, Objects, Function calls	sum(...arr)
Rest (...)	Collects values	Function params, Destructuring	function fn(...args)

‚úÖ In short:

Spread ‚Üí unpacks values.

Rest ‚Üí packs values.
-------------------------------------------------


What are Promises and how do they work?
A Promise in JavaScript is an object that represents the eventual completion (or failure) of an asynchronous operation ‚Äî and its resulting value.
It‚Äôs a cleaner way to handle async tasks than messy callback chains (‚Äúcallback hell‚Äù).

1. States of a Promise

A Promise can be in one of three states:

State	Meaning
Pending	The operation is still running.
Fulfilled	The operation completed successfully (resolve() called).
Rejected	The operation failed (reject() called).

Once fulfilled or rejected, a promise becomes settled and cannot change state again.

2. Basic Syntax
const promise = new Promise((resolve, reject) => {
  const success = true;

  if (success) resolve("Operation successful!");
  else reject("Something went wrong!");
});

3. Consuming a Promise

You handle the result using .then() and .catch():

promise
  .then(result => console.log(result))   // runs if resolved
  .catch(error => console.error(error))  // runs if rejected
  .finally(() => console.log("Done"));   // runs always

4. Real Example (Async Operation)
function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Data loaded");
    }, 2000);
  });
}

getData()
  .then(data => console.log(data))  // "Data loaded" after 2 sec
  .catch(err => console.error(err));

5. Promise Chaining

You can chain .then() calls to run sequential async actions:

fetchUser()
  .then(user => fetchPosts(user.id))
  .then(posts => console.log(posts))
  .catch(error => console.error(error));


Each .then() returns a new promise, enabling smooth chaining.

6. Async/Await (Modern Syntax)

async/await makes working with promises look synchronous:

async function loadData() {
  try {
    const result = await getData();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}


‚úÖ In short:
A Promise is a structured way to handle asynchronous code ‚Äî it avoids callback hell and gives you clean control over success and failure paths using .then(), .catch(), and async/await.
---------------------------------------------------------------

Explain async/await syntax
async/await is modern JavaScript syntax for handling asynchronous operations in a way that looks and behaves like synchronous code, but still runs asynchronously under the hood.
It‚Äôs built on top of Promises ‚Äî not a replacement.

1. async Function

Declaring a function with async makes it automatically return a Promise.

Whatever you return becomes a resolved value.

If you throw, it becomes a rejected promise.

async function greet() {
  return "Hello";
}

greet().then(msg => console.log(msg)); // Hello

2. await Keyword

await pauses the execution of an async function until the promise resolves or rejects.

It can only be used inside an async function.

function fetchData() {
  return new Promise(resolve => setTimeout(() => resolve("Data loaded"), 2000));
}

async function load() {
  console.log("Fetching...");
  const data = await fetchData(); // waits here until resolved
  console.log(data); // Data loaded
  console.log("Done!");
}

load();


Output:

Fetching...
(wait 2 sec)
Data loaded
Done!

3. Error Handling with try...catch

Use try...catch for clean error management ‚Äî replaces .catch() chains:

async function getData() {
  try {
    const result = await fetch("https://api.example.com");
    const data = await result.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
}

4. Running Promises in Parallel

If you don‚Äôt need sequential waiting, use Promise.all():

async function loadAll() {
  const [user, posts] = await Promise.all([
    fetch("/user"),
    fetch("/posts")
  ]);
}


‚úÖ In short:

async makes a function return a Promise.

await pauses execution until the promise resolves.

Together, they make async code look synchronous, easier to read, and simpler to debug.
-------------------------------------------------------------

What are JavaScript modules (import/export)?
JavaScript modules let you split your code into separate files, each with its own scope ‚Äî making your code organized, reusable, and maintainable.

They work using export and import keywords.

1. Exporting

You can export variables, functions, classes, or objects from a file so they can be used elsewhere.

Named Exports

You can export multiple items:

// math.js
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

Default Export

You can export one main thing per file:

// logger.js
export default function log(msg) {
  console.log(msg);
}

2. Importing

You bring exported items into another file.

Importing Named Exports

Use curly braces and exact names:

import { add, multiply } from './math.js';
console.log(add(2, 3)); // 5


You can also rename imports:

import { add as sum } from './math.js';

Importing Default Exports

No braces needed:

import log from './logger.js';
log("Hello World!");


You can import both default and named together:

import log, { add } from './mathUtils.js';

3. Exporting All

You can re-export everything from another module:

export * from './math.js';

4. Module Scope

Each module has its own scope ‚Äî variables declared inside aren‚Äôt global:

// inside math.js
const secret = 42; // not accessible outside

5. How to Use

Works natively in browsers with <script type="module">.

In Node.js, modules use .mjs extension or "type": "module" in package.json.

<script type="module" src="app.js"></script>


‚úÖ In short:

export ‚Üí makes code available to other files.

import ‚Üí brings exported code into your file.

Modules = cleaner, modular, reusable code with isolated scope.
---------------------------------------------------------

What are Map and Set objects?
Map and Set are built-in JavaScript objects (introduced in ES6) that provide more efficient and flexible ways to store collections of data compared to plain objects or arrays.

1. Map

A Map stores key‚Äìvalue pairs, like an object ‚Äî but with key flexibility and predictable iteration.

Key Features

Keys can be any type (objects, functions, primitives).

Maintains insertion order.

Has built-in methods for size, iteration, and existence checks.

Example
const map = new Map();

map.set("name", "Piyush");
map.set("age", 22);
map.set({ id: 1 }, "Developer");

console.log(map.get("name")); // Piyush
console.log(map.size);        // 3
console.log(map.has("age"));  // true

map.delete("age");
map.clear(); // removes everything

Iteration
const users = new Map([
  ["id", 1],
  ["name", "Piyush"]
]);

for (const [key, value] of users) {
  console.log(key, value);
}
// id 1
// name Piyush

2. Set

A Set stores unique values ‚Äî no duplicates, no key‚Äìvalue pairs.

Key Features

Values are unique (duplicates automatically removed).

Maintains insertion order.

Can store any type of value.

Example
const set = new Set();

set.add(10);
set.add(20);
set.add(10); // duplicate ignored

console.log(set.size);     // 2
console.log(set.has(20));  // true

set.delete(10);
set.clear(); // removes all

Iteration
const numbers = new Set([1, 2, 3, 3]);
for (const num of numbers) {
  console.log(num);
}
// 1 2 3

3. Quick Comparison
Feature	Map	Set
Structure	Key‚ÄìValue pairs	Unique values
Keys	Any type	N/A
Duplicates	Allowed in values	Not allowed
Useful for	Lookups, caching	Unique collections, filtering duplicates

‚úÖ In short:

Map = object-like structure with any-type keys and ordered entries.

Set = array-like structure that stores unique values efficiently.
----------------------------------------------------

Explain Object.keys(), Object.values(), Object.entries()
The methods Object.keys(), Object.values(), and Object.entries() are built-in JavaScript functions for working with object properties.
They make it easy to extract an object‚Äôs keys, values, or key‚Äìvalue pairs in array form ‚Äî often used for iteration or transformation.

1. Object.keys()

Returns an array of the object‚Äôs own property names (keys).

Example:
const user = { name: "Piyush", age: 22, country: "India" };
console.log(Object.keys(user));
// ["name", "age", "country"]


‚úÖ Use when you need the property names to loop or check for existence.

2. Object.values()

Returns an array of the object‚Äôs property values.

Example:
console.log(Object.values(user));
// ["Piyush", 22, "India"]


‚úÖ Use when you only care about the values, not the keys.

3. Object.entries()

Returns an array of key‚Äìvalue pairs, where each pair is itself an array [key, value].

Example:
console.log(Object.entries(user));
// [["name", "Piyush"], ["age", 22], ["country", "India"]]


‚úÖ Useful for iteration with destructuring:

for (const [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}
// name: Piyush
// age: 22
// country: India

4. Summary Table
Method	Returns	Example Output	Use Case
Object.keys(obj)	Array of keys	["name", "age"]	Looping over property names
Object.values(obj)	Array of values	["Piyush", 22]	Getting only values
Object.entries(obj)	Array of [key, value] pairs	[["name","Piyush"],["age",22]]	Iteration, destructuring

‚úÖ In short:

keys() ‚Üí property names

values() ‚Üí property values

entries() ‚Üí both keys and values together
-------------------------------------------------------------------

What are generators and how do they work?
Generators are functions that can pause and resume, letting you produce values one at a time instead of all at once. They exist to give you precise control over iteration.

1. Syntax

A generator is created with function* and uses yield to output values.

function* gen() {
  yield 1;
  yield 2;
  yield 3;
}


Calling it does NOT run the function. It returns an iterator:

const iterator = gen();

2. How they work

Each call to iterator.next() runs the function until the next yield.

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }


You get:

value: the yielded value

done: whether the generator has finished

3. They allow bidirectional communication

You can send data back into the generator:

function* calc() {
  const x = yield 5;
  yield x * 2;
}

const it = calc();
console.log(it.next());      // { value: 5, done: false }
console.log(it.next(10));    // { value: 20, done: false }


The argument passed to next() becomes the result of the previous yield.

4. They‚Äôre perfect for custom iterators

Generators implement the iterator protocol directly:

const range = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  }
};

for (const n of range) console.log(n);

5. Practical uses

Most people misuse generators because they don‚Äôt understand them. Their core real-world value:

Building custom lazy data streams

Controlling complex iteration logic

Implementing async flows (before async/await existed)

Creating infinite sequences safely

Example of an infinite generator:

function* infinite() {
  let n = 0;
  while (true) yield n++;
}


Runs forever but only produces one value at a time when requested.

Short version

Generators are pause-and-resume functions powered by yield and next(). They give you manual control over execution and let you produce values lazily instead of upfront.
-----------------------------------------------------

The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM used by libraries like React to update the UI efficiently.

1. What it actually is

It‚Äôs just a JavaScript object that mirrors the structure of the real HTML DOM.

Example (conceptually):

const vdom = {
  type: "div",
  props: {},
  children: [
    { type: "p", props: {}, children: ["Hello"] }
  ]
};


This is easier and cheaper to update than touching the real DOM directly.

2. How it works
Step 1 ‚Äî Render Virtual DOM

Your UI is converted into a virtual DOM tree.

Step 2 ‚Äî State changes

When state changes, a new virtual DOM tree is created.

Step 3 ‚Äî Diffing

React compares the old VDOM and the new VDOM:

Figures out exactly what changed.

This step is called reconciliation.

Step 4 ‚Äî Update real DOM minimally

Only the parts that actually changed get updated in the real DOM.

This avoids expensive full-page re-renders.

3. Why it exists

The real DOM is slow.
Manipulating it repeatedly destroys performance.
The VDOM reduces that cost by:

batching updates

minimizing direct DOM operations

avoiding unnecessary re-renders

4. Misconception to avoid

People often parrot ‚ÄúVirtual DOM is faster.‚Äù
No ‚Äî the real point is predictable, optimized updates, not raw speed.

React uses VDOM to avoid waste, not to magically outrun the real DOM.

Short version

The Virtual DOM is a JavaScript representation of the real DOM that lets frameworks update UI efficiently by:

Creating a virtual copy

Diffing old vs new

Updating only what's changed in the real DOM

It‚Äôs an optimization layer for cleaner, smarter rendering.
-----------------------------------------------

Advanced Concepts
What is the prototype chain?
The **prototype chain** is JavaScript‚Äôs **inheritance mechanism**.
Every object has a hidden link called **`[[Prototype]]`** that points to another object.
When you try to access a property, JavaScript **walks up this chain** until it finds the property or hits `null`.

---

## **How it works**

```js
const obj = {};
```

Prototype chain:

```
obj ‚Üí Object.prototype ‚Üí null
```

If you call:

```js
obj.toString();
```

JS checks:

1. `obj` ‚Äî not found
2. `Object.prototype` ‚Äî found ‚Üí use it
3. If it wasn't there, it would stop at `null`

---

## **With constructor functions**

```js
function Person(name) {
  this.name = name;
}
Person.prototype.sayHi = function() {};

const p = new Person("Piyush");
```

Chain:

```
p ‚Üí Person.prototype ‚Üí Object.prototype ‚Üí null
```

---

## **Short answer**

The **prototype chain** is the linked chain of objects JS searches through when resolving properties. It‚Äôs how JavaScript implements inheritance.

----------------------------------------------------------------------

Explain event delegation
Event delegation is a technique where you **attach one event listener to a parent element** instead of attaching separate listeners to every child.
The parent catches events because events **bubble up** the DOM.

---

## **How it works**

1. An event happens on a child (e.g., a button inside a list).
2. The event **bubbles** to the parent.
3. The parent‚Äôs single listener checks **which child triggered it** using `event.target`.

---

## **Example**

```js
document.querySelector("#list").addEventListener("click", (e) => {
  if (e.target.matches("li")) {
    console.log("Clicked:", e.target.textContent);
  }
});
```

You avoid attaching individual listeners like:

```js
li.addEventListener("click", ...)
```

---

## **Why event delegation matters**

* You **save memory** (one listener instead of many).
* You avoid constantly re-attaching listeners when elements are added/removed.
* You control a dynamic UI with minimal event wiring.

---

## **Short version**

Event delegation = **listen on the parent, catch events from children**, and handle them based on `event.target`. It‚Äôs the only scalable way to manage large or dynamic DOM structures.
--------------------------------------------------------------



What is currying in JavaScript?
Currying is the process of transforming a function that takes multiple arguments into a chain of functions that each take one argument at a time.

Example (normal function)
function add(a, b) {
  return a + b;
}

Curried version
function curryAdd(a) {
  return function (b) {
    return a + b;
  };
}

curryAdd(3)(5); // 8

Why it matters

Currying lets you:

Reuse functions by pre-filling some arguments (partial application)

Build cleaner, modular logic

Avoid repeating the same parameters

Short version

Currying breaks a multi-argument function into a sequence of single-argument functions, enabling easy reuse and partial application.
------------------------------------------------

Difference between deep copy and shallow copy
A **shallow copy** copies only the **top-level** values.
A **deep copy** copies **everything**, including nested objects.

---

## **Shallow Copy**

Copies references of nested objects ‚Äî not the objects themselves.

```js
const original = { a: 1, b: { c: 2 } };
const copy = { ...original };

copy.b.c = 99;

console.log(original.b.c); // 99  (changed!)
```

### Why?

Because `b` was **not** duplicated ‚Äî both objects share the same inner reference.

---

## **Deep Copy**

Creates a **fully independent** clone, including nested structures.

```js
const original = { a: 1, b: { c: 2 } };
const deep = JSON.parse(JSON.stringify(original));

deep.b.c = 99;

console.log(original.b.c); // 2  (unchanged)
```

### Better deep copy tools:

* `structuredClone()`
* Recursive functions
* Libraries like Lodash (`_.cloneDeep`)

---

## **Short version**

* **Shallow copy:** duplicates top-level properties, but nested objects **share references**.
* **Deep copy:** duplicates **everything**, producing a completely independent object.

-----------------------------------------------------------


How does setTimeout and setInterval work?
**setTimeout** and **setInterval** are just timers controlled by the JavaScript event loop. They don‚Äôt ‚Äúpause‚Äù code ‚Äî they schedule callbacks to run **later**.

---

## **setTimeout**

Runs a function **once** after a delay.

```js
setTimeout(() => {
  console.log("Runs once after 1s");
}, 1000);
```

The delay is **never exact**. It only means ‚Äúrun this *after at least* X ms, when the call stack is empty.‚Äù

---

## **setInterval**

Runs a function **repeatedly** at a fixed interval.

```js
setInterval(() => {
  console.log("Runs every 1s");
}, 1000);
```

It does **not** wait for the previous callback to finish.
If your callback is slow, intervals will drift or pile up.

---

## **Core mechanics**

1. The timer starts in the browser/node environment (not the JS engine).
2. When time is up, the callback is put into the **task queue**.
3. The event loop pushes it into the call stack **only when the stack is empty**.

---

## **Short version**

* **setTimeout:** run once after a delay.
* **setInterval:** run repeatedly at fixed intervals.
  Both rely on the **event loop**, and delays are never guaranteed to be exact.
----------------------------------------------------------------------------------


What is memoization and provide an example?

Memoization is **caching the result of a function call** so future calls with the **same arguments** return the stored result instantly instead of recomputing.
It‚Äôs a performance hack for expensive or repetitive calculations.

---

## **Example**

```js
function memoize(fn) {
  const cache = {};
  return function (x) {
    if (cache[x] !== undefined) return cache[x];
    const result = fn(x);
    cache[x] = result;
    return result;
  };
}

function slowSquare(n) {
  // pretend this is expensive
  return n * n;
}

const fastSquare = memoize(slowSquare);

console.log(fastSquare(5)); // computed
console.log(fastSquare(5)); // cached
```

---

## **Short version**

Memoization = **store results ‚Üí skip recomputation ‚Üí speed boost**.
-----------------------------------------------------------------

Explain JavaScript's memory management
JavaScript‚Äôs memory management is straightforward on the surface but brutal underneath: **you don‚Äôt control memory directly ‚Äî the garbage collector does ‚Äî and you can still screw things up by holding references you shouldn‚Äôt.**

Here‚Äôs the concise, accurate breakdown:

---

## **How JS memory works**

### **1. Allocation**

When you create variables, objects, arrays, functions, JS grabs memory for them automatically.

```js
let x = 10;          // value stored directly
let obj = { a: 1 };  // reference stored, object lives elsewhere
```

Primitive values go on the **stack**, complex objects go on the **heap**.

---

## **2. Reachability**

The garbage collector only cares about **reachability**.

A value is ‚Äúreachable‚Äù if the program can still access it through:

* global variables
* function scopes
* closures
* active references

If nothing references it, it becomes **garbage**.

---

## **3. Garbage collection**

JavaScript uses **mark-and-sweep**:

1. Start from roots (global, active function scopes).
2. Mark everything reachable.
3. Delete (‚Äúsweep‚Äù) everything not marked.

It's automatic **but not magic** ‚Äî you can easily create memory leaks.

---

## **4. The real problem: accidental memory leaks**

The engine handles cleanup, **you** create leaks when you keep references alive that shouldn‚Äôt exist:

### **Common leak sources**

* **Uncleared timers**

  ```js
  setInterval(() => {}, 1000); // never cleared ‚Üí forever reachable
  ```
* **Unused event listeners**

  ```js
  element.addEventListener("click", handler);
  // element removed but listener still references it
  ```
* **Closures that trap variables**

  ```js
  function outer() {
    const huge = new Array(1_000_000);
    return () => console.log("trapped"); // huge stays alive
  }
  ```
* **Global variables** (the easiest way to poison memory)

---

## **Short version**

JavaScript allocates and frees memory automatically using **reachability-based garbage collection**, but you can still leak memory by keeping unnecessary references alive. The engine handles the mechanics; you‚Äôre responsible for not sabotaging it.

-----------------------------------------------------------------------

What are Web Workers?
Web Workers let you run JavaScript **in background threads**, separate from the main UI thread.
They exist because the main thread freezes if you run heavy code ‚Äî workers prevent that.

---

## **What they do**

* Run CPU-heavy tasks **without blocking the UI**
* Have their **own thread**
* Communicate with the main thread via **message passing**
* Cannot access the DOM (and shouldn‚Äôt)

---

## **Basic example**

**main.js**

```js
const worker = new Worker("worker.js");

worker.postMessage(10);

worker.onmessage = (e) => {
  console.log("Result:", e.data);
};
```

**worker.js**

```js
onmessage = (e) => {
  let num = e.data;
  postMessage(num * 2);
};
```

---

## **Short version**

Web Workers = **background JS threads** for heavy work so the main thread stays smooth. They communicate via messages and cannot touch the DOM.
------------------------------------------------------------

Explain the Module Pattern

What is the Revealing Module Pattern?

Array Methods
Difference between map, filter, and reduce

When would you use forEach vs map?

Explain some and every array methods

What does Array.prototype.flat() do?

How does Array.prototype.find() work?

Explain Array.prototype.includes() vs Array.prototype.indexOf()

What is the purpose of Array.prototype.splice()?

How to remove duplicates from an array?

Explain Array.prototype.sort() method

1. some()

Checks whether at least one element passes a condition.

[1, 2, 3].some(n => n > 2); // true


Returns true as soon as it finds a match.

Stops early.

If the callback never returns true ‚Üí false.

2. every()

Checks whether all elements pass a condition.

[1, 2, 3].every(n => n > 0); // true


Returns false as soon as one element fails.

Stops early.

3. What does Array.prototype.flat() do?

It flattens nested arrays.

[1, [2, [3]]].flat();      // [1, 2, [3]]
[1, [2, [3]]].flat(2);     // [1, 2, 3]


Default depth is 1.

4. How does find() work?

Returns the first element that satisfies the callback.

[1, 5, 10].find(n => n > 5); // 10


If no element matches ‚Üí undefined.

Does not return an index ‚Äî it returns the value.

5. includes() vs indexOf()
includes()

Checks if a value exists.

Returns true/false.

Handles NaN correctly.

[1, 2, NaN].includes(NaN); // true

indexOf()

Returns the index or -1.

Fails with NaN.

[1, 2, NaN].indexOf(NaN); // -1 (broken check)

6. What is the purpose of splice()?

It mutates the array by adding/removing elements.

const arr = [1, 2, 3, 4];
arr.splice(1, 2, 99); // remove 2 items at index 1, insert 99
// arr ‚Üí [1, 99, 4]


First arg = start index

Second arg = how many to delete

Rest = items to insert

It modifies the original array.

7. How to remove duplicates from an array?

Fastest and cleanest:

const unique = [...new Set(arr)];


Alternative:

const unique = arr.filter((v, i) => arr.indexOf(v) === i);

8. Explain Array.prototype.sort()

The default sort is lexicographical, not numerical.

[10, 2, 5].sort(); // ["10", "2", "5"]


To sort numbers correctly, supply a comparator:

[10, 2, 5].sort((a, b) => a - b); // [2, 5, 10]


Sort mutates the original array.

Comparator function:

return < 0 ‚Üí a comes before b

return > 0 ‚Üí a comes after b

return 0 ‚Üí keep order
--------------------------------------------------------

How to flatten a nested array?
Flattening a nested array is trivial. You‚Äôve got multiple ways, and most people overcomplicate it. Here are the only methods that matter:

1. Use flat() (best and simplest)
const arr = [1, [2, [3, 4]]];
const flat = arr.flat(Infinity);


Infinity guarantees full flattening, no matter how deep the nesting is.

2. Use recursion (if you insist on manual control)
function flatten(arr) {
  const result = [];
  for (const item of arr) {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  }
  return result;
}

3. Use reduce() (same idea, different style)
const flatten = arr =>
  arr.reduce((acc, val) =>
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);

4. Use a stack (iterative, avoids recursion limits)
function flatten(arr) {
  const stack = [...arr];
  const result = [];

  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) stack.push(...next);
    else result.push(next);
  }

  return result.reverse();
}

Bottom line

If you‚Äôre in modern JavaScript:
Use arr.flat(Infinity) and stop overthinking it.
--------------------------------------------------------------------


Object & Functions
How to check if an object is empty?
You want to know if an object is empty? There are only a few correct ways. Everything else is noise.

1. The proper modern way
Object.keys(obj).length === 0

If there are no own enumerable properties, it‚Äôs empty.
This is the standard check ‚Äî stop pretending there‚Äôs something ‚Äúcleaner.‚Äù

2. Full check (keys, values, entries ‚Äî all identical result)
Object.values(obj).length === 0
Object.entries(obj).length === 0

Same logic. Same result.

3. JSON trick (works but unnecessary)
JSON.stringify(obj) === "{}"

Avoid it unless you enjoy wasting time and CPU cycles.

4. Defensive check (handles null or non-objects)
function isEmpty(obj) {
  return obj && typeof obj === "object" && Object.keys(obj).length === 0;
}


Blunt truth
If you‚Äôre not using Object.keys(obj).length === 0, you‚Äôre overcomplicating something that should take one line.
----------------------------------------------------------------------------------


Difference between Object.create() and constructor functions
Here‚Äôs the clean, no-nonsense breakdown.
Object.create() and constructor functions both create objects, but they operate on completely different mechanisms.

1. Object.create()

Creates a new object with its prototype explicitly set to whatever you pass in.

const proto = { greet() { console.log("Hi"); } };
const obj = Object.create(proto);


No constructor called

No this binding

No automatic property setup

Prototype is exactly what you choose

Perfect for simple prototypal inheritance

You're basically saying:
"Make an object that directly inherits from THIS object."

Prototype chain:

obj ‚Üí proto ‚Üí Object.prototype ‚Üí null

2. Constructor Functions

Use the new keyword to create objects.
They create:

a brand new object

this bound to that object

the object linked to FunctionName.prototype

function Person(name) {
  this.name = name;
}
Person.prototype.sayHi = function() {};

const p = new Person("Piyush");


Prototype chain:

p ‚Üí Person.prototype ‚Üí Object.prototype ‚Üí null


Constructors are essentially templates for object factories.

Core Differences
Feature	Object.create()	Constructor Function
How object is made	Direct prototype object	Uses new and a constructor
Prototype control	Explicit and manual	Prototype = Func.prototype
Calls a ‚Äúconstructor‚Äù	No	Yes (function runs with this)
Property initialization	Manual	Done inside constructor
Use case	Pure inheritance, simple protos	Instances, blueprints, OOP-style patterns
Short brutal summary

Object.create() = ‚ÄúGive me an object that inherits from THIS exact prototype.‚Äù

Constructor function = ‚ÄúRun this function as a class-like blueprint and attach its prototype automatically.‚Äù

If you want simple prototype chaining: use Object.create().
If you want class-like object construction: use constructors or ES6 classes.
--------------------------------------------------------


What are getters and setters?
Getters and setters are special object methods that let you control how properties are read and written.

They look like normal properties but behave like functions.

1. Getter (get)

Runs when you access a property.

const user = {
  first: "Piyush",
  last: "Kumar",
  get fullName() {
    return `${this.first} ${this.last}`;
  }
};

console.log(user.fullName); // "Piyush Kumar"


Looks like a property

Executes logic

No parentheses

2. Setter (set)

Runs when you assign a value.

const user = {
  first: "Piyush",
  last: "Kumar",
  set fullName(value) {
    const [f, l] = value.split(" ");
    this.first = f;
    this.last = l;
  }
};

user.fullName = "John Doe";
console.log(user.first); // "John"


Allows validation, transformation, side effects

Controls how data is stored

Why they exist

Hide internal logic

Validate inputs

Compute derived properties

Encapsulate behavior without changing the API

Short answer

Getters let you run code when reading a property.
Setters let you run code when writing to a property.
Both make method-like behavior look like simple property access.
--------------------------------------------------------------------


Explain function composition
Function composition is the process of combining multiple functions so the output of one becomes the input of the next.
It‚Äôs how you build clean, pipeline-style logic instead of writing bloated, repetitive code.

Core idea
If you have two functions:
const f = x => x + 2;
const g = x => x * 3;

Composition creates a new function:
const composed = x => f(g(x));

Call it:
composed(5); // f(g(5)) = f(15) = 17

You‚Äôre stacking behaviors without writing new logic.

A reusable compose function
const compose = (...fns) => (value) =>
  fns.reduceRight((acc, fn) => fn(acc), value);

Usage:
const double = x => x * 2;
const square = x => x * x;

const fn = compose(double, square);
fn(3); // square(3) ‚Üí 9 ‚Üí double(9) = 18


Why it matters


Forces small, pure, reusable functions


Eliminates duplicated steps


Makes logic predictable and testable


Builds pipelines without clutter



Short version
Function composition = chain functions together so each function feeds the next.
It‚Äôs the backbone of clean functional programming.
-----------------------------------------------------------


What are higher-order functions?

How to merge two objects in JavaScript?
1. What are Higher-Order Functions?
A higher-order function (HOF) is any function that either:


takes another function as an argument, or


returns a function.


That‚Äôs it. No mystique ‚Äî just functions manipulating functions.
Examples:
Built-in HOFs:
[1, 2, 3].map(x => x * 2);
[1, 2, 3].filter(x => x > 1);
[1, 2, 3].reduce((a, b) => a + b);

Returning a function:
function multiplier(x) {
  return function (y) {
    return x * y;
  };
}

const double = multiplier(2);
double(5); // 10

HOFs are the backbone of functional programming ‚Äî you abstract behavior, not data.

2. How to Merge Two Objects in JavaScript
There are only a few correct methods that matter.

Method 1: Spread operator (best)
const merged = { ...obj1, ...obj2 };



Rightmost object overrides keys from the left.


Clean, modern, readable.



Method 2: Object.assign()
const merged = Object.assign({}, obj1, obj2);

Equivalent to spread but older.

Method 3: Deep merge (if nested objects)
Spread and Object.assign() are shallow.
For deep merging, you need recursion or a library like Lodash.
Example (manual):
function deepMerge(a, b) {
  const result = { ...a };
  for (const key in b) {
    if (typeof b[key] === "object" && !Array.isArray(b[key])) {
      result[key] = deepMerge(result[key] || {}, b[key]);
    } else {
      result[key] = b[key];
    }
  }
  return result;
}


Short blunt summary


Higher-order functions = functions that take or return other functions.


Merging objects = use {...a, ...b} unless you need deep merging, in which case you must handle it manually.

-----------------------------------------------------------------------------


What is method chaining?

Explain the Factory Pattern

What is the Singleton Pattern?

How to prevent object modification?

‚öõÔ∏è React Native (50 Questions)
Core Concepts
What is React Native and how is it different from React?

Explain the bridge architecture in React Native

Difference between React Native and Flutter

What are the main components in React Native?

How does React Native communicate with native modules?

What is the difference between View and ScrollView?

When would you use FlatList vs ScrollView?

Explain the VirtualizedList component

What is the purpose of SafeAreaView?

How do you handle different screen sizes in React Native?

Components & APIs
Difference between TextInput and Text components

How do you handle touch events in React Native?

Explain the TouchableOpacity component

What is the ActivityIndicator component used for?

How do you implement pull-to-refresh?

Explain the Modal component

What is StatusBar and how do you customize it?

How to use the Alert API?

Explain the KeyboardAvoidingView component

How to handle device orientation changes?

Navigation
What are the main navigation libraries in React Native?

How do you implement stack navigation?

Explain tab navigation implementation

How to pass parameters between screens?

What is deep linking in React Native?

How to handle authentication flow with navigation?

Explain navigation lifecycle methods

How to prevent going back to a specific screen?

What is the purpose of navigationRef?

How to handle conditional navigation?

Performance & Optimization
How do you optimize React Native app performance?

What is Hermes and what are its benefits?

How to reduce bundle size in React Native?

Explain the useMemo hook in React Native context

When to use useCallback in React Native?

How to implement lazy loading of components?

What are the common performance bottlenecks?

How to use the Performance API?

Explain how to debug React Native apps

What is Flipper and how is it used?

Native Modules & Deployment
How do you create a native module?

What is CodePush and how does it work?

Explain the difference between development and production builds

How to handle different environments (dev, staging, prod)?

What are the app store submission requirements?

How to handle versioning in React Native apps?

What is Fastlane and how is it used?

How to implement in-app purchases?

Explain push notification implementation

How to handle deep linking in React Native?

üé® Styling (20 Questions)
Core Styling
What are the different ways to style React Native components?

Difference between inline styles and StyleSheet API

How does Flexbox work in React Native?

Explain the main Flexbox properties

How to handle responsive design in React Native?

What is the difference between width: '100%' and flex: 1?

How to implement dark/light theme?

What are styled-components and how to use them in RN?

How to handle platform-specific styles?

Explain the transform property in React Native

Advanced Styling
How to create custom animations?

What is the LayoutAnimation API?

How to use the Animated API?

Difference between Animated.timing and Animated.spring

How to create gradient backgrounds?

What is react-native-vector-icons and how to use it?

How to handle text overflow and ellipsis?

Explain zIndex and stacking context in React Native

How to create shadow effects on both iOS and Android?

What is the PixelRatio API and when to use it?

üóÉÔ∏è Redux (30 Questions)
Core Concepts
What is Redux and why is it used?

Explain the three principles of Redux

What are actions in Redux?

What are reducers and how do they work?

What is the Redux store?

Explain the Redux data flow

What is the difference between Redux and Context API?

When should you use Redux vs local state?

What are action creators?

How to handle asynchronous actions in Redux?

Middleware & Async
What is Redux Thunk and how does it work?

How is Redux Saga different from Redux Thunk?

What are Redux middleware and how do they work?

How to implement custom middleware?

Explain the applyMiddleware function

How to handle side effects in Redux?

What is redux-persist and how to use it?

How to implement optimistic updates in Redux?

What is normalizing state shape?

How to handle errors in Redux?

React-Redux & Tools
What is the connect function in react-redux?

How to use the useSelector hook?

How to use the useDispatch hook?

What is the purpose of the Provider component?

How to structure a Redux application?

What is Redux Toolkit and why is it recommended?

Explain createSlice in Redux Toolkit

What is createAsyncThunk and how to use it?

How to use Redux DevTools?

How to implement code splitting with Redux?

üîÑ TanStack Query (20 Questions)
Core Concepts
What is TanStack Query and what problems does it solve?

How is TanStack Query different from Redux?

Explain the main concepts of TanStack Query

What are query keys and how are they used?

How does caching work in TanStack Query?

What is stale time vs cache time?

How to handle pagination with TanStack Query?

Explain infinite queries

How to implement prefetching?

What is background fetching and how does it work?

Advanced Features
How to handle mutations with useMutation?

What are query invalidation strategies?

How to implement optimistic updates?

What is the QueryClient and its responsibilities?

How to handle errors in TanStack Query?

What are query retries and how to configure them?

How to implement dependent queries?

What is the useQueries hook used for?

How to handle offline support?

How to test components that use TanStack Query?

üéØ Quick Preparation Tips:
For JavaScript:

Practice array methods and async/await patterns

Understand closure and this keyword thoroughly

Be ready to write code snippets

For React Native:

Focus on performance optimization techniques

Know navigation patterns thoroughly

Understand native module integration

For State Management:

Compare different state management solutions

Understand when to use each tool

Be prepared to discuss trade-offs

General Tips:

Practice explaining concepts in simple terms

Have real project examples ready

Be honest about what you don't know

Show enthusiasm for learning

Good luck with your interview! Remember to relate answers to your 1-year experience with specific examples from your projects. üöÄ